---
#layout: mypost
title: 高效能程序员的修炼
categories:
- [博览群书]
tags:
- 博览群书
---

[goodreads](https://www.goodreads.com/book/show/15746409-effective-programming)

[豆瓣读书](https://book.douban.com/subject/24868904)

### 目录

- 入门须知

  - 程序员的八种境界

    1.**不朽的程序员这是最高境界！虽然人已经走了，但是他的代码却依然活着。**他成为计算机博物馆中的一个永久收藏。其他为数众多的程序员都在学习他的作品。他在生前可能得到过图灵奖，或者发表了大量有影响力的论文，或者是发明了一些影响到计算机专业课程设置的基础技术。他已经不仅仅只是拥有一个维基百科的条目，事实上，有很多专门的网站来讲述他的作品以及他生平的事迹。在人的有生之年能够达到这一境界的程序员屈指可数。代表人物：Dijkstra、Knuth、Kay。译者注：Dijkstra是一名荷兰的计算机科学家，他因发明了计算机编程语言而于1972年获得了图灵奖。Knuth是《计算机程序设计艺术》一书的作者，他被称为算法分析之父。Kay是一名美国的计算机科学家，是面向对象编程、视窗图形用户界面设计的先驱者，他有一句名言是：“预测未来的最好办法是创造未来。”

    2.成功的程序员成功的程序员不仅拥有广泛的知名度，同时还运营着一个不错的公司，甚至控制了整个产业链。他们拥有绝对的自由，可以做着自己想做的事情。他们同时还有着把“自由”带给广大程序员同胞的梦想。这一境界的程序员最受人羡慕。要到达这一境界，更多的是需要商业上的才能，而不是你的编程能力。代表人物：比尔·盖茨、Carmack、DHH。译者注：比尔·盖茨是微软公司的创始人，他是个电脑神童，13岁开始编程，20岁开始领导微软；他同时也是个商业奇才，他利用自己的远见卓识和精明的商业头脑让微软名噪天下，把软件做成了人们生活中不可或缺的东西，成就了今日的微软帝国。Carmack是Id软件公司的创始人，该公司主要从事电脑游戏以及游戏引擎的开发，作品有《半条命》、《反恐精英》、《毁灭战士》等。DHH是一名丹麦的程序员，他建立了“RubyonRails”Web应用架构,并与人合写了《Web开发敏捷之道：应用Rails进行敏捷Web开发》一书。

    3.知名程序员进入这一境界的程序员也不错，当然前提是，你得有一份不错的工作。这个境界的程序员虽然在圈子里很有名，但是成为名人并不意味着你可以靠这个赚取收入并且养活自己。出名固然不错，但成功更为关键。你可能在一家非常知名的大型技术公司工作，也可能在一家很有影响力的小公司，或者是在一个很有希望的创业团队。不管怎么样，其他的程序员都或多或少地听说过你，并且你对你所在的领域有着积极的影响。

    4.胜任的程序员你作为一名软件工程师非常成功，因为你的能力使你在工作中游刃有余。你从来不会为找一份满意的工作而发愁。你的同事也非常尊敬你。每一家你工作过的公司都因为你的加盟而在某些方面得到了提升。**但问题是：你接下来的方向在哪里？**

    5.普通程序员这个境界的程序员能够基本应付一般的编程工作。他们自己也很清楚，由于天资所限，他们很难成为杰出的程序员。其实，天赋跟成功的关系并不大。如果你有敏锐的商业嗅觉和不错的人际交往能力，你依然可以变得很成功。如果你是一个普通的程序员，但你还能靠这一行当过上不错的生活，那已经说明你是很有才的，只是你不必非得干程序员这一行。人贵自知之名。通常你的能力都会比你自认为的要低。缺乏天赋并不是什么大不了的事情。要勇敢一点，发掘自己的特长，并且充分地加以发挥。

    6.**业余程序员业余程序员通常都热衷于编码。**他们可能是一些很有前途的学生或实习生，也可能正在参与某些开源项目，或者利用个人闲暇时间开发一些“好玩的”应用程序或网站。从他们的代码和创意可以看得出，他们是一群很有想法、充满激情的人。成为一名业余程序员是件好事。这个境界的程序员可以通过自我提升，很快速地胜任程序员这个职业。

    7.低调的程序员还有一些坊间流传的比较有个性的程序员，比如JoeCoder，很有能力但是没啥令世人瞩目的成就。他们可能服务于某家大型公司。对于这些人来说，写代码仅仅是份工作而已，并非他们生活的全部。这没什么错，挺好的！

    8.**烂程序员这个级别的程序员技能极其匮乏（已无境界可言），他们通常是因为某些阴差阳错的原因才干上这一行的。他们所做的任何事情都会给他们的同事带来痛苦和灾难——当然可能也有一个例外，就是他们的同事也是一帮差劲的程序员，差到连身边全是一帮烂程序员都意识不到。如果要给烂程序员下一个定义的话，那就是：没有金刚钻，却偏偏揽了瓷器活。应该承认，以上所有的这些境界定义得并不严谨。其实，不是所有的程序员在他们的职业生涯中都渴望相同的东西。思考一个程序员在他10年、20年、乃至30年、甚至一生的时间内所能达到的成就，是非常有意义的！想一想，你最崇拜哪个程序员？到底是他的什么成就，使得你对他有如此的崇拜？**

    话说回来：你究竟想要过怎样的生活？

- 把一堆烂事搞定的艺术
  - 磨刀不误砍柴工

    有个人在山间漫步，偶遇一位伐木工。他便停下来观察这位伐木工，看他热火朝天地锯一棵很大的树。他发现这位伐木工干得大汗淋漓，不停地锯来锯去，但是没有丝毫的进展。这个过路人注意到伐木工所使用的锯子已经和黄油刀一样钝了。于是，他就对伐木工说：“不好意思，伐木工先生，我看着你已经很使劲地在锯那棵树了，但为什么进展不大呀？”伐木工回答道：“是呀……我也知道。不过，看起来这棵树不好对付啊！”此时，汗正从他的眉毛间滴落下来。过路人于是提醒道：“伐木工先生，这不是树的问题，是你的锯子太钝了。这么钝的锯子什么东西也锯不断的！”“我知道。”伐木工回答说，**“但是，我连锯树都忙不过来，哪有时间磨锯子啊！”**

    大家都知道，如果想要在某方面有所提高，最好的办法就是勤加练习。但是，如果你只顾着埋头写代码，连讨论、反思或者学习的时间也没有了，其实你得不到真正的进步。**你必须在磨练工艺与思考如何提高工艺之间找到一个适当的平衡。**

    **当然，过多地磨锯子，或者随意地、没有目标地磨锯子，会变成另外一种形式的延误**。然而，如果一个程序员对这些完全不感兴趣，那也是一个巨大的危险信号。就像Peter Bregman说的那样，“痴迷可以是一件好事”：

    > 人们成功常常不是因为他们克服了自己的机能障碍，反而是这些障碍成就了他们。痴迷是通向成功的一个最明显的风向标。如果理解了一个人的痴迷，你就会理解他最自然的动机—他会为之坚持走到世界的尽头。

    对磨锯子有些痴迷是没有问题的，但前提是，你的痴迷是类似Hackers News的网站上积极地提交和讨论与编程相关的文章。

    作为一名程序员，你对如何磨快锯子有更好的建议吗？

  - 一路向前冲

    **沿着那条路下去，一定要快。如果有什么东西挡住了你的去路……绕开它！**

  - 关于多任务的神话

    **根据Weinberg的计算，哪怕只是在你的工作负荷中增加一个项目，也会严重地影响你的效率。你会损失20%的时间。当你增加第三个项目的时候，你有将近一半的时间浪费在任务切换上面。**

    **即便你同一时间只做一个项目，这种问题也可能会发生。轻易让电子邮件、电话以及即时消息打断你正在进行的工作，其影响可能是深远的，就像BBC的这个研究中所记载的那样：**

    > 英国精神病学研究院所做的这个研究表明，**过度地使用科技会降低工作人员的智力。**研究员得出结论：**那些常被电子邮件和电话干扰的人，他们的智商会有10个点的下降——跟研究发现的吸食大麻所引起的损害相比，前者是后者的两倍还多。**

    通常情况下，我会拒绝“同时做多个项目”这样的要求。说“不”也许很难，因为软件开发者往往过于乐观，这是他们众所周知的职业性“毛病”。

    **我们常常高估自己的能力，而关于多任务的神话让我们的内心更加膨胀。但是，只要有可能，请远离干扰，并且避免同时做多个项目。如果实在避免不了，关于你在多任务并行的情况下实际能做多少事情，请你自己保持清醒的认识，也坦率地让其他项目干系人知道。你很可能会力不从心！**

- 高效编程之原则

  - 第一条发展：永远都是你的错

    老是要处理一些困难的、捉摸不透的问题，这是一件令人绝望的事情，但是不要让绝望领着你误入歧途。作为一名谦逊的程序员，最基本的要求就是要有意识：**你写的代码在任何时候出了问题，那一定都是你的错。**

    代码产权的另一面是代码责任。**无论你的软件出现什么样的问题——甚至最开始出错的地方根本就不是你的代码——你也应该总是假定问题出在你的代码里，并且根据这个假设采取行动。如果你想让世界人民接受你的软件，那你就要为它的故障承担全责。尽管——从严格意义上来说——你并不是非这么做不可。只有这样，你才能赢得尊敬和信用。如果你不断地把问题推卸到其他人、其他公司或者其他的源头上，你是无论如何也得不到尊敬和信用的。**

  - 避免写注释

    尽管注释本身说不上好或者坏，它们却常常被用作支撑代码的“拐杖”。**应该总是专注于编写代码，而忘了还有注释这种东西的存在。这会迫使你竭尽全力使用最简单、最直白、最能自我说明的方式把代码写出来。**

  - 学会阅读源代码

    有些时候，文档是不完整的。有些时候，它干脆就是错误的。**源代码是从来不会撒谎的**。对于一名有经验的程序员来说，阅读源代码通常会更快些（尤其在你已经熟悉了软件包架构的情况下）……我现在和几个创业公司在一个中等规模的共享办公区域里一起工作。很多其他公司的首席技术官和工程师都时常跑到我们团队来寻求指导和建议。当他们带着有问题的软件过来的时候，我问他们的第一个问题就是：“嘿，你看过源代码了吗？”

    我鼓励开发人员“git clone”他们依赖的所有源代码。起初，他们都有些害怕。“那个项目太大了。我永远也无法把问题找出来！”“我没那么聪明，看不懂那些代码。”“那些代码太难看了！简直惨不忍睹！”**但是，你不必把那些代码翻个底朝天，而只需要跟着线索走**。况且，如果你不能理解你所依赖的平台，你又怎么能驾驭你自己的软件呢？在大多数情况下，菜鸟程序员认为漂亮的，往往止于肤浅；而他们认为丑陋的，往往是骇客大师们所写的久经考验的产品级代码。现在，在经过了一两年之后，有几个开发人员专程过来找我，感谢我当初强迫他们在别人的代码里“潜水”或者“畅游”。他们现在的技能都比以前大有长进，而且他们还感叹：真不知道过去在没有别人源代码的时候是怎么把事情做好的……

    **真正的骇客世界里只有一个简单的事实：如果一个软件在我的机器上运行，那它就是我的软件**。我对它负责。我必须把它弄明白。从源代码开始构建是一条必须遵循的原则，而且从不例外。我必须控制我的环境，我还要控制所有我依赖的东西。

  - 向橡皮鸭求助

    - 在Stack Exchange上，我们坚持要求提出问题的人需要在自己的问题上多下些功夫，而且我们在这方面有些偏执。那就是说，当你开始要提问题的时候，你应该：

    - 用足够多的细节来描述发生的状况，这样我们可以顺着你的描述继续研究下去。即使在你所在的特定领域里我们并不是专家，你也要向我们提供必要的背景情况，这样我们可以了解到底发生了什么事情。

    - 告诉我们你为什么需要知道答案。你怎么会出现在这里？是闲来无事的好奇，还是在某个项目里遇到了障碍？我们不是要求你长篇大论地讲生活故事，只是想了解跟你的问题相关的一些基本情况。

    - 说一说为了解决这个问题你都做过什么研究，以及你的发现（如果有的话）。如果你没有做过任何研究，你应该来这里提问题吗？

    - 归根结底，这关乎公平：如果你想要我们花上宝贵的时间来帮助你，只有在你也花了相当的宝贵时间酝酿出一个合格的问题时才算公平。帮我们也就是帮你自己！

  - 当我自己解决了自己的问题，我该怎样感谢社区呢？

    - 迄今为止我只贴出了一个问题，第二个问题差一点就贴出去了。**在我写两个问题的过程中，我自己找到了答案（至少是部分答案）。我把这归功于网络社区和提问流程，因为它们促使我自己思考答案**。在我所写的东西里，没有任何内容明确地指明了我要的答案。**但是在我把它们写下来的过程中，某种东西让我用额外的思维方式去思考问题**。

    **为什么适当地组织你的问题通常能让你自己找到答案？**

    我已经记不清这样的情况发生过多少次：

    - 我碰到一个问题；

    -我决定把这个问题提到Stack Overflow；

    - 我很笨拙地写下我的问题；

    - 我意识到这个问题根本就说不通；

    - 我花了15分钟重新思考该如何提出我的问题；

    - 我意识到我正在一个完全错误的方向上解决这个问题；

    - 我从头再来，然后很快就找到了解决方案。

    - 你也有过这样的情况吗？有时候，提出正确的问题差不多就已经把问题解决了一半。

    - 开始提出问题实际上促使我自己诊断自己的问题。

    为了得到满意的答案，当我尝试组织一个内容连贯且信息翔实的问题时，提问题的动机实际上促使我自己诊断自己的问题。这在别人身上也发生过吗？

    这不是一个新的概念。如果给予足够的时间，每个社区似乎都能自己意识到这个问题。但是，“问鸭子”确实是一个非常有效的解决问题的技巧。

  - 创新以人文本

    一个好的创意值多少钱？Derek Sivers1认为，不值多少：

    当我了解到人们都在紧张兮兮地保护创意，我觉得很好笑。（有人要求我签署一份保密协议，然后才肯告诉我一个简单得不能再简单的创意。）对我来说，**除非创意能被执行，否则它一文不值**。执行是创意的倍增器。真正价值巨大的是“执行”！

    如果你想要创业赚钱，你必须把这两者相乘。最杰出的创意，如果没有执行，那也只值20美元。最杰出的创意需要卓越的执行才能值2000万美元。这就是我不想只听人们的创意的原因所在。在没看到他们的执行力之前，我对他们的创意一点儿都不感兴趣。

    创意与执行之间的鸿沟是如此巨大，以至于我很费解：为什么作者自己看不到？！

    我不会说创意本身毫无价值，但是很显然，单有创意只是空头支票。**成功很少是由创意的质量来决定的，但它时常由你执行的质量来决定**。因此，与其担心你全心投入的下一个大创意是否足够出色，不如担心你能执行得多好。

    不要批判那些“超有默契的人”，他们正是你取得成功所必需的；这个在Stack Overflow上同样备受推崇。具有讽刺意味的是，Andy Baio（就是在上面邮件里被点名的那个人）在去年给我的一封邮件里说道：

    我非常喜欢Hacker News网站上那个关于用一个周末的时间就克隆一个网站的讨论。我最欣赏的评论是，有人相信Stack Overflow之所以成功仅仅是因为人们对Atwood和Spolsky的狂热崇拜。太令人惊异了！

    不管你在互联网上有多么出名，都不可以跳过“执行”这一步。当然，你可能在刚开始的时候会吸引更多的眼球，但如果你没能做出来一些有用的东西，整个世界最终会齐刷刷地耸耸肩膀、转去那些更加有用的地方。

    **在软件开发领域，执行意味着专注于构成你的应用程序的所有微小细节。如果你不是始终沉迷于你的应用程序的每个方面，不去持续优化和改进它的每一处细节（无论多么微不足道），那么你就不是在执行。至少，不是在很好地执行。**

    除非你是一个人工作的（如今已经非常少见了），否则，你掌控构成你的应用程序的所有细节的能力完全取决于你能否组建一支很棒的团队。他们是成功的必要元素。这段来自Ed Catmull的演讲4，几乎完全专注于皮克斯5是如何通过尝试和失败学会组建具有执行力的团队的。

    这是一次引人入胜的演讲，过程中充满了令人惊叹的见识。你应该把这段视频完整地看一遍。在演讲中，Catmull先生延伸了Sivers先生的观点：

    如果你把一个好的创意给一个普通的团队，他们会把它搞砸。如果你把一个普通的创意给一个好的团队，他们会对它加以完善。或者，他们会把那个创意丢掉，然后想出一些更棒的。

  - 你的团队能通过电梯测试吗

    **软件开发者认为他们的工作就是编写代码。其实不然。（这句话是我从Billy Hollis那里“偷”来的**。他曾以软件痴迷者为主题做过15分钟的精彩演讲。）**他们的工作应该是解决客户的问题**。当然，我们偏爱通过软件来解决问题，那的确包含了编写代码。但是，我们要有全局的观点：编写代码是我们为了交付解决方案所必须完成的其中一环。它自身并不是目的。

    作为软件开发者，我们花了那么多时间沉浸在没完没了的、支离破碎的细节中，以致于我们太容易掉入为了编码而编码的陷阱中。如果没有明确的焦点或者某种让我们团结在一起的东西，我们就会只见代码这棵树木而看不见整个森林。由此可见，拥有一个清晰的项目远景声明（Vision Statement）是极其重要的，每个人都可以把它当作这个项目的试金石。如果你把远景声明搞清楚了，你团队里的每个人都应该能通过由陌生人主持的“电梯测试”——在60秒之内，清晰地解释他们在做什么，以及为什么人们会在意他们正在做的事情。

    我发现有一个做法在让整个团队思考产品远景方面很有效果，那就是“设计产品包装盒”。这个练习可以在项目启动阶段很好地激发大家的思维和讨论。整个团队假设产品最终会被装在一个可拆封的盒子里，而他们的任务就是设计这个包装盒的正面和背面。这包括给产品起个名字、一副图片、正面列出3~4个关键点来“叫卖”这个产品、背面的详细特性说明、以及运行要求。

    **实践证明，想出15~20个产品特性是容易的。难就难在，要选出其中3~4个能促使人们购买这个产品的特性。这个过程中还经常会发生关于“谁是真正的客户”的激烈争论**。

    “设计产品包装盒”是构建远景声明的一种极好的方法。它基于一个具体的、真实世界里的概念，因此大多数人都可以轻松地开动他们的脑筋。忘掉那些空中馅饼式的远景追求吧，让我们务实一点：我们（假想）的产品包装盒看起来会是什么样的呢？

    我们都是消费者。我们对产品包装盒的设计目标都很清楚。如果不拿产品包装盒跟极端的“电梯推介”相提并论，那它也应该：

    - **用最简单可行的方法来解释我们的产品是什么**；
    - **把潜在客户愿意购买这个产品的原因解释得一清二楚**；
    - **与货架上所有其他的产品包装盒相比具有独一无二的辨识度**。

- 招聘程序员须得其法
  - 怎样招聘程序员
    1. 首先要求通过几个简单的“Hello World”在线测试

    2. 提出要看看他们的文件夹

        看看应聘者以前做过什么样的工作，他在网上展示了什么样的作品，这对了解这个人是极其有帮助的——通过这些，可以去理解他做过的东西，并且判断出他擅长什么（或者不擅长什么）。

    3. 只雇佣认同公司文化的人

    4. 进行一个周详的结构化电话面试

        **不要期望从电话的另一头得到完美的答案，也没这个必要。你需要了解的只是这个人解决问题的方式，还有他们是否真的掌握了相关的技术（上下浮动10%）**。你的目标是，不要让一些不合格的人蒙混过关，否则到了下一阶段会浪费大家更多的时间。因此，你不要心慈手软，要对电话另一头保持火力，而当发现有太多疑点之后，提前结束通话。

    5. 给他们一个“试镜”项目

       到这时候，应聘者已经通过了“Hello World”编程测试，他的“文件夹”里的东西也很光彩夺目，他融入公司文化没有丝毫的问题，他也成功通过了电话面试。是时候把他叫过来进行面对面的面试了，对吗？别这么急，兄弟！

       我见过一些应聘者通过了前面4关，然后加入了公司，结果在实际项目中还是表现不佳。我没有提醒你吗？招聘程序员是很难的！

       这位候选人会不会是一个成功的聘用呢？如果你还心存疑虑，想要抹去这层阴影的最好办法，就是给他一个“试镜”项目。我指的不是那种空泛的、抽象的编程问题，而是现实世界里、实际项目中你需要马上做的一块实实在在的工作。这块工作你原本是打算让正式员工做的，只是他们现在都在忙着其他的事情，因此这块工作暂时还没分配出去。

       这个项目应该以常规的咨询服务的形式进行，按小时计费，并且清晰地定义好项目任务书。**选择的项目一定要小，理想情况下几天就能做完，至多1~2周**。候选人可以进办公室来做这个项目，或者也可以远程登录过来。我知道，不是所有的公司都能提供这种“一口大小”的工作分给公司以外的人来做。（他们拼死了也想把所有的事情都在公司内部做完。）但是，我就想了，如果你费劲脑汁还是想不出一个迷你的“试镜”项目给一位很不错的候选人做（你很有可能把这个人招进来哦），也许你在现有员工之间的工作分配方面也存在一些问题，至少不够结构化。

       如果“试镜”项目做成了，那就太美妙了——你现在得到了一位高度合格的候选人，他的做事能力得到了验证，而且你还有效地给实际项目完成一些工作。迄今为止，我还没见过有谁通过了“试镜”项目的考验但后来还在实际项目中表现不佳的。我非常依赖“试镜”项目来考察一个人的能力；做这种项目实际上跟做正常的工作很接近了，就差没把人家聘用进来了。不过，如果“试镜”项目失败了，也不要紧，想想也就浪费一点点咨询服务费，跟把候选人直接叫进公司、浪费公司的其他4~5位同事的时间去面试他相比，其实还是挺划算的。况且，你还可以把这个“试镜”项目传给下一位有潜力的候选人去做。

    6. 找个房间面谈，并最后定夺

    7. 上面没有哪条是保证奏效的

  - 如何做好电话面试筛选

    1. 不要让候选人主导面试过程。大部分时间都应该是面试官在说话。面试官要引导整个对话过程，直到自己满意为止（要么确认候选人知道答案，要么候选人放弃了）。

    2. 小心只会一招的"小马驹"。**只会一种特定的语言或编程环境，并且对其他东西一窍不通的候选人，小心啦，这是一个巨大的红色警告信号**。

        电话面试的目的，不是让候选人复述他们做过的事情。面试官应该把他们从舒适区推出去一点，问他们一些相关的问题，但那些又是他们以前没见过或没做过的。理想情况下，你要了解这个人在面对新事物（比如你的代码库）的时候会做出什么样的反应。

        为了让电话面试进行得更加顺畅一点，我在下面罗列了你在面试软件开发工程师时需要问的5个基本问题。它们不能保证你会找到最棒的候选人，但能阻止相当一部分的人蒙混过关。

        **1）编程。候选人需要用C、C++或Java写一段简单的代码，要求语法正确。**

        **2）面向对象（Object Oriented，简称OO）的设计。候选人需要说清楚OO的基本概念，并且想出一些类来为一个简单的问题建模。**

        **3）脚本编程和正则表达式。候选人需要描述一下，如何在50000个HTML网页里把电话号码都找出来。**

        **4）数据结构。候选人需要证明他对最常用的数据结构都有着基本的理解。**

        **5）位与字节。候选人需要回答几个关于位、字节和二进制数字的简单问题。**

        请注意：我们这里想要发掘的，是在前面所说的某一方面完全无知的人。如果他们挣扎了一下，然后还是回答出来了，也就算过了。他们甚至可以要求一点小小的线索或提示。我不介意他们反应迟钝或动作缓慢。我们要找出的，是那些对问题中所涉及的领域极端困惑、毫无头绪的候选人。

  - 工作经验年数之神话

    在招聘过程中，纵然你的电话面试筛选工作做得非常出色，有个概念还是常常会被扭曲。在澳大利亚有一家名叫Flat Rate Recruitment的人才中介公司，他们的Andrew Stuart曾经给我写信，向我讲述了一个非常好的故事。我把它摘录如下，恰好来说明这个问题：

    我有个客户正在开发一个关于安全方面的高级应用程序。我给他们输送人才，一个接着一个，结果候选人统统都被退回来了。究其原因，几乎无一例外都说这些人"没有足够的底层编码经验"。然而，我送去的人都做过像设计并开发操作系统、高级内存管理等这样的事情，或者开发过其他高度复杂的应用程序。但我的客户不感兴趣。他们要求候选人前一份工作做的是在某个特定领域内的底层编码，并且要有实际经验。幸运的是，我最终找到了一位候选人-他是一位非常聪明的软件工程师，他几乎单枪匹马完成了一款优秀的电脑模拟器-但是，在客户所要求的特定领域里，他几乎没有任何底层编码的经验。

    我告诉客户："我现在有个很棒的小伙子，虽然他没有底层编码经验，但我认为你们应该雇用他。"他们一开始持极其怀疑的态度。我力劝，一定让他们给个面试的机会，"瞧，这小伙子是个超级棒的软件工程师，虽然他现在没有你们所要求领域内的底层编码经验，但只要你们雇用他，给他3～6个月的时间，他一定能够成为你们想要的那种有底层编码经验的超级棒的软件工程师"。

    他们后来面试了他，并且雇用了他。也就是几个星期的时间，他很快成为那家公司最聪明的程序员。他快速掌握了他们的底层编码技术，他的学习能力比公司里的其他人都要出色。每次我跟那个客户联系的时候，他们都要对这位员工大加赞美一番，因为他已经成为那家公司的技术骨干。自那以后，那家公司已不再把招聘重点放在那些过往工作经验和所需技术完全匹配的候选人身上。**取而代之的是，他们开始专注于寻找并雇用最聪明、最富有热情的工程师**。

    从我记事的那天起，关于工作经验年数的神话就已经在软件行业里广为流传了。但它是有害的，效果往往会适得其反。不难想象，就是因为很多公司都痴迷于雇用经验和技术完全匹配的人，结果造成很多才华横溢的软件工程师都被拒之门外。

    他们似乎已经忘记了，软件开发者最擅长的就是学习。**雇主应该找的是富有热情、有干劲、脑子灵活、自学能力强，并且证明了有能力用任何语言编程的人，然后就是找一些有趣的项目让他们施展才华**。

    工作经验年数与编程技能之间是没有必然联系的。这已经一次又一次地被证明过了。在任何特定的技术领域工作过6～12个月之后，你要么是精通了，要么就这样一直混下去了。不管其他程序员宣称他们有多少年的"经验"，其实都不重要，他们甚至很可能仍然对他们正在做的事情一窍不通。为什么杰出的程序员很快会变得以一定程度的厌世怀疑态度去看待他们的同事们呢？原因就在这里。也许这是唯一合理的解释，那就是经验和技能之间的背离在软件工程领域已经是相当普遍了！

    了解了这些之后，如果你看到一家公司在它的招聘过程中还在一味地追求工作经验年数这样的神话，你还会想去这家公司工作吗？也许不会吧。

    于是，我有了这样的一个观点：**在你的招聘广告里写"要求在X平台上有Y年的工作经验"是很愚昧的！只要应聘者有6个月或1年的工作经验，那就不要再去比工作年数啦**！转而去关注其他能够表现出能力差异的方面吧！平台经验只是一个基准线，它不应该成为一个至关重要的考量因素。

    换个角度来说，如果你正在找工作，你就可以根据像"3～5年的某某技术经验"这样的招聘要求，来判断这个公司的用人之道。他们对某个特定技术领域的服务年数要求越高，就越有可能完全不知道怎么招人，因而他们组建的团队也很可能都是些平庸之辈。

    我并不是说工作经验在软件开发方面无关紧要。恰恰相反，经验是很重要的。但是，我们得全面考量一个开发人员的经验，并且认识到，人们投入的时间并不会自动转化为技能；否则，你可能会把一些超级棒的软件工程师拒之门外，仅仅是因为他们在你要求的狭小技术领域内缺少"N年的工作经验"-这样就太可惜了！

  - 与程序员面谈

    在30分钟的面试时间里，你怎样才能识别出那些有潜质的软件开发者？关于这个话题，Artima Developer网站上有一篇很不错的圆桌论文，题为"How to Interview a Programmer"（怎样面试程序员）-它汇聚了很多知名程序员的建议：

    - 在一个专业技术领域深入试探

    - 让他们评论一件事情（或一样东西）

    - **请他们解决一个问题**（但不是回答一个谜题）

    - **查看他们的代码**

    - **询问他们看过什么书**

    - 问一个关于人的问题

    - 把他们招进来试用

    Joel Spolsky在面试程序员方面也有一些独到的见解，他的指导原则可以归纳为"人要聪明，能把事做好"：

      1. 自我介绍

      2. **针对最近的项目提问**

      3. 提一个难以回答的问题

      4. **写几个C函数**

      5. **给他一段代码，问他是否满意**

      6. 设计问题

      7. 用难题来挑战他

      8. **问他有什么问题**

- 促使团队紧密协作

  - 不管怎么说，那总是人的问题

    Bruce Eckel 巧妙地指出了所有软件开发问题的根源：

    我们身处一个新兴产业中。很原始，真的-我们对真正有用的东西知之甚少，而且我们总是认为我们已经找到了可以解决一切问题的"银弹"。结果呢？这么多年来我们一直在经历从繁荣到萧条的轮回：新的想法出现、进一步发展、失去控制、偃旗息鼓。不过，有些理念似乎有持久力。例如，敏捷方法论里的很多理念看起来在生产力和质量方面正在产生着实质性的影响。这是因为它们更多关注了在一起工作的"人"的问题，而更少关注"技术"的问题。

    我从Gerald Weinberg那里学到了很多。他最早写的几本书都是关于编程技术的。后来他转变了方向，撰写了（包括与人合写）50多本关于软件开发流程的书。他还有一句名言："不管他们告诉你什么，那总是人的问题。"

    项目的成败通常都是因为流程和人员的问题-你每天的工作方式；你的架构师、你的经理以及和你一起工作的编程团队成员；你是如何沟通的，最重要的是，当流程和人员出现问题时，你是如何解决它们的。让你陷入困境最快的方法，就是认为技术是决定性的因素，而且你相信你能轻易解决其他方面的问题。事实上，那些其他方面的问题最可能让你止步不前。

    Bruce把Gerald Weinberg的原话记错了，它应该是"不管什么问题，那总是人的问题"。但是，Bruce的重述有一种不可言喻的真实感，当然也忠实于Gerald Weinberg原话的精神。

    假设我现在有个任务，要去判断你的软件项目是否会失败。我手上有3个问题，当我得到你对它们的回答时，我几乎可以肯定地宣判你的项目结果：

    1．你的团队将会写多少行代码？

    2．你们在开发什么样的软件？

    3．你喜欢你的同事吗？

    最后的那一个问题不是笑话。我是在说正经的。从个人角度出发，你是否喜欢你团队成员的陪伴？你是否在专业上尊重你的团队成员？假设你换工作到了另一家公司，你是否会邀请你的同事一起过去？你们是否有令人振奋的团队讨论，还是那种打倒、拖出去，直到最后一个站着的强人说了算的争论？在你的团队里，是否有你想要"投票赶下岛"的人（如果你可以这么做的话）？

    让你关注跟你一起工作的"人"，而不是那些实实在在的事情（例如，实际的工作或者你工作中所用的特定技术），这听起来可能有点本末倒置，但事实上并非如此。我发现，**从你选择的跟你一起工作的人身上能最准确地预测工作满意度。而根据我以前的经验，工作满意度和成功有着密切的联系**。我还从来没有看到过一个快乐、健康、有凝聚力、社交正常的软件开发团队失败过呢！遗憾的是，这样的团队太少了。

    就像Gerald Weinberg所说的，那总是"人"的问题。如果你不是和你喜欢的人、你尊敬的人、会挑战和激励你的人一起工作，那你为什么不去找到这些人呢？是什么在阻止你？

  - 领导须以身作则

    开发团队需要遵守纪律才能从现代软件工程规范中获益。如果你的团队没有正确的工程纪律，那么你们所使用的工具和流程几乎都起不到什么作用。这一点，我已经在“Discipline Makes Strong Developers”（纪律造就强大的开发者）一文中着重论述过了。

    有人提议，应该在团队里配备一位像枪炮士官哈特曼那样的资深训导员，以强化工程纪律。一些评论者对此表示了担忧。这也在情理之中。

    你这个臭小子！我知道你的名字了！看我怎么收拾你！我看你还笑得出来吗？你会想哭都哭不出来的。你必须一条一条学下去。我会教你的。

    对于软件开发者来说，以哄骗或痛斥的方式让他们服从不是一个有效的激励方法。至少在我的经验里，那行不通。**如果你想提高团队的工程水平，你需要一个领导，而不是靠一个训导员去强制执行。其目标并不是给所有的同事洗脑，而是要和他们一起协商出大家都能接受的标准**。

    Dennis Forbes曾经发表过一篇文章，题目为“Effectively Integrating into Software Development Teams”（有效地融入软件开发团队）。我觉得他很出色地概括了关于有效领导方面的策略。他用一封假想的电子邮件开头（根据我对Dennis的了解，这也可能是他的亲身经历），描述了被人当作强制执行者的弊端：

    我最近被拉去帮助一个软件开发团队完成一个产品的开发，具体的要求是协助一些Web应用程序的编码。我尽了自己最大的努力去融入这个团队，热心地帮助他们，以赢得一些信誉和尊敬。

    我时常转发“Joel on Software”上的各种小文章给大家，还建议在公司里摆上一堆像《代码大全》、《人件》以及《人月神话》之类的书籍。不管任何事情，只要我觉得可以做得更好，我都会尽力给大家指出来。我经常浏览源代码库，以找出可以让其他成员工作得更好的方法。

    当其他开发者来向我寻求帮助的时候，我不仅帮他们解决实际的问题，我还举一反三——指出他们在开发方式上的问题，教他们怎样改进打字形式，告诉他们该使用哪种命名规范，提倡一种更好的代码编辑工具，并且对究竟应该使用存储过程（Stored Procedure）还是动态SQL的争论给出我训练有素的最终结论。

    然而，所有这些努力似乎都不起作用，我还是会常常受到他们的抵制，而且我觉得整个团队不是很喜欢我。我的很多建议都没有被采纳，而且我觉得有些人给我的回应是毫不掩饰的讽刺。

    我到底哪里做错了？

    我相信我们都曾和这样的人一起工作过。也许我们自己就是这样的人。即使你有最好的意图，并且已经熟读我给大家推荐的优秀书籍，你最终还是会落得跟枪炮士官哈特曼一样的下场：被你自己的团队“枪杀”了。

    在文章的最后，Dennis对如何避免被你自己的团队“枪杀”做了一个很有想法的总结：

    **保持谦虚**。总是先假定你是错的。虽然开发者的确是会犯错误的，并且作为一个新人你理所当然应该帮助其他人发现和修正错误，但是在你骄傲地宣布你的发现之前，你应该努力确保你的观察结果是正确的。如果你老是喊着“狼来了”（慌报险情），你的信誉将遭受巨大的损失。

    **提出建设性的批评时要小心。开发者更容易接受非正式的建议和具有巧妙引导性的问题，而不是把同样的内容以电子邮件的方式发送给整个开发组**。扩大受众面很可能会引起开发者的防御和逆反。团队总是会去猜测你的动机。如果你贬低他们的工作是为了提升你自己，你会因此被投诉而流放的。

    **要想赢得信誉和尊敬，最好的方法就是努力工作并且取得实实在在的成绩**。廉价而肤浅的替代品——例如群发关于最佳实践的邮件，或者转发别人鼓吹某种“银弹”的评论——它们不会产生同样的效果，到头来你可能也只是枉费心机。

    百说不如一干。创建一个团队博客（blog），或者一个维基（wiki），或者实施一种新的代码控制机制，或者实现一种新技术——这些事情说起来都很容易。**所有人都知道，你只是在声明这些主意是你想出来的，而实现它们所需付出的艰苦努力却最终会落在别人的头上——他们会因此而讨厌你**。如果你想建议些什么，你应该为此付出实际的行动、做好充分的准备。例如，展示团队博客的基本要素，包括初级的使用指南，以及所有的支撑技术。这并不能保证团队对你的倡议会一呼百应，而且你还可能徒劳无功，但团队会意识到：你是付出努力的，你在积极地推动它，而不是在试图捡便宜。

    没有一个通用的建议可以适用于所有的情况。不是所有的应用都是大型的电子商务网站。仅仅因为那是最普遍认同的最佳实践，并不意味着它对你所加入的团队来说也是最好的设计原则。也许差得很远！

  - 程序员与系统管理员的黑夜传说

  - 结对编程与代码评审

    我曾经讨论过“代码评审”（CodeReview）的功效。那是我亲身经历过的，因此我可以毫无保留地担保代码评审的价值。我忍不住想知道，是否结对编程就是打过兴奋剂的代码评审。它们之间不是一个替代另一个的关系——你当然可以两个都做——但是，我怀疑结对编程的很多好处都可以通过可靠的同级评审（PeerReview）来获得。

    不过，代码评审也不是万能灵药，就像MartyFried指出的那样：

    我对于代码复查的经验好坏参半。其中的一个问题是，似乎没有人愿意花时间去真正理解那些并不简单的新代码，所以反馈通常是非常笼统的。**但是后来，当有人要在原有代码基础上添加功能或者修改错误的时候，他们通常会有很多的反馈（有时候他们还会怒气冲冲地想要推倒重来），但那时候可能已经太晚了，而且效果也不会理想；之前写那块代码的程序员可能也已经不在了**。我觉得，代码评审或许多多少少有些好处，但要让一个程序员告诉他的老板他的程序员同伴工作很差劲就有点勉为其难了。

    结对编程的优势就在于它的即时性：当复查者就坐在你边上的时候，忽略他是不可能的。大多数人在可以选择的情况下都会选择息事宁人。然而在结对编程中，这是不可能的。在代码被写下来的那一时刻，配对的每个人都必须立即理解代码。结对或许有点唐突，但是它能强制一定程度的交流，这是你用其他方法可能永远也做不到的。

    另一方面，相比于把程序员的身体堆在同一个地方（这是结对编程的要求），同级评审更有灵活性（其规模可大可小）。让我们来看一看Macadamian在WINE项目中做代码评审的经历吧：

    **在WINE项目中，我们采用了两个以前我们不曾用过的流程：公开的同级评审——在这个流程中，新的代码和补丁会通过一个邮件列表发送给所有参与这个项目的人；以及单一提交者——在这个流程中，项目主管对哪个补丁能被接受进入源码树有最终的决定权。**

    我们很快发现，Alexandre Julliard对于代码能否进入源码树特别地挑剔——他自1994年开始就已经是WINE的维护者以及核心开发者之一了。我们团队的补丁都要经过他的仔细审查。当其中有些被驳回的时候，团队里就会有很多的抱怨：“我的代码能正常工作。这个家伙以为他是谁啊？最后期限就要到了，我们没时间了!”但是，随着项目的进展，我们意识到我们在开发有史以来最好的代码。我们写出了整洁、设计良好的代码，并且能在第一遍就通过审核进入源码树很快就成为了一种骄傲。我们同时还发现，尽管这个项目十分庞大，并且开发者散布在世界各地，我们仍然非常清楚地知道整个项目的进展状况，因为我们在邮件列表上看到了每一个补丁。我们现在在每个项目上都采用代码评审；在更大型的项目上，我们还会创建一个内部邮件列表，并且指定一位单一提交者。或许在你的公司里建立起代码评审的流程会很痛苦，而且团队里可能还会有些抱怨，但是在代码的质量以及可维护性方面你将会看到巨大的进步。

    我认为这两种方法很明显都是“纯好事”，尽管它们都有各自的优点和不足。其中的一个就一定比另一个更有效吗？我们应该两个都做吗？

    归根结底，我不认为这是一个二选一的问题，只要保证你有超过一双的眼睛在看你所写的代码，不管你选择用哪种方法都是可以的。当你的代码有其他人帮你复查的时候——不管那个人就坐在你边上，还是远在几千英里以外——你就会开发出更好的软件。这个我可以保证！。
  - 会议是浪费工作时间的最佳去处

    今天你开了多少个会？这个星期呢？这个月呢？

    现在你再自问一下，那些会议中有多少是值得参加的？如果把相同的时间用在工作上，你又能完成多少事情？

    这不禁让人想知道，我们究竟为什么要开会。

    在GitHub，我们不开会。我们没有固定的工作时间，甚至都没有规定工作日。我们不记录休假或者病假的天数。我们没有经理，也没有组织结构图。我们没有着装规范。我们没有开支账户审计，也没有人力资源部门。

    现在，我很肯定Tom（GitHub的联合创始人）在说“GitHub不开会”的时候是在开玩笑的，因为我最近去他们公司做演讲的时候，在他们的办公室里亲眼看到了会议室。谁知道呢，也许他们用那些会议室来存放多余的“叉子”。

    尽管有些会议是不可避免的，甚至是必需的，Tom在这里倡导的原则却很重要。**我们应该以怀疑的态度去看待会议，把它当成是一种降低工作效率的风险。我们举行会议是因为我们认为我们需要它们，但事实上，会议往往只是在浪费宝贵的工作时间**。就我而言，我采用以下的几个原则，以确保我的会议是真正有用的：

    1. **会议绝不应该超过一个小时，否则应判以死刑**

          对于任何会议，第一个并且最重要的约束就是时间。可想而知，它在任何公司都是最宝贵的资源。**如果你不能把会议限制在大约一个小时之内，那一定是有什么事情错得离谱了。你应该首先修正这个错误。可能是会议牵涉了太多的人，也可能是会议讨论的范围太宽泛了，或者就是整体上缺少一个能使会议不偏离的必要的焦点** 。我不相信有人可以记住在长达几个小时的会议里发生的任何事情。当其他的一切都无法做到时，请至少把会议开得简短！

    2. **每个会议都应该有一个清晰的目标声明**

          你开会要达到什么目标？你能用简洁的一句话来说明你召集会议的目的吗？我不想推荐你使用“议事日程”和“日程事项”，因为“议事日程”这个词暗示着一个巨大而乏味的分项列表——包含太多事情了！只要确保每个人都很清楚会议的目的，剩下的事自然会水到渠成。

    3. **在开会之前预先做好功课**

          **既然你的会议有了一个清晰的目标声明，那么每个与会者都应该提前知道了他们将要讨论和分享的内容，并且在走进会议室之前都已经做好了准备。是这样吗？只有这样，我们才能把会议控制在一个小时之内。如果你没有预先做好功课，你就不应该参加这个会议。如果没有任何人做功课，那么这个会议应该被取消**。

    4. **把会议变成可选的**

          “强制”的会议是站不住脚的。每一个出现在会议上的人都应该是因为他们想要在那里，或者他们需要在那里。**一种让你自己对会议负责的可靠方法，就是让每个人自行决定是否要参加你的会议**。想象一下举行一次大家都真正想要参加的会议，那一定是因为它……真的很有用，或者很有趣，或者很娱乐。现在就让它发生吧！

    5. **在会议结束时概括一下待办事项**

          假设你的会议从未召开过，会有什么后果呢？如果你诚实地回答说“几乎没什么后果”，那么也许你的会议根本就没必要开。任何一个真正有成效的会议都会做一些决定，然后就直接导致某些事情的发生。**作为一个负责任的与会者，你应该把你需要做的事情都记录下来——而且为了表明大家的责任心，会议室里的每个人最好在离开会议室之前都概括一下他们的待办事项——这样做对每个人都是有益的**！

          我并不是说我们不应该开会，关键在于，我们必须认识到会议固有的风险，并且努力使我们必须要开的为数不多的会议开得更有效率。（但愿我们不用开太多的会！）让我们快速干活，少说废话，抓住工作的重点。

  - 处理坏苹果

    Robert认为这是一个关于技术依赖的警示性故事，但我看到了另外的一些东西：一个有问题的团队成员，也就是一个典型的"坏苹果"。

    我相信Joe曾经有过最好的意图，但是当你积极地对项目宣战并以你的团队成员为敌时，你就成了项目的一个负担。

    问题员工对于项目的损耗是很严重的，就像Steve McConnell在《快速软件开发》一书第12章指出的那样：

    **如果你容忍所有其他开发者眼里的"问题员工"（哪怕这样的员工只有一个），你就会损害优秀开发人员的士气。你在暗示着，你不仅期望你的团队成员贡献他们的全部，你还指望他们在有同事作对时也能这样做。**

    在一次32个管理团队的联合评审中，Larson和LaFasto发现团队成员最一致而强烈的抱怨是，他们的团队主管不愿意直面并解决与个别团队成员表现差劲有关的问题。（Larson和LaFasto在1989年提出了这个发现。）他们在报告中指出，"如果团队主管不愿意直接并有效地处理自私的团队成员或者不作为的团队成员，这种主管给团队带来的扰乱比其他任何单一方面的团队领导力问题都要严重"。他们接着说，"这是一个重大的管理盲区，因为管理者所认为的团队运转状况几乎总是比团队成员实际认为的要更加乐观"。

    我们应该如何识别问题员工呢？这并不像你想象的那么困难。我有一个朋友曾经把他团队中的某个人比喻成"癌症"（他原话中用的就是这个词）。当你或者团队中的任何其他人使用像"癌症"这样一个词来比喻某个团队成员时，你的项目就已经有严重的病变了。你不必和团队中的每个人都成为朋友，当然那有一定的帮助，但对个人和职业一定程度的基本尊重才是任何团队正常运转所必需的。

    Steve McConnell列举了一些警报信号，用以识别你的团队中是否有"坏苹果"：

    1. 他们掩饰自己的无知，而不是尽力去向他们的团队伙伴学习。他们会说："我不知道该怎么解释我的设计。我只知道它能正常工作。"或者"我的代码太复杂了，没办法测试。"（这些可都是他们的原话。）

    2. 他们对个人隐私有着过度的渴望。他们会说："我不需要任何人来查看我的代码。"

    3. 他们很在意自己的地盘。他们会说："我代码里的问题没人能修复。但我现在太忙了，没时间去管它们。我打算下周处理它们。"

    4. 他们抱怨团队所做的决定，并且在团队已经继续前进了很久之后还会重拾旧题。他们会说："我还是认为，我们应该回过头去修改我们上个月讨论的那个设计。我们当初选择的那个是行不通的。"

    5. 所有其他的团队成员都在传说关于同一个人的俏皮话或者抱怨他。软件开发人员通常不会直接抱怨，因此当你听到很多俏皮话的时候，你必须去查探是否有什么状况发生。

    6. 他们不会积极投入团队的行动。在我经历的一个项目中，就在我们第一个重要的截止日期的前两天，有个开发人员突然要求请一天假。原因是什么呢？他想那天去参加邻城的一个男装展销会-那清晰地表明他并没有融入整个团队。

    让我把我的观点说得清清楚楚、明明白白：如果你的团队主管或者经理没有处理项目中的"坏苹果"，那他就是玩忽职守。

    **你绝不应该害怕去调动（甚至解雇）那些从内心不为团队利益考虑的人。你可以培养一个人的技能，但是你不能让他们有积极的态度。这些具有破坏性的人格在一个项目里逗留得越久，它们的影响就会越大。它们会以代码、关系和交流的形式，慢慢地把毒害传播到项目的每一个角落。**

    **把某个人从团队中调走是很痛苦的。这件事对任何人来说都没有趣。但是，当你意识到你本应该在六个月前就把某人调走时，此时你已经更加痛苦了。**

  - 坏苹果是团队的毒药

- 蝙蝠的：程序员的高效工作场所

  - 程序员的《权利法案》

    程序员应有的权利你都要去争取！而且记住：**你可以让公司做出改变，要不然你就换一家公司**。”

    一个公司愿意付给一个开发人员6万~10万美元的薪水，却用糟糕的工作条件以及破烂的硬件设施摧残他，这对我来说是难以置信的。不管怎么说，这买卖一点都不划算。然而，我却总能看到这样的事情。这让人很震惊，竟然有这么多公司依然没有为软件开发者的成功提供必要的基础条件。

    我提议，我们应该制定一个针对程序员的《权利法案》，以防止公司拒绝给程序员提供取得成功所必需的基础条件，最终达到保护程序员权利的目的。

    1. 每个程序员都应该有两个显示器

        **在LCD价格跳水以及双输出的显卡如此普及的情况下，如果你还把你的开发者限制在一个屏幕上，那你一定是疯了。通过把电脑桌面双倍扩大可以获得生产力的提升，这已经被充分论证过了。如果你想把开发者的生产力发挥到极致，请确保每个开发者都有两个显示器。**

    2. 每个程序员都应该有一台快速的电脑

        程序员必须运行很多软件才能完成他们的工作：开发环境、数据库引擎、网络服务器、虚拟机，如此等等。运行所有这些软件需要一台快速的电脑，再配上很多内存。**程序员的电脑越快，他们每次编译、调试的周期就越短**。我不是让你当“发烧友”，花天价去购买最新、最顶级的配置——但是，你也得向高配置看齐吧。给你的开发者配备快速的、带有很多内存的电脑吧。眼巴巴地盯着进度条等待绝对是一种浪费！

    3. 每个程序员都应该自己选择鼠标和键盘

        在大学的时候，我经营过一个代客油漆的业务。我雇用的每一位油漆工都需要他们自己购买刷子。这是我早期积累的经验之一。将一把标准的刷子扔给一位新的油漆工是行不通的。这些“公司标配的”刷子不被爱惜，很快就会沦落到破损不堪的状况。但是，那些自己买刷子的油漆工很珍惜他们的刷子。他们懂得欣赏花20美元买来的专业刷子与那些从一元店里买来的一次性刷子之间的差别。**拥有自己的刷子让他们产生一种持久的责任感和手艺人的感觉。程序员应该和他们的鼠标以及键盘保持一种相同的关系——它们是我们用来实践我们手艺的最基本的日常工具，我们应该加以善待。**

    4. 每个程序员都应该有一把舒适的椅子

        别小看这个问题！很大程度上来说，我们靠屁股每天坐上8个小时来谋生。为什么不在一把舒适的、设计优良的椅子上度过那8小时呢？要坐8个小时啊，仅仅给程序员提供勉强过得去的椅子是不够的，要让他们坐得愉悦才行！当然，你雇用程序员主要是为了他们聪明的脑袋，但是也别忘了照顾他们的其他重要部位。

    5. 每个程序员都应该能快速接入互联网

        **任何东西只要能“偷”来的，好的程序员从来不会自己去写。互联网是有史以来“偷”东西的最佳去处**。我完全赞成“读万卷书”，但如果没有快速响应的互联网搜索、不能弹指间找到我想要的东西，很难想象我是否还能正常开展工作。

    6. 每个程序员都应该有安静的工作环境

        编程需要全神贯注。程序员在一个嘈杂的环境里是没法高效工作的。请确保你的工作环境能够保护程序员的“心流”状态，否则他们宝贵的时间将在各种干扰之下消耗殆尽。

    我们要求的这几个基本权利是容易办到的。这些要求并不过分，但它们对于软件开发者工作生活的质量起着关键性的作用。如果你所在的公司在这方面做得不好，那就改善一下吧，这既不需要大量的资金投入，做起来也并不难。作为程序员，你要去争取应有的权利！而且记住：**你可以让公司做出改变，要不然你就换一家公司**。

  - 电脑工作站的人体工程学

  - 多显示器能提高生产力吗

    早在使用Windows Me的黑暗年代，我就已经热衷于多显示器了。在最近的4年里，我曾多次写文章来表达给电脑上多个显示器所带来的各种乐趣：

        * "Multiple Monitors and Productivity"（多显示器和生产力）

        * "Multiple LCDs"（多个液晶显示器）

        * "Joining The Prestigious Three Monitor Club"（加入享有盛名的三显示器俱乐部）

        * "The Large Display Paradox"（大显示器的悖论）

        * "LCD Monitor Arms"（液晶显示器支架）

  - 购置优质的电脑椅

    待补充......

  - 背景光的功效

    待补充......

- 设计时要把用户放在心上

  - 你永远不会有足够的奶酪

    我们也许会认为自己的应用程序很吸引人，但它们在用户眼里真的那么有吸引力吗？我表示高度的怀疑。除非你给用户提供免费的mp3音乐，或者给他们看色情图片，否则你不太可能有足够的奶酪让人愿意去克服哪怕是最微弱的电击。你能控制的惟一可变因素只有你的应用程序的可用性。只有让进入的门槛低到荒唐的程度，才能让人们稍微去看一看你的软件——更别提有多少人会去使用它了。

    Joel Spolsky也曾说起过这样的事：

    这里有一个可怕的事实——至少会让用户界面专业人员提心吊胆：**一个应用程序如果可以把人们真正想要的东西做得非常好，那么它即使不是很好用，它仍然会获得成功。反之，一个应用程序即便是世界上最容易使用的，但如果它不能做任何人想要的任何事，那它一定会失败**。因为可用性被普遍认为是“可选的”——这就是那可怕的事，而且在很多情况下，它确实是可选的——于是，用户界面咨询顾问们不得不忙着为自己辩护，他们整出了一个难以令人信服的投资回报率（Return On Investment，简称ROI）公式，用以精确计算客户为可用性项目付出的75000美元投资会获得多少回报。在很多情况下，可用性的确是可选的。CNN网站就不会从可用性咨询中得到任何收获。

    Napster和ICQ在用户界面方面绝对惨不忍睹。但这完全没有关系。他们贡献给世界的东西是那么引人入胜，而且（在那个时期）没有足够的竞争，以致于那些开发者并没有为糟糕的用户界面付出沉重的代价。

    美味的奶酪是一种稀有的奢侈品；大多数致力于标准商业应用的开发者都不应该奢望这种东西。比如一个文件管理系统，用户要疯狂到什么程度才会对它充满期待呢？要让用户真正地使用你的软件，如果你对此还有一丝希望的话，忘掉奶酪吧——确保你不会“电击”你的用户。

  - 细节决定成败

    待补充......

  - 用户界面代表了软件

  - 用户界面须优先设计

  - 分页显示该休矣

  - 对待弱视的用户

  - 在谈浏览器底栏

  - 费茨定律与无限宽度

  - 单元测试的终极失败

  - 第一版做得不好，但照样发布

    我曾经发布过的软件中没有一个能让我满意的。哪怕一个也没有！部分的原因是，像很多其他的软件开发者一样，我是一个完美主义者。于是，有些问题就不可避免了：

        * **开发计划太激进，时间太短了。我们需要更多的时间！**

        * **我们碰到了原先没有预料到的技术问题，它逼着我们做了一个折中的解决方案。**

        * **我们的设计做错了，不得不在开发的过程中做出改变。**

        * **我们的团队出人意料地发生了内部摩擦。**

        * **客户跟我们想象中的不一样。**

        * **设计师、开发者和项目管理团队之间的沟通效率没有我们想象中的那么高。**

        * **我们高估了自己学习新技术的能力。**

        * **这个清单还可以继续往下写。软件项目失败的原因真是数不胜数！**

    在项目启动的时候，你憧憬着你的软件会成为软件工程历史上一座光彩夺目的丰碑。然而在开发周期结束的时候，你最终做出来的却只是那座丰碑的暗淡的影子。

    看到这，你也许想要认输了——往开发计划里增加更多的时间，这样你就能在软件发布之前把它做得更好。毕竟，软件的发布还得靠那些开发人员。

    在这里我要告诉你，这种做法是错误的。

    没错，你在这个项目里把很多很多东西都做砸了。但是，你还把很多很多你尚且不知道的东西做砸了。除非你把软件发布出去、送到用户和客户的面前，否则你无法知道那些做砸的东西到底是什么。我觉得，用DonaldRumsfeld的那首诗来说明这个问题再好不过了：

        我们知道，

        有一些已知的知道。

        有些东西我们知道我们知道。

        我们也知道，

        有一些已知的未知。

        也就是说，

        我们知道有些东西我们不知道。

        但还有些未知的未知，

        就是那些我们不知道我们不知道的东西。

    在项目的收尾阶段面对那些无法避免的忧郁——在枪口之下妥协，还有很多令人不安的权宜之计、欠考虑的解决方案——你可能会蹲下来，默默地舔着你的伤口。你也可能重整队伍，在将软件发布之前另外再花上几个月的时间去修复那些问题。你可能还会自我感觉良好，因为你做了一个艰难的决定：你及时阻止了向全世界发布又一个错误百出的半成品软件，确保了软件工程的质量。

    不幸的是，跟发布带有缺陷的版本比较起来，这是一个更大的错误。

    **与其在与世隔绝的实验室里花上3个月的时间无聊地修复第一版里的问题，你不如把这3个月的时间用于倾听来自真实世界里使用你的软件的用户提出的反馈，尽管他们很烦人，但他们很虔诚、很专注。别把时间花在你想象中的软件上。也别去想象你的用户。他们存在于真实世界里。你可以转过身去，利用来自于真实世界的定向反馈，不仅可以修复第一版里所有做得很差劲的部分，而且可以根据确凿的用户使用数据做出预测，从而能够让你把开发经费花得更有效益。**

    别误会，我不是说你应该发布像狗屎一样的东西。相信我，我们都是完美主义者。但现实是残酷的，它容不下我们的完美主义。理智一些吧，抛开完美主义；要认识到，当你的软件在真实世界里的岩岸上崩溃的时候，让人失望是难免的，但那是可以弥补的！重要的不是软件的初始状态有多么完美——事实上，有人认为，“如果你没有被你的第一版软件搞得局促不安，那说明你还发布得不够早”——重要的是，你在把软件发布之后都做了些什么？

    你的团队对用户反馈的响应速度会为你的软件定下基调，这是任何一次软件发布都不能起到的作用。那才是你真正需要去提高的方面。**不要再沉迷于柏拉图式的理想（发布一款神话中的完美软件），而应该对你的用户和客户做出及时的响应，并且通过基于他们的反馈持续改进和完善你的软件来展示你对他们的诚意。至于说你在为一个接近完美的软件发布而努力，你实际上在为一个错误的目标而浪费精力。**

    **只要有可能的话，请尽早发布你的软件。然后把剩下的时间都用在基于真实世界的反馈进行的快速迭代开发上**。不管你预算的时间有多少，你终将做出更好的软件来。这是毋庸置疑的！

    请你相信我：**即使第一版做得很差劲，坚持把它发布出去**。

- 安全数据：保护用户数据

  - 所有网络通信都应该加密吗

  - 防范字典式攻击

  - 快速哈希

  - 关于网络密码的可怕真相

- 第9章 加强代码测试，别让它太差劲

  - 与客户患难与共

  - 结交“混世魔猴”

  - 代码评审：说做就做

    在“The Soft Side of Peer Reviews”（同级评审的柔软面）一文中，Karl Wiegers以下面这段高调的声明开篇：

    同级评审——软件交付物原作者以外的其他人帮忙检查缺陷、促进提升的一种活动——是最有效的提高软件质量的工具之一。同级评审的方法包括审查、走查、同级桌查、以及其他类似的活动。在从同级评审中受益了将近15年之后，我绝不再愿意在一个不做同级评审的团队里工作。

    在Vertigo公司参与了一段时间的代码评审之后，我坚信，**同级之间的代码评审是你为提高代码质量所能做的最大的贡献**。如果你现在还没有跟另外一个开发人员开展代码评审活动的话，你实际上正在放纵大量的Bug留在你的代码里，也使自己错失了一些关键的职业技能发展的契机。就我个人而言，在我找到一位同事帮我检查完代码之前，我不会认为我已经完成了编码。

    不过，我说的话你可能不信。McConnell在《代码大全》（Code Complete）一书里为代码评审的功效提供了大量的证据，摘录如下：

    ……孤立的软件测试功效有限——在平均缺陷发现率方面，单元测试只能达到25%，功能测试可以达到35%，而集成测试也只能达到45%。相比之下，设计和代码审查的平均功效可以达到55%和60%。评审结果的案例研究非常鼓舞人心：

        * 在一个软件维护的组织里，在引入代码评审之前，55%的单行维护代码改动都是错误的。在引入评审之后，错误率降到了2%。如果考量所有的代码改动，在评审引入之后，95%的代码改动第一次提交的时候就对了；而在评审引入之前，首次代码提交的正确率低于20%。

        * 在一个软件开发的组织里，由同一批人开发11个程序，前5个在开发过程中不做评审，后6个做评审。在所有的程序都正式发布之后，前5个程序平均每100行代码有4.5个错误，而后6个程序平均每100行代码只有0.82个错误。代码评审可以消除80%以上的错误。

        * 安泰保险公司通过代码审查发现了程序里82%的错误，他们因此能够减少20%的开发资源投入。

        * IBM的Orbit项目（500000行代码）使用了11级的审查。软件提前交付了，错误率只有大概1%（这个比率通常是可以接受的）。

        * AT&T内部一个200人的组织报告称，在他们引入代码审查之后，生产率提升了14%，而软件缺陷降低了90%。

        * 美国国家航空航天局下属的喷气推进实验室估计，在早期阶段发现并修复缺陷所节省的成本，按照审查次数折算下来，每次审查可以省下大概25000美元。

    **代码评审的惟一障碍是找到一位你尊敬的开发人员，然后留出专门的时间来做这件事**。一旦你开始这么做了，我相信你会很快发现，你在代码评审中花的每一分钟都会得到十倍的回报！

    如果你所在的公司或组织刚刚开始做代码评审，我强烈推荐Karl的这本书：《软件同级评审》（Peer Reviews inSoftware: A Practical Guide）。Karl在他的网站上提供的样章也不失为一份极好的入门资料。

  - 加大测试力度

  - 我同情那些不写单元测试的傻瓜

    J.Timothy King写了一篇很棒的文章：“先写单元测试的12个好处”（Twelve Benefits of Writing Unit Tests First）。遗憾的是，他在文章最后说的话完全是画蛇添足。

    然而，如果你不愿意改掉先写代码的老习惯，如果你觉得固执己见比设计优秀的软件更重要，好吧，我对你深表同情。

    把你的怜悯用在不认同你的人身上，并不是推广你主张的最有效的方式。

    看看T先生的例子吧。他从1980年代初开始怜悯傻瓜，但迄今为止，“愚蠢”在这个世界仍然是随处可见。

    J.Timothy King有点弄巧成拙了，因为关于单元测试的主张是很重要的。单元测试的普遍接受，已经成为过去5~7年里软件开发领域里最大的进步之一！

    你是怎样解决一个软件问题的？在学校里老师教过你吗？你首先会做什么？你在开始解决问题的时候，会问，“我要写什么代码来解决这个问题呢？”但其实这是后面的问题。你最先要问的问题不是“我要写什么代码”，而是“我怎样才能确认我的方法解决了那个问题？”

    在我们接受的教育里存在一个假设，就是我们已经知道如何去判断我们的解决方案是否奏效。这根本就不是问题。就比如下流行为，我们看到的时候也就知道了。关于代码需要去做什么事，我们相信也没必要在写代码之前去思考一下。这种信仰已经根深蒂固，对于大部分人来说，这是很难改变的！

    J.Timothy King罗列了12个具体的方法，来帮助大家接受“测试先行”的观念（这种方法已经帮助他写出了更为出色的代码）：

    1. **单元测试可以证明你的代码是能真正解决问题的**

    2. 你可以获得一个底层模块的回归测试工具

    3. 你可以在不破坏现有功能的基础上持续改进设计

    4. 一边写单元测试，一边写实现代码，这种工作方式更有乐趣

    5. **它们可以用来真实地展示开发进度**

    6. **单元测试可以用作为演示代码**

    7. **它逼着你在写代码之前做好计划**

    8. 它降低Bug修复的成本

    9. **单元测试甚至比代码审查的效果还要好**

    10. 它实际上为程序员消除了工作上的障碍

    11. 单元测试促成更好的设计

    12. 它比不写单元测试而直接写代码的效率更高

    上面这个列表里，即使你只认同3~4个——根据我的经验，至少一半以上是正确的——对于软件开发者来说也是一个巨大的进步。关于单元测试的重要性，我绝对没有不同意见。恰恰相反，我越来越相信，单元测试是如此之重要，以致于它应该成为第一类的语言构建（像类、方法、事件等一样）。

    然而，我觉得“测试先行”（或者说“测试驱动”）的倡导者太专注在他们自己的立场上，有点急于求成了。要求开发人员一夜之间彻底改变他们开发软件的方式是很过分的。特别是，有些开发人员还从来没有写过单元测试。对于任何软件开发组织来说，如果他们还没有把单元测试采纳为每一个软件项目的标准方法，那我也不认为他们具备了采用“测试驱动”开发方法的条件。

    对“测试驱动”的过度推崇和膜拜，可能使得软件开发人员对单元测试的整个概念都产生怀疑和厌恶。

    要真是那样，就很可惜了！因为关于软件测试，测总比不测好。我们对随机测试（Ad-hoctesting）的概念很熟悉，其实单元测试也就是一种更为正式一点的随机测试，难道不是吗？我觉得Fowler有段话说得非常好：

    **你想把某些信息打印到屏幕或输出给调试器的任何时候，你都应该把它改写成一个单元测试。**

    我希望开发人员能够认识到单元测试的价值。我力劝他们在编写功能代码的时候，也养成编写结构化测试代码的习惯。观念改变一点点，可能最终会促成更大的飞跃，就比如测试驱动开发——但是，在开始跑之前，你必须先学会爬！

  - 单元测试与Beta测试的对比

  - 低保真的可用性测试

    牛人，给你来个突击测验：你怎么知道你的应用程序能够正常工作？当然，也许你的程序通过了编译。也许它通过了所有的单元测试。也许它还成功通过了QA的严酷考验。也许它被成功部署到了一个正式的服务器，或者被打包成了一个安装程序。也许连Beta测试人员都签字认可了。

    然而，所有这些都不能说明你的程序能够正常工作。

    用户真的能理解你的应用程序吗？他们能够使用你的程序去完成他们的工作吗？这才是“能工作的应用程序”的定义。我在第一段罗列的所有东西都算不上什么。**实际上，如果你不找来真正的用户做可用性测试（Usability Testing）的话，你是无法知道你的程序能否正常工作的！**

    你会定期给你的应用程序做可用性测试吗？

    你应该去做！这就是我的观点。Steve Krug有本书叫《Don’t Make Me Think》，其中有个中心思想就是：可用性测试对于任何软件项目来说都是必需的。Krug有个简单易行的方法来做可用性测试，他称之为“跳楼大减价”的可用性测试。

    可用性测试已经存在很长一段时间了。它的基本理念很简单：如果你想知道你的软件、网站或VCR的遥控器是否容易使用，那么在一些人尝试使用它的时候观察他们，记下他们在哪里碰到了问题，然后修正这些问题，之后再度测试。

    不过，在最开始的时候，可用性测试的花费非常昂贵。你需要建立一个可用性实验室，它带有一间位于单向玻璃后面的观察室；至少要有两部摄像机，分别录制用户的反应和他们正在使用的东西。此外，你还得招募大量的测试用户，以得到具有统计意义的结果。这是科学研究。每次测试需要花费2~5万美元。因此这种活动不会经常发生。

    但是在1989年，Jakob Nielsen写了一篇题为“Usability Engineering at a Discount”（打折的可用性工程）的论文。他指出，可用性测试不是非得那样做不可。你可以不需要可用性实验室，而且就算测试用户减少很多，也能得到同样的结果。这个想法是一个巨大的进步！惟一的问题是，10年以后的人们仍然觉得可用性测试不便宜，聘请一个人主持一次测试仍然得花上5000〜15000美元。结果呢？虽说可用性测试比以前发生得多了，但还是不够频繁。

    在这一章里，我要介绍的方法将会更加激进，这就是我们所说的“跳楼大减价”可用性测试。我将教你在你没有时间且预算不足的情况下，如何自己进行测试。当然，如果你有能力去请专家进行测试的话，那就去请吧。但如果这样破费会减少你的测试次数，那你还是别请了。

    Krug指出，除非你对可用性测试有抵触情绪，否则它不难！即使只请一个人来做可用性测试，你多多少少总能得到一些有用的结果，比如下面的情况：

    可用性测试总是会有效果的，哪怕对不合适的用户做一次最糟糕的测试，也会让你看到网站的一些需要改进的地方。我喜欢在每次研习班上做一次现场用户测试；通过这种方式，人们会认识到测试其实很容易做，而且经常能产生许多有价值的看法。我会在班上找一位志愿者，请他在某个其他同学的网站上执行一项任务。这样的测试不会超过10分钟，但被测试网站的主人通常会迅速记上好几页的笔记。他们还会询问是否可以对测试过程录像，以便他们带回去给开发团队看。（曾经有人告诉我，他的团队看过录像后对网站进行了一项改进，后来他们算了一下，这项改进帮他们节省了10万美元！）

    如果你想看到更多的证据，来证明不需要很多用户也能进行有效的可用性测试，那就来看看Jakob Neilsen提供的这张图吧：

    显而易见，完全不做可用性测试是一场灾难。但还有一点不是那么显而易见的是，只有少许几个人进行的可用性测试也能相当有效。而且，如果你遵循Krug给出的指导原则，你的低保真（Low-Fi）可用性测试会进行得更加顺利：

        * 我该在什么时候测试？理想情况下，一个月一次。在整个开发过程中，你应该持续不断地做小型的可用性测试。这些测试应该很简单，持续时间较短，以便于你随时都可以开展，而不用提前花时间去做计划。

        * **我需要找多少用户？3个，或者顶多4个。**

        * **要找什么样的用户**？随机抓一些人。只要会用电脑就行。一个不为人知的秘密是，可用性测试找谁测其实无关紧要。**尽管找到具有代表性的用户会更好，但早点测、经常测要重要得多**。别不好意思，不要放过你的朋友和邻居。

        * **测试要持续多长时间？每个用户花45分钟到1个小时。尽量保持简单。让测试的范围小一点**。不管怎么说，哪怕做最简单的可用性测试，它还是会占用额外的时间。但从长远来说，它还是为你节省时间的。可用性测试的结果可以让你幸免于无休止的争论，或者避免在项目的收尾阶段大量返工。

        * 在哪里测试？任何办公室或者会议室。你所需要的只是一个房间、一张桌子、一台电脑和两把椅子，并且不受别人的干扰。

        * **测试人员应该具备什么特质？任何有点耐心的人都可以。这个人要有耐心，还要冷静、感性并且善于倾听。只要稍微训练一下，大部分人都能胜任做一个测试人员。**

        * **我需要什么设备？你只需要一个屏幕录制软件（比如Camtasia）。如果想要录制的效果更好一点，你可以用一个便携式摄像机把人和屏幕都录下来。**

        * **我要为测试做什么准备？想好你想要展示的东西。草拟一些步骤和说明，以引导参与者如何开始测试。**

        * 测试需要花多少钱？如果不算主持人的时间，给每个用户50~100美元津贴。

        * **我们应该怎样解读测试的结果？在当天的午饭时间，向开发团队和任何感兴趣的干系人汇报。可用性测试最大的好处之一，就是测试结果在所有人面前都是一目了然的。任何严重的问题都难以被遗漏！**

    如果你还没买《Don’t Make Me Think》这本书，那你就太落伍了！赶紧去买吧！在等待送货期间，我强烈建议你下载该书的第9章先看看（下载地址为<http://sensible.com/Downloads/DMMTchapter09_for_personal_use_only.pdf>）。我前面只是初略地介绍了一下，如果你想知道更多的细节，还是去看书吧。

    **可用性测试没必要做得很复杂。如果你真的想知道你正在做的东西是否对路，邀请一些人来使用它吧，并且你待在旁边仔细观察。没别的，也就是从会计部把Joe抓过来，从市场部把Sue抓过来；只要不是直接参与这个项目的，附近的人随便抓，然后请他们使用你做的东西。不要告诉他们做什么。给他们指定一个任务，然后提醒他们，在他们动手做的同时把心里的想法都说出来。而你只需要静静地坐在后面，仔细观察**。根据我个人的经验，我可以告诉你，结果往往是令人惊讶的。

    可用性测试的好处是毋庸置疑的。你尽管去做吧，这样才能真正体会到那些好处！

  - 比程序崩溃更糟糕的时什么

- 第10章 创建并管理社区，同时从中受益

  - 倾听社区的声音，但别被他们牵着鼻子走

    大家都知道，面试官是多么热衷于问这样的问题，“你最大的弱点是什么？”“你曾经犯过最大的错误是什么？”这些问题听起来可能都是公式化的，甚至都是些陈词滥调，但是你在回答的时候可要小心了：它们貌似无足轻重，其实不然！

    如果有人问我，“在创办Stack Overflow网站的过程中你犯过最大的错误什么”，我会很坦然，因为我不用费尽心思地去寻找答案。我可以很诚实地告诉大家，我在开发Stack Overflow的第一天就犯了个天大的、非常荒唐的错误，而且我还固执地坚持了整整9个月，完全不顾社区里此起彼伏的抗议。我越陷越深，甚至还写了一篇长长的博客去驳斥。

    长久以来，我一直有一种很可怕的“搏击俱乐部”式的观念：“Stack Overflow网站的第一条规则，就是你别对Stack Overflow说三道四！”毕竟，大家上这个网站来是为了找到志同道合的人一起学习编程，而不是讨论一个做得很傻的网站。是这样吗？

    我没有意识到大家对“元”（meta）的需要。

    所谓“元”，就是一个大家讨论自身所处之地的地方。听起来很费解吧，但是其含义值得我们好好想想。“元”是给那些深切关注社区、也愿意更进一步做出贡献、组织起来并费尽心思去研究怎样维持和管理社区的人的。所以，我很懊悔！我当初的所作所为，实际上是在告诉那些热爱Stack Overflow的人们：“滚一边去！”

    回想起来，我真是羞愧难当！

    在社区的不断刺激之下，也在我反复的防守还击过程中，很庆幸，我最终醒悟了。尽管我们在一开始的测试阶段用了一个第三方的“元”站点，但在公测后的10个月，也就是2009年6月最终发布的时候，我们还是用了自己的域名：meta.stackoverflow。同样的错误绝不再犯第二次，在我们后来做Stack Exchange的时候就注意了——我们为每一个上线的Stack Exchange子网站从一开始就配备了一个“元”。我们现在知道了，“元”的参与是社区有序领导和治理的源泉，我们须培养它，也因此要加以密切的监控。

    为了“赎罪”，我也成为了我们自己“元”的顶级用户。在过去的2年又7个月的时间里，我将自己埋身在成堆的bug、功能需求和各种讨论中，而支持所有这些的就是我们的“元”。从我的用户账号概况里可以看出，在那段时间里，我有901天都泡在“元”里，其实差不多也就是每天都在了！我以自己对“元”的参与度而感到骄傲，好比是得了一块勋章，而更重要的是，我认识到了我们应该围绕着用户开展工作。我们在Stack Exchange上所做的任何一件事都是特意公开的——这跟象牙塔式的开发模式完全是对立的。

    这一路走过来，在开发社区软件和处理社区反馈方面，我学到了不少的经验和教训。现总结如下：

    1. **90%的社区反馈都是垃圾**

        让我们现在就承认吧！在这方面，“史特金定律”是不可能被任何人否定的，无论你是男人、女人、孩子，还是一个社区。“元”社区，我爱死你了；正因为如此，让我们彼此坦诚相待吧：**你们提出的大部分反馈和功能需求，其实没有任何可操作性**……需要的话，我可以说出一万条理由。

        且慢，别忽略了要点：这也意味着，有另外10%的社区反馈是非常棒的！假如你有毅力看上上百条帖子，我保证你会发现其中有10条的含金量很高，而就是它们能让你的网站得到明显的提升。做好准备吧，若想从一大堆社区反馈里挖掘出“宝石”，你需要花很多时间，而且这时间还不是一般的多！我坚信，每个社区总会有一些足够聪明的人来制造一定数量的“宝石”，他们常常让你喜出望外。

    2. **别抵挡不住诱惑而误入歧途**

        当你收到反馈和功能需求的时候，你应该立即把它们分成两大类：

        我们需要给这辆轿车安上电动窗！

        或者

        我们需要给这辆轿车加个货车车厢！

        显而易见，前者只是给轿车增加一个合理的配件，而后者试图改变车辆的基本特性。**软件本身固有的“易于修改的特性”，使得增加功能变得很诱人，但这有时候无异于给轿车加上一个货车车厢**。为什么不这么做呢？用户们会不断地反问你。货车多方便呀！真的是这样吗？

        别掉进陷阱！牢记你当初的使命。轿车加货车的混合体对于很多人来说都很有吸引力，但是这很可怕，你会最终做出一辆像斯巴鲁Brat一样的车。除非你真的想要做出一辆货车来，否则，如果用户提出想要货车这样的功能，你最好大方地把他们带到附近的货车经销商那里，因为他们似乎来错了地方。

    3. **坦诚地说出你不想做的事**

        当看到bug跟踪系统里或反馈论坛里有成千上万条记录无人问津时，我总是很沮丧。这是社区疏于治理的信号，更为糟糕的是，它折射出了社区里一种信赖缺失的关系。这很常见，也很可悲。千万别搞成这样！

        尽管很多时候来自社区的反馈是令人讨厌的，但我并不建议你把对他们的厌恶之情赤裸裸地表现出来。那样只会显得你很卑劣。但当你觉得他们提出的请求没有道理，或者你无法在一个合理的范畴内将它们实现的时候，请你不要羞于“礼貌地”拒绝他们。（当然，你应该总是保留将来改变主意的权力。）毫无疑问，被人拒绝是很伤心的，但被人忽略让人尤其心灰意冷。我非常非常坚定地相信，只要你对你的社区待之以诚，他们最终会因此而更加敬重你。

        所有的关系都是基于诚实的。如果你不愿意诚实地对待你的社区，你凭什么要求他们来尊敬你呢？他们最终会离你而去……

    4. **倾听社区的声音，但别被他们牵着鼻子走**

        把“元”社区里的需求一股脑儿地吸收进你的软件或者网站中加以实现，这么做看起来很不错。“元”的出发点是倾听来自社区的声音，然后根据社区反馈采取相应的行动，对吗？遗憾的是，如果你过于直接地对社区反馈采取行动，那是非常危险的，它也是很多社区失败的原因。让我们一起来看看GitHub的联合创始人Tom Preston-Werner是怎么解释的吧：

        我们来看一个这样的需求：“GitHub应该允许我用FTP的方式把我项目里的一个文档站点上传上去。”其实，这个客户真正想说的是：**“我想要一个简单的方法来发布与我项目相关的内容。”只是他们早已经习惯了现有的东西，所以他们必然以他们熟悉的术语来表达他们的需求。我们本可以按照他们要求的那样，实现一个糟糕的基于FTP的解决方案。然而，经过我们深入研究之后，我们发现了问题的根本，最终的解决方案是：允许用户通过往账号里加一个Git仓库来实现内容发布。这种做法既满足了功能需求，又不失优雅，堪称完美。**

        社区反馈是美妙的，但它的作用绝不应该被夸大并滥用，它不能代替你去深刻反思你要做的东西以及你为什么要这样做。**花点功夫去挖掘潜在的真正需求吧，然后制定出一个合理的产品路线图。**

    5. 参与并支持你的社区

        大概有一半的社区关系都不尽如人意，他们并不在恪守承诺地做着社区认为他们应该做的事情。即便这样，建议你还是要去积极参与社区，去倾听，去回应。当Stack Exchange的联合创始人回复你在“元”里的发帖时，即使他的回复不能完全达到你的期望，我希望你也能理解，他的行动足以证明了我们对社区的承诺，那就是我们始终跟社区在一起并肩作战。

        不管你现在缺不缺钱用，你都应该热衷到“元”里的社区反馈或bug报告里挖掘出稀有的“宝石”。这些“宝石”能让你的网站或产品更加出色。你应该义无反顾地这么去做，以促成公众反馈的良性循环：“你所关心的就是我们所关注的，所有事情都在朝着一个好的方向持续得到改进。”

        这就是社区的真谛！难道不是吗？

  - 我重申：别盲目听从你的用户

    关于倾听用户，Paul Buchheit是这么说的：

    我用了一天的时间就做出了第一版的Gmail。它一开始并不起眼。我所做的，也不过是把我所有的邮件放进Google组（Usenet）的索引引擎里。我把它发给几个人看了，他们评价说这还是挺有用的，但如果除了我的邮件之外也能搜他们的邮件，那就更好了。于是我开发了第二版。在将第二版发布之后，人们开始想要回复邮件的功能。于是我开发了第三版……在Gmail正式面世之前，这个过程实际上在Google内部持续了好几年！

    一般创业公司不太会有成千上万那么多的内部用户。因此，把产品尽早公开发布出去是很重要的。当FriendFeed在10月份准发布（内部测试）的时候，这个产品其实才开发了大概两个月（而且99.9%的代码是由Bret和Jim两个人写的）。从那以后，我们做了大量的改进。试想如果我们当初没有提前发布，可以肯定的是，我们最终做出来的产品绝对不会像现在这么好。什么原因呢？因为我们找到了用户，而且我们倾听来自他们的反馈，我们很清楚地知道我们的产品哪方面做得好以及哪方面做得不好。

    倾听用户是一件很微妙的事情。**用户常常不知道他们想要什么，即使知道，他们也未必能够说得清楚**。沟通永远是个问题。但不管怎么样，你都不能忽视用户。大部分人在发现你的软件或网站满足不了他们的需要时，都只是静静地走开，而且永远不会回头。因此，那些热心给出反馈的用户值得你去注意和尊敬。他们很积极，以帮助你设计产品为己任。如果你不认真倾听，并且有礼貌地回应所有的用户反馈，那你注定会失败。

    拒绝倾听用户是很不明智的。然而，我们给“可用性”设定的第一条规则是“不要听从用户”，这不是自相矛盾吗？

    如果想知道哪个设计方案更好，只须用户在操作界面上尝试去完成他们的任务时，你在一旁仔细观察。这个方法是如此之简单，以致于很多人都熟视无睹。他们不敢相信，认为可用性测试一定还有其他更为高深的东西。然而，这里面究竟有哪些基本原则呢？我把它们归结如下：

        * 观察人们的实际做法；

        * 不要相信人们说的他们做了什么；

        * 绝对不要相信人们预想的他们将来可能会做什么。

    我是认同Paul的，但他的话容易让人误解。Paul曾在一篇文章里说过相关的这么一段话，“我们心里很清楚什么东西在正常工作”，它实际上暗示了“衡量”和“关联”两个要素。如果你的产品能够产生详细的日志来记录用户的实际操作，那么就没必要当面去观察他们了（尽管你去当面观察也无妨）。在你收集了用户的反馈之后，要把它们跟记录那些用户实际操作的数据关联起来。

    **不要单纯地实现来自“用户代表”或者“业务分析师”的功能需求。把可用性搞砸最常见的做法，就是只听用户说的，而不去看他们真正做的。需求说明书里定义的常常都是错误的。你必须快速地把需求转变成原型程序，然后将具体的东西展示给用户，以确认那是否就是他们真正想要的。**

    仅凭用户反馈就采取行动是有问题的。哪怕你出于多么美好的意图去猜测。如果你能根据“白纸黑字”一样可靠的数据而采取行动，为啥还要靠猜呢？**把用户反馈和详细的使用数据结合起来，然后再去对你的应用程序或网站采取必要的改进措施，这才是正确的做法。**

  - 游戏化

  - 暂停，禁止，或者打入地狱

- 轻重缓急，了然于心

  - 程序员，你幸福吗？

    科学家们喜欢标新立异，抛出了这样的一个观点：钱是可以买到幸福的。从一定程度上来说，他们是对的！

    近期的研究已经开始区分主观幸福的两个方面：情绪上的幸福感和对生活的看法。前者是指一个人每天经历的情绪的质量，具体包括快乐、压力、悲伤、愤怒以及其他让人开心或不开心的感情的频率和强度。后者是指人们在审视他们的生活时所持的看法。钱到底能不能买到幸福呢？我们对以上两个方面分别做了评估—盖洛普公司做了一个关于“幸福指数”的民意调查，每天都有1000名美国人参与。在分析了超过45万份问卷结果之后，我们得出了这样一个报告：如果以收入的对数作为参考坐标，人们对生活的看法随着收入的提高在稳步提升，而情绪上的幸福感也在提升，只不过当年收入超过7.5万美元的时候幸福感就停滞不前了。

    这里还有一个数字可供大家参考：美国联邦政府当前公布的四口之家的贫困线标准是23050美元。也就是说，一旦你的收入超过了贫困线的3倍多一点之后，你就已经得到了最大的幸福，至少钱本身能给你带来的幸福就那么多。

    上面的结论在很多研究资料里都得到了印证。一旦你拥有了“足够的”金钱去满足“马斯洛需求层次理论”金字塔最底部的基本需求之后—也就是说，你不再需要为食物、住所、安全而担心，甚至还有一点可支配的收入用于应急—即使你赚更多的钱，甚至堆金如山，也无助于你到达金字塔的顶端。

    然而，即使你幸运地拥有一份可观的收入，你花钱的方式也会对你所花的钱能带来的幸福（或者不幸）产生很大的影响。我可不是危言耸听哦！这是有科学依据的。相关的研究在“If money doesn’t make you happy, then you probablyaren’t spending it right”（如果金钱没能给你带来幸福，那可能是你花钱的方式不对）一文中做了很好的总结。

    关于幸福，其实大部分人都不知道它的科学本质—什么能带来幸福？什么又能维持幸福？—也因此，他们不知道怎样使用自己的金钱去获取幸福。那么，下面的事就不足为奇了：一个对酒一窍不通的有钱人，并不见得比他的邻居们更会储存酒；一个对幸福一无所知的有钱人，并不见得比其他人生活得更幸福。金钱是获取幸福的一种机会，但仅仅因为人们觉得应该能给他们带来幸福的东西常常并不能让他们如愿以偿，这种机会很多时候都被白白浪费了。

    那么，什么才是幸福的真谛呢？下面，我将尽我所能总结出最基本的8点，但如果你想了解各条原则背后的研究论证过程以及更多的细节，我建议你还是去完整阅读一下那篇论文。（在互联网上可以搜索得到。）

    1. 经历胜过物质

        东西会变旧。东西会变得平淡无奇。东西就是东西，它还会磨损，很难拿来分享。但是经历却完全不同，它是独特的，它在你的记忆里像钻石一样光芒四射，而且常常还会历久弥新。经历永远都可以拿出来与人分享。只要有可能的话，把钱花在经历上（比如带全家去迪士尼乐园玩），而不要花在物质上（比如买一台新电视机）。

    2. 助人为乐

        人类本质上是社会性的动物。任何花点钱就能跟其他人建立起更为深入的联系的东西（或事情），将有助于我们的社会关系更加紧密，有助于提升我们自己和他人的正面感受。想一想，你能通过何种方式、只需花费自己一部分的钱就能帮到别人？**勿以善小而不为**。把它们放到你的常规开销计划里去吧！

    3. 让幸福细水长流

        人是最能适应变化的。因此，最有效的花钱方式是经常买来一些小变化，而不是花大钱一下子买来一个大惊喜，然后坐等着新鲜劲很快过去。如果可能的话，把一个大的购买计划拆分成多个小的，一点一点慢慢买进来，更好地享受整个过程。**就拿幸福来说吧，频率比强度更重要**。大家需要改变一下观念，记住：很多次小的、愉快的购买实际上比一次巨额的购买更能有效地给你带来幸福。

    4. 少买保险

        人能快速适应变化，不管这个变化是正面的还是负面的。额外的担保或保险是在利用我们“损失厌恶”的天性，利用我们的一时冲动。因为人们的适应能力很强，当购买的东西出现故障时，其实他们并不会像原先想象的那样懊恼不已。

        而且，因为人们放弃了享受完整承诺带来的情感利益，保险条款容易不生效或者慷慨的返还政策反而会引起更多的焦虑和不快。因此，避免购买保险，千万别贪图慷慨的返还政策。

    5. 为将来埋单

        即刻的喜悦可能会使你冲动买下你承受不起的东西，或者不是你真正想要的东西。冲动购买使你丧失了必要的思考空间，让你难以做出合理的决定。它也无情地扼杀了期待的感觉，而期待恰恰是幸福的源泉。**为了让幸福最大化，你应该尽情享受是否要买、买什么、什么时候到货等问题带来的不确定性，甚至故意把做决定的过程拖长。**

    6. 三思而后行

        **在考虑为将来购置东西的时候，我们常常会忽略一些细节问题。但有研究表明，恰恰是这些被我们忽略的微小细节决定了我们的幸福（或者不幸）。在进行一次重要的采购之前，考虑一下售后服务，同时也想想一旦拥有这样东西之后你到底哪些时间会用在它上面。试着设想将来典型的一天，一小时一小时地细细审视：这东西会如何影响你的生活？**

    7. 小心比较购物的陷阱

        **“比较购物”转移了我们的注意力，使我们过多地关注在这个商品区别于其他商品的一些无足轻重的特性上，而忽略了去评估我们真正有多喜欢这个东西**。他们关注的是我们购物时关心的方面，而不是我们购买之后使用的时候我们所关注的方面。换句话说，花2美元买到一块便宜巧克力（不错的买卖），跟这块巧克力好不好吃其实没什么关系。不要为了比较而比较，谨防掉入比较购物的陷阱。试着去考量那些真正能给你带来快乐或提升体验的指标。

    8. 随大流

        不要高估你的能力，别以为你能独立预测你会有多喜欢某样东西。从科学的角度来讲，我们在这方面极其不擅长！但如果某样东西可靠地给其他很多人带来了幸福，那它很可能也会给你带来幸福。在你做出购买决定之前，请认真考量一下别人的看法和用户评论。

        赚钱不容易。跟钱财相比，幸福更是来之不易！因此，当你花钱的时候，请记住上面的8点，这样才能使你买到的幸福最大化。请记住：这是科学！

  - 来也匆匆，去也匆匆，到头来两手空空

    .......

- abc
