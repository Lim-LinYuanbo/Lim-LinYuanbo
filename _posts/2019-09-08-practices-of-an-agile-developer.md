---
layout: mypost
title: 高效程序员的45个习惯
categories: [博览群书]
---

中文版：

[豆瓣读书](https://book.douban.com/subject/4164024/)

英文版：

[豆瓣读书](https://book.douban.com/subject/1767907/)

---

## 第1章　敏捷——高效软件开发之道

## 第2章　态度决定一切

## 第3章　学无止境

## 第4章　交付用户想要的软件

### 10 让客户做决定

  > “开发者兼具创新和智慧，最了解应用程序。因此，所有关键决定都应该由开发者定夺。每次业务人员介入的时候，都会弄得一团糟，他们无法理解我们做事的逻辑。”

  在设计方面，做决定的时候必须有开发者参与。可是，在一个项目中，他们不应该做所有的决定，特别是业务方面的决定。

  就拿项目经理Pat的例子来说吧。Pat的项目是远程开发，一切按计划且在预算内进行着——就像是个可以写入教科书的明星项目。Pat高高兴兴地把代码带到客户那里，给客户演示，却败兴而归。

  原来，Pat的业务分析师没有和用户讨论，而是自作主张，决定了所有的问题。在整个开发过程中，企业主根本没有参与具体的决策。项目离完成还早着呢，就已经不能满足用户的需要了。这个项目一定会延期，又成为一个经典的失败案例。

  因而，你只有一个选择：**要么现在就让用户做决定，要么现在就开始开发，迟些让用户决定，不过要付出较高的成本。如果你在开发阶段回避这些问题，就增加了风险，但是你要能越早解决这些问题，就越有可能避免繁重的重新设计和编码。甚至在接近项目最终期限的时候，也能避免与日俱增的时间压力**。

  假设你要完成一个任务，有两种实现方式。第一种方式的实现比较快，但是对用户有一点限制。第二种方式实现起来需要更多的时间，但是可以提供更大的灵活性。很显然，你有时间的压力（什么项目没有时间压力呢），那么你就用第一种很快的方式吗？你凭什么做出这样的决定呢？是投硬币吗？询问同事或者项目经理了吗？

  作者之一Venkat最近的一个项目就遇到了类似的问题。项目经理为了节约时间，采取了第一种方式。也许你会猜到，在Beta版测试的时候，软件暴露出的局限让用户震惊，甚至愤怒。结果还得重做，花费了团队更多的金钱、时间和精力。

  开发者（及项目经理）能做的一个最重要的决定就是：**判断哪些是自己决定不了的，应该让企业主做决定。你不需要自己给业务上的关键问题做决定。毕竟，那不是你的事情。如果遇到了一个问题，会影响到系统的行为或者如何使用系统，把这个问题告诉业务负责人。如果项目领导或经理试图全权负责这些问题，要委婉地劝说他们，这些问题最好还是和真正的业务负责人或者客户商议**。

  当你和客户讨论问题的时候，准备好几种可选择的方案。**不是从技术的角度，而是从业务的角度，介绍每种方案的优缺点，以及潜在的成本和利益。和他们讨论每个选择对时间和预算的影响，以及如何权衡**。无论他们做出了什么决定，他们必须接受它，所以最好让他们了解一切之后再做这些决定。如果事后他们又想要其他的东西，可以公正地就成本和时间重新谈判。

  毕竟，这是他们的决定。

  > **让你的客户做决定。开发者、经理或者业务分析师不应该做业务方面的决定。用业务负责人能够理解的语言，向他们详细解释遇到的问题，并让他们做决定。**

### 11 让设计指导而不是操纵开发

  > “设计文档应该尽可能详细，这样，低级的代码工人只要敲入代码就可以了。在高层方面，详细描述对象的关联关系；在低层方面，详细描述对象之间的交互。其中一定要包括方法的实现信息和参数的注释。也不要忘记给出类里面的所有字段。编写代码的时候，无论你发现了什么，绝不能偏离了设计文档。”

  “设计”是软件开发过程不可缺少的步骤。它帮助你理解系统的细节，理解部件和子系统之间的关系，并且指导你的实现。一些成熟的方法论很强调设计，例如，统一过程（Unified Process，UP）十分重视和产品相关的文档。项目管理者和企业主常常为开发细节困扰，他们希望在开始编码之前，先有完整的设计和文档。毕竟，那也是你如何管理桥梁或建筑项目的，难道不是吗？

  另一方面，敏捷方法建议你早在开发初期就开始编码。是否那就意味着没有设计呢？不，绝对不是，好的设计仍然十分重要。画关键工作图（例如，用UML）是必不可少的，因为要使用类及其交互关系来描绘系统是如何组织的。在做设计的时候，你需要花时间去思考（讨论）各种不同选择的缺陷和益处，以及如何做权衡。

  然后，下一步才考虑是否需要开始编码。如果你在前期没有考虑清楚这些问题，就草草地开始编码，很可能会被很多意料之外的问题搞晕。甚至在建筑工程方面也有类似的情况。在锯一根木头的时候，通常的做法就是先锯一块比需要稍微长一点的木块，最后细致地修整，直到它正好符合需求。

  但是，即使之前已经提交了设计文档，也还会有一些意料之外的情况出现。时刻谨记，此阶段提出的设计只是基于你目前对需求的理解而已。一旦开始了编码，一切都会改变。设计及其代码实现会不停地发展和变化。

  一些项目领导和经理认为设计应该尽可能地详细，这样就可以简单地交付给“代码工人们”。他们认为代码工人不需要做任何决定，只要简单地把设计转化成代码就可以了。就我而言，没有一个愿意在这样的团队中做纯粹的打字员。我们猜想你也不愿意。

  如果设计师们把自己的想法绘制成精美的文档，然后把它们扔给程序员去编码，那会发生什么？程序员会在压力下，完全按照设计或者图画的样子编码。如果系统和已有代码的现状表明接收到的设计不够理想，那该怎么办？太糟糕了！时间已经花费在设计上，没有工夫回头重新设计了。团队会死撑下去，用代码实现了明明知道是错误的设计。这听起来是不是很愚蠢？是够愚蠢的，但是有一些公司真的就是这样做的。

  严格的需求—设计—代码—测试开发流程源于理想化的瀑布式 开发方法，它导致在前面进行了过度的设计。这样在项目的生命周期中，更新和维护这些详细的设计文档变成了主要工作，需要时间和资源方面的巨大投资，却只有很少的回报。我们本可以做得更好。

  **设计可以分为两层：战略和战术。前期的设计属于战略，通常只有在没有深入理解需求的时候需要这样的设计。更确切地说，它应该只描述总体战略，不应深入到具体的细节。**

  > 做到精确
  >
  > 如果你自己都不清楚所谈论的东西，就根本不可能精确地描述它。
  >
  > <p align="right">——约翰·冯·诺依曼</p>

  前面刚说过，战略级别的设计不应该具体说明程序方法、参数、字段和对象交互精确顺序的细节。那应该留到战术设计阶段，它应该在项目开发的时候再具体展开。

  **良好的战略设计应该扮演地图的角色，指引你向正确的方向前进。任何设计仅是一个起跑点：它就像你的代码一样，在项目的生命周期中，会不停地进一步发展和提炼。**

  下面的故事会给我们一些启发。在1804年，Lewis与Clark进行了横穿美国的壮举，他们的“设计”就是穿越蛮荒。但是，他们不知道在穿越殖民地时会遇到什么样的问题。他们只知道自己的目标和制约条件，但是不知道旅途的细节。

  软件项目中的设计也与此类似。在没有穿越殖民地的时候，你不可能知道会出现什么情况。所以，不要事先浪费时间规划如何徒步穿越河流，只有当你走到河岸边的时候，才能真正评估和规划如何穿越。只有到那时，你才开始真正的战术设计。

  不要一开始就进行战术设计，它的重点是集中在单个的方法或数据类型上。这时，更适合讨论如何设计类的职责。因为这仍然是一个高层次、面向目标的设计。事实上，CRC（类—职责—协作）卡片的设计方法就是用来做这个事情的。每个类按照下面的术语描述。

  * 类名。
  * 职责：它应该做什么？
  * 协作者：要完成工作它要与其他什么对象一起工作？

  如何知道一个设计是好的设计，或者正合适？代码很自然地为设计的好坏提供了最好的反馈。如果需求有了小的变化，它仍然容易去实现，那么它就是好的设计。而如果小的需求变化就带来一大批基础代码的破坏，那么设计就需要改进。

  **好设计是一张地图，它也会进化。设计指引你向正确的方向前进，它不是殖民地，它不应该标识具体的路线。你不要被设计（或者设计师）操纵。**

  **切身感受**

  **好的设计应该是正确的，而不是精确的。也就是说，它描述的一切必须是正确的，不应该涉及不确定或者可能会发生变化的细节。它是目标，不是具体的处方。**

  **平衡的艺术**

  * **“不要在前期做大量的设计”并不是说不要设计。只是说在没有经过真正的代码验证之前，不要陷入太多的设计任务。当对设计一无所知的时候，投入编码也是一件危险的事。如果深入编码只是为了学习或创造原型，只要你随后能把这些代码扔掉，那也是一个不错的办法。**

  * **即使初始的设计到后面不再管用，你仍需设计：设计行为是无价的。正如美国总统艾森豪威尔所说：“计划是没有价值的，但计划的过程是必不可少的。”在设计过程中学习是有价值的，但设计本身也许没有太大的用处。**

  * **白板、草图、便利贴都是非常好的设计工具。复杂的建模工具只会让你分散精力，而不是启发你的工作。**

### 12 合理地使用技术

  > “你开始了一个新的项目，在你面前有一长串关于新技术和应用框架的列表。这些都是好东西，你真的需要使用列表中所有的技术。想一想，你的简历上将留下漂亮的一笔，用那些伟大的框架，你的新应用将具有极高技术含量。”

  从前，作者之一Venkat的同事Lisa向他解释自己的提议：她打算使用EJB。Venkat表示对EJB有些顾虑，觉得它不适合那个特殊的项目。然后Lisa回答道：“我已经说服了我们经理，这是正确的技术路线，所以现在不要再扔‘炸弹’了。”这是一个典型的“简历驱动设计”的例子，之所以选择这个技术，是因为它很美，也许还能提高程序员的技能。但是，盲目地为项目选择技术框架，就好比是为了节省税款而生孩子，这是没有道理的。

  **在考虑引入新技术或框架之前，先要把你需要解决的问题找出来。你的表述方式不同，会让结果有很大差异。如果你说“我们需要xyzzy技术，是因为……”，那么就不太靠谱。你应该这样说：“……太难了”或者是“……花的时间太长了”，或者类似的句子**。找到了需要解决的问题，接下来就要考虑：

  * **这个技术框架真能解决这个问题吗？是的，也许这是显而易见的。但是，这个技术真能解决你面临的那个问题吗？或者，更尖锐一点说，你是如何评估这个技术的？是通过市场宣传还是道听途说？要确保它能解决你的问题，并没有任何的毒副作用。如果需要，先做一个小的原型。**

  * **你将会被它拴住吗？一些技术是贼船，一旦你使用了它，就会被它套牢，再也不可能回头了。它缺乏可取消性，当条件发生变化时，这可能对项目有致命打击。我们要考虑它是开放技术还是专利技术，如果是开放的技术，那又开放到什么程度？**

  * **维护成本是多少？会不会随着时间的推移，维护成本变得非常昂贵？毕竟，方案的花费不应该高于要解决的问题，否则就是一次失败的投资。我们听说，有个项目的合同是支持一个规则引擎，引擎一年的维护费用是5万美元，但是这个数据库只有30条规则。这也太贵了。**

  当你在考察一个框架（或者任何技术）的时候，也许会被它提供的各种功能吸引。接着，在验证是否使用这个框架的时候，你可能只会考虑已经发现的另外一些功能。但是，你真的需要这些功能吗？也许为了迎合你发现的功能，你正在为它们找问题。这很像站在结账处一时冲动而买些无用的小零碎（那也正是商场把那些小玩意儿放到那里的原因）。

  不久前，Venkat遇到了一个项目。咨询师Brad把一个专有框架卖给了这个项目的管理者。在Venkat看来，这个框架本身也许还有点儿意思，但是它根本不适合这个项目。

  尽管如此，管理者却坚决认为他们要使用它。Venkat非常礼貌地停手不干了。他不想成为绊脚石，阻碍他们的工作进度。一年之后项目还没有完成——他们花了好几个月的时间编写代码来维护这个框架，为了适应这个框架，他们还修改了自己的代码。

  Andy有过相似的经历：他的客户想完全透明地利用开源，他们拥有“新技术大杂烩”，其中的东西太多，以至于无法让所有的部分协同工作。

  如果你发现自己在做一些花哨的东西（比如从头创建自己的框架），那就醒醒吧，闻闻烟味有多大，马上该起火了。你的代码写得越少，需要维护的东西就越少。

  例如，如果你想开发自己的持久层框架，记住Ted Neward的评论：对象—关系的映射就是计算机科学的越南战场3。你可以把更多的时间和精力投入到应用的开发——领域或具体应用中。

  > **根据需要选择技术。首先决定什么是你需要的，接着为这些具体的问题评估使用技术。对任何要使用的技术，多问一些挑剔的问题，并真实地作出回答。**

  **切身感受**

  **新技术就应该像是新的工具，可以帮助你更好地工作，它自己不应该成为你的工作。**

  **平衡的艺术**

  * **也许在项目中真正评估技术方案还为时太早。那就好。如果你在做系统原型并要演示给客户看，也许一个简单的散列表就可以代替数据库了。如果你还没有足够的经验，不要急于决定用什么技术。**

  * **每一门技术都会有优点和缺点，无论它是开源的还是商业产品、框架、工具或者语言，一定要清楚它的利弊。**

  * **不要开发那些你容易下载到的东西。虽然有时需要从最基础开发所有你需要的东西，但那是相当危险和昂贵的。**

### 13  保持可以发布

  > “我们刚试用的时候发现了一个问题，你需要立即修复它。放下你手头的工作，去修复那个刚发现的问题，不需要经过正规的程序。不用告诉其他任何人——赶快让它工作就行了。”

  这听起来似乎没什么问题。有一个关键修复的代码必须要提交到代码库。这只是一件小事，而且又很紧急，所以你就答应了。

  修复工作成功地完成了。你提交了代码，继续回到以前那个高优先级的任务中。忽然一声尖叫。太晚了，你发现同事提交的代码和你的代码发生了冲突，现在你使得每个人都无法使用系统了。这将会花费很多精力（和时间）才能让系统重新回到可发布的状态。现在你有麻烦了。你必须告诉大家，你不能交付你承诺的修复代码了。而魔鬼在嘲笑：“哈哈哈！”

  这时候，你的处境会很糟糕：系统无法发布了。你弄坏了系统，也许会带来更糟糕的后果。

  1836年，当时的墨西哥总统安东尼奧·洛佩斯·德·圣安那将军，率领部队穿越得克萨斯州西部，追赶败退的萨姆·休斯顿将军。当圣安那的部队到达得克萨斯州东南方向的布法罗河岸的沼泽地带的时候，他命令自己的部队就地休息。传说中认为他是太过自信，甚至没有安排哨兵。就在那个傍晚，休斯顿发动了突然袭击，这时圣安那的部队已经来不及编队了。他们溃不成军，输掉了这场决定性的战争，从此永远改变了得克萨斯州的历史4。

  任何时候只要你没有准备好，那就是敌人进攻你的最佳时机。好好想一想，你的项目进入不可发布状态的频率是多少？你的源代码服务器中的代码，是不是像圣安那在那个决定性的黄昏一样——没有进行编队，遇到紧急情况无法立即启动。

  在团队里工作，修改一些东西的时候必须很谨慎。你要时刻警惕，每次改动都会影响系统的状态和整个团队的工作效率。在办公室的厨房里，你不能容忍任何人乱丢垃圾，为什么就可以容忍一些人给项目带来垃圾代码呢？

  下面是一个简单的工作流程，可以防止你提交破坏系统的代码。

  * **在本地运行测试。先保证你完成的代码可以编译，并且能通过所有的单元测试。接着确保系统中的其他测试都可以通过。**

  * **检出最新的代码。从版本控制系统中更新代码到最新的版本，再编译和运行测试。这样往往会发现让你吃惊的事情：其他人提交的新代码和你的代码发生了冲突。**

  * **提交代码。现在是最新的代码了，并且通过了编译和测试，你可以提交它们了。**

  在做上面事情的时候，也许你会遇到这样一个问题——其他人提交了一些代码，但是没有通过编译或者测试。如果发生了这样的事情，要立即让他们知道，如果有需要，可以同时警告其他的同事。当然，最好的办法是，你有一个持续集成系统，可以自动集成并报告集成结果。

  这听起来似乎有点恐怖，其实很简单。持续集成系统就是在后台不停地检出、构建和测试代码的应用。你可以自己使用脚本快速实现这样的方式，但如果你选择已有的免费、开源的解决方案，它们会提供更多的功能且更加稳定。有兴趣的话，可以看一看Martin Fowler的文章5，或者是Mike Clark编著的图书《项目自动化之道》。

  再深入一点，假设你得知即将进行的一次重大修改很可能会破坏系统，不要任其发生，应该认真地警告大家，在代码提交之前，找出可以避免破坏系统的方法。选择可以帮助你平滑地引入和转换这些修改的方法，从而在开发过程中，系统可以得到持续的测试和反馈。

  虽然保持系统可发布非常重要，但不会总是那么容易，例如，修改了数据库的表结构、外部文件的格式，或者消息的格式。这些修改，通常会影响应用的大部分代码，甚至导致应用暂时不可用，直到大量的代码修改完成。尽管如此，你还是有办法减轻这样的痛苦。

  为数据库的表结构、外部文件，甚至引用它的API提供版本支持，这样所有相关变化都可以进行测试。有了版本功能，所做的变化可以与其他代码基相隔离，所以应用的其他方面仍然可以继续开发和测试。

  你也可以在版本控制系统中添加一个分支，专门处理这个问题（使用分支需要十分小心，不好的分支也许会给你带来更多的麻烦。详情可以查阅《版本控制之道——CVS》或《版本控制之道——Subversion》）。

  > 保持你的项目时刻可以发布。保证你的系统随时可以编译、运行、测试并立即部署。

  切身感受

  你会觉得，不管什么时候，你的老板、董事长、质量保障人员、客户或者你的配偶来公司参观项目的时候，你都能很自信并毫不犹豫地给他们演示最新构建的软件。你的项目一直处于可以运行的稳定状态。

  **平衡的艺术**

  * **有时候，做一些大的改动后，你无法花费太多的时间和精力去保证系统一直可以发布。如果总共需要一个月的时间才能保证它一周内可以发布，那就算了。但这只应该是例外，不能养成习惯。**

  * **如果你不得不让系统长期不可以发布，那就做一个（代码和架构的）分支版本，你可以继续进行自己的实验，如果不行，还可以撤销，从头再来。千万不能让系统既不可以发布，又不可以撤销。**

### 14 提早集成，频繁集成

  > “只要没有到开发的末尾阶段，就不要过早地浪费时间去想如何集成你的代码，至少也要等开发差不多的时候，才开始考虑它。毕竟，还没有完成开发，为什么要操心集成的事情呢！在项目的末尾，你有充裕的时间来集成代码。”

  我们说过，敏捷的一个主要特点就是持续开发，而不是三天打鱼两天晒网似地工作。特别是在几个人一起开发同一个功能的时候，更应该频繁地集成代码。

  很多开发者用一些美丽的借口，推迟集成的时间。有时，不过是为了多写一些代码，或者是另一个子系统还有很多的工作要完成。他们很容易就会这样想：“现在手头上的工作压力够大了，到最后我才能做更多的工作，才能考虑其他人代码。”经常会听到这样的借口：“我没有时间进行集成”或者“在我机器上设置集成环境太费事了，我现在不想做它”。

  但是，在产品的开发过程中，集成是一个主要的风险区域。让你的子系统不停地增长，不去做系统集成，就等于一步一步把自己置于越来越大的风险中，世界没有了你仍然会转动，潜在的分歧会继续增加。相反，尽可能早地集成也更容易发现风险，这样风险及相关的代价就会相当低。而等的时间越长，你也就会越痛苦。

  作者之一Venkat小时候生活在印度钦奈市，经常赶火车去学校。像其他的大城市一样，印度的交通非常拥挤。他每次必须在车还没有停稳的时候，就跳上去或者跳下来。但，你不能从站的地方一下子跳上运行的火车，我们在物理课上学习过这种运动定律。而应该是，首先你要沿着火车行驶的方向跑，边跑边抓住火车上的扶手，然后跳入火车中。

  软件集成就像这一样。如果你不断地独立开发，忽然有一天跳到集成这一步，千万不要为受到打击而吃惊。也许你自己在项目中就有这样的体会：每次到项目结束的时候都觉得非常不爽，大家需要日日夜夜地进行集成。

  > **你能集成并且独立**
  >
  > **集成和独立不是互相矛盾的，你可以一边进行集成，一边进行独立开发。**
  >
  > **使用mock对象来隔离对象之间的依赖关系，这样在集成之前就可以先做测试，用一个mock对象模拟真实的对象（或者子系统）。就像是拍电影时在光线的掩饰下使用替身一样，mock对象就是真实对象的替身，它并不提供真实对象的功能，但是它更容易控制，能够模仿需要的行为，使测试更加简单。**
  >
  > **你可以使用mock对象，编写独立的单元测试，而不需要立刻就集成和测试其他系统，只有当你自信它能工作的时候，才可以开始集成。**

  当你在公司昏天黑地地加班时，唯一的好处就是可以享受到免费的披萨。

  独立开发和早期集成之间是具有张力的。当你独立开发时，会发现开发速度更快，生产率更高，你可以更有效地解决出现的问题。但那并不意味着要你避免或延迟集成。你一般需要每天集成几次，最好不要2~3天才集成一次。

  当早期就进行集成的时候，你会看到子系统之间的交互和影响，你就可以估算它们之间通信和共享的信息数据。你越早弄清楚这些问题，越早解决它们，工作量就越小。就好比是，刚开始有3个开发者，开发着5万行的代码，后来是5000个开发者进行3000万行代码的开发。相反，如果你推迟集成的时间，解决这些问题就会变得很难，需要大量和大范围地修改代码，会造成项目延期和一片混乱。

  > **提早集成，频繁集成。代码集成是主要的风险来源。要想规避这个风险，只有提早集成，持续而有规律地进行集成。**

  切身感受

  如果你真正做对了，集成就不再会是一个繁重的任务。它只是编写代码周期中的一部分。集成时产生的问题，都会是小问题并且容易解决。

  平衡的艺术

  * 成功的集成就意味着所有的单元测试不停地通过。正如医学界希波克拉底的誓言：首先，不要造成伤害。

  * 通常，每天要和团队其他的成员一起集成代码好几次，比如平均每天5~10次，甚至更多。但如果你每次修改一行代码就集成一次，那效用肯定会缩水。如果你发现自己的大部分时间都在集成，而不是写代码，那你一定是集成得过于频繁了。

  * 如果你集成得不够频繁（比如，你一天集成一次，一周一次，甚至更糟），也许就会发现整天在解决代码集成带来的问题，而不是在专心写代码。如果你集成的问题很大，那一定是做得不够频繁。

  * 对那些原型和实验代码，也许你想要独立开发，而不要想在集成上浪费时间。但是不能独立开发太长的时间。一旦你有了经验，就要快速地开始集成。

### 15 提早实现自动化部署

  > “没问题，可以手工安装产品，尤其是给质量保证人员安装。而且你不需要经常自己动手，他们都很擅长复制需要的所有文件。”

  系统能在你的机器上运行，或者能在开发者和测试人员的机器上运行，当然很好。但是，它同时也需要能够部署在用户的机器上。如果系统能运行在开发服务器上，那很好，但是它同时也要运行在生产环境中。

  这就意味着，你要能用一种可重复和可靠的方式，在目标机器上部署你的应用。不幸的是，大部分开发者只会在项目的尾期才开始考虑部署问题。结果经常出现部署失败，要么是少了依赖的组件，要么是少了一些图片，要么就是目录结构有误。

  如果开发者改变了应用的目录结构，或者是在不同的应用之间创建和共享图片目录，很可能会导致安装过程失败。当这些变化在人们印象中还很深的时候，你可以快速地找到各种问题。但是几周或者几个月之后查找它们，特别是在给客户演示的时候，可就不是一件闹着玩的事情了。

  如果现在你还是手工帮助质量保证人员安装应用，花一些时间，考虑如何将安装过程自动化。这样，只要用户需要，你就可以随时为他们安装系统。要提早实现它，这样让质量保证团队既可以测试应用，又可以测试安装过程。如果还是手工安装应用，那么最后把应用部署到生产环境时会发生什么呢？就算公司给你加班费，你也不愿意为不同用户的机器或不同地点的服务器上一遍又一遍地安装应用。

  有了自动化部署系统后，在项目开发的整个过程中，会更容易适应互相依赖的变化。很可能你在安装系统的时候，会忘记添加需要的库或组件——在任意一台机器上运行自动化安装程序，你很快就会知道什么丢失了。如果因为缺少了一些组件或者库不兼容而导致安装失败，这些问题会很快浮现出来。

  > Andy如是说……
  >
  > 从第一天起就开始交付
  >
  > 一开始就进行全面部署，而不是等到项目的后期，这会有很多好处。事实上，有些项目在正式开发之前，就设置好了所有的安装环境。
  >
  > 在我们公司，要求大家为预期客户实现一个简单的功能演示——验证一个概念的可行性。即使项目还没有正式开始，我们就有了单元测试、持续集成和基于窗口的安装程序。**这样，我们就可以更容易更简单地给用户交付这个演示系统：用户所要做的工作，就是从我们的网站上点击一个链接，然后就可以自己在各种不同的机器上安装这个演示系统了。**
  >
  > **在签约之前，就能提供出如此强大的演示，这无疑证明了我们非常专业，具有强大的开发能力。**

  > **一开始就实现自动化部署应用。使用部署系统安装你的应用，在不同的机器上用不同的配置文件测试依赖的问题。质量保证人员要像测试应用一样测试部署。**

  切身感受

  这些工作都应该是无形的。系统的安装或者部署应该简单、可靠及可重复。一切都很自然。

  平衡的艺术

  * **一般产品在安装的时候，都需要有相应的软、硬件环境**。比如，Java或Ruby的某个版本、外部数据库或者操作系统。这些环境的不同很可能会导致很多技术支持的电话。所以检查这些依赖关系，也是安装过程的一部分。

  * **在没有询问并征得用户的同意之前，安装程序绝对不能删除用户的数据。**

  * **部署一个紧急修复的bug应该很简单，特别是在生产服务器的环境中。你知道这会发生，而且你不想在压力之下，在凌晨3点半，你还在手工部署系统。**

  * 用户应该可以安全并且完整地卸载安装程序，特别是在质量保证人员的机器环境中。

  * 如果维护安装脚本变得很困难，那很可能是一个早期警告，预示着——很高的维护成本（或者不好的设计决策）。

  * 如果你打算把持续部署系统和产品CD或者DVD刻录机连接到一起，你就可以自动地为每个构建制作出一个完整且有标签的光盘。任何人想要最新的构建，只要从架子上拿最上面的一张光盘安装即可。

 ### 16 使用演示获得频繁反馈

  > “这不是你的过错，问题出在我们的客户——那些麻烦的最终客户和用户身上。他们不停地更改需求，导致我们严重地延期。他们一次就应该想清楚所有想要的东西，然后把这些需求给我们，这样我们才能开发出令他们满意的系统。这才是正确的工作方式。”

  > Andy如是说……
  >
  > 维护项目术语表
  >
  > **不一致的术语是导致需求误解的一个主要原因。企业喜欢用看似普遍浅显的词语来表达非常具体、深刻的意义。**
  >
  > **我经常看到这样的事情：团队中的程序员们，使用了和用户或者业务人员不同的术语，最后因为“阻抗失调”导致bug和设计错误。**
  >
  > **为了避免这类问题，需维护一份项目术语表。人们应该可以公开访问它，一般是在企业内部网或者Wiki上。这听起来似乎是一件小事情——只是一个术语列表及其定义。但是，它可以帮助你，确保你真正地和用户进行沟通。**
  >
  > **在项目的开发过程中，从术语表中为程序结构——类、方法、模型、变量等选择合适的名字，并且要检查和确保这些定义一直符合用户的期望。**

  > **清晰可见的开发。在开发的时候，要保持应用可见（而且客户心中也要了解）。每隔一周或者两周，邀请所有的客户，给他们演示最新完成的功能，积极获得他们的反馈。**

  切身感受

  项目启动了一段时间之后，你应该进入一种舒适的状态，团队和客户建立了一种健康的富有创造性的关系。**突发事件应极少发生。客户应该能感觉到，他们可以在一定程度上控制项目的方向。**

  > 跟踪问题
  >
  > 随着项目的进展，你会得到很多反馈——修正、建议、变更要求、功能增强、bug修复等。要注意的信息很多。随机的邮件和潦草的告示帖是无法应付的。所以，要有一个跟踪系统记录所有这些日志，可能是用Web界面的系统。更多详情参阅《软件项目成功之道》。
  
  平衡的艺术

  * **当你第一次试图用这种方法和客户一起工作的时候，也许他们被这么多的发布吓到了。所以，要让他们知道，这些都是内部的发布（演示），是为了他们自己的利益，不需要发布给全部的最终用户。**

  * **一些客户，也许会觉得没有时间应付每天、每周甚至是每两周的会议。毕竟，他们还有自己的全职工作。**

  * **所以要尊重客户的时间。如果客户只可以接受一个月一次会议，那么就定一个月。**

  * **一些客户的联络人的全职工作就是参加演示会议。他们巴不得每隔1小时就有一次演示和反馈。你会发现这么频繁的会议很难应付，而且还要开发代码让他们看。缩减次数，只有在你做完一些东西可以给他们演示的时候，大家才碰面。**

  * 演示是用来让客户提出反馈的，有助于驾驭项目的方向。**如果缺少功能或者稳定性的时候，不应该拿来演示，那只能让人生气。可以及早说明期望的功能：让客户知道，他们看到的是一个正在开发中的应用，而不是一个最终已经完成的产品。**

## 第5章　敏捷反馈

### 19 守护天使

  单元测试的理由：
  * **单元测试能及时提供反馈**.你的代码会重复得到锻炼.但若修改或者重写了代码,测试用例就会检查你是否破坏了已有的功能.你可以快速得到反馈,并很容易的修复他们.

  * **单元测试让你的代码更加健壮**.测试帮助你全面思考代码的行为,帮你练习正面和反面以及异常情况.

  * **单元测试是有用的设计工具**.正如我们在实践20中谈论到的,单元测试有助于实现简单的,注重实效的设计.

  * **单元测试是让你自信的后台**.你测试代码,了解它在各种不同条件下的行为.这会让你在面对新的任务,时间紧迫的巨大压力之下,找到自信.

  * **单元测试是解决问题是的探测器**. 单元测试就像是测试印制电路板的示波镜.当问题出现的时候,你可以快速地给代码发送一个脉冲信号.这为你提供了一个很自然的发现和解决问题的方法(见习惯35,第136页).

  * **单元测试是可信的文档**.当你开始学习新API的时候,它的单元测试是最精确的可靠的文档.

  * **单元测试是学习工具**.在你开始学习新API的时候,可以为这个API写个单元测试,从而加深自己的理解.这写学习用的测试,不仅能帮助你理解API的行为,还能保证你快速找到以后可能引入的,无法与现有代码兼容的变化.

 > **使用自动化的单元测试**.好的单元测试能够为你的代码问题提供及时的警报.如果没有到位的单元测试,不要进行任何设计和代码修改.

  切身感受

  你依赖与单元测试.如果代码没有测试,你会觉得很不舒服,就像是在高空作业没有系安全带一样.

  **平衡的艺术**

  * **单元测试是优质股,值得投资.但一些简单的属性访问方法或者价值不大的方法,是不值得花费时间进行测试的.**
  * 人们不编写单元测试的很多借口都是因为代码中的设计缺陷.通常,抗议越强烈,就说明越糟糕.
  * **单元测试只有在达到一定测试覆盖率的时候,才能真正地发挥作用.你可以使用一些测试覆盖率工具,大致了解自己的单元测试的翻盖情况.**
  * **不测试越多质量就会越高,测试必须要有效.如果测试无法发现任何问题,也许它们就是没有测试对路.**

### 20 先用它在来实现它

  > “请进，先完成所有的代码库，后面会有大量时间看到用户是否是如何思考，现在只有把代码仍过去就可以了，我保证它没有问题”

  很多成功的公司都是靠着“吃自己的狗食”活着。**也就是说，如果要让你的产品尽可能的好，自己先要积极地使用它。**

  幸运的是，我们不是在狗食业务，但是，我们的业务是要创造出能调用的API和可以使用的接口，事实上，在你刚做完设计但还没完成后面的实现的时候，应使用它，这个可行吗？

  使用 被称为TDD（Test Driven Development，测试驱动开发的技术，你总是在一个失败的单元测试后才开始编码，测试）失败要么是因为测试方法不存在，要么是因为方法的逻辑不足以让测试通过。

  **先测试，你就会站在代码用户的角度去思考，而不仅仅是一个单纯的实现者，这样就是很大区别，你就会发现以为自己要使用它们，所以能设计一个更有，更一致的接口。**

  TDD有机会让你编写的代码之前（或者至少深入到实现之前），可以深思熟虑将如何用它，这会迫使你去思考它的可用性和便利性，并然你的设计更加注重实效。

  **当然，设计不是开始编码的时候就结束了，你需要在它色生命周期中持续地添加测试，添加代码，并重新设计代码（更多信息参考第133也习惯28）。**

  > 先用它在来实现它。将TDD作为设计工具，它会为你带来更简单游实数的设计。

  切身感受

  这种感受就是，只在有具体理由的时候才开始编码，你可以专注设计接口。而不会被很多实现的细节干扰

  平衡的艺术

  * 不要把测试优先和提交代码之前的测试等同起来，测试先行可以帮助你改进设计，但是你还是需要在提交代码之前做的测试。
  * 任何一个设计都可以被改进。
  * **你在验证一个想法或者设计一个原型的时候，单元测试也许不适合，但是。万一这些代码不幸仓促演变成一个真正的系统，就必须要为他们添加测试（但是最后重新开始设计系统）。**
  * **单纯的单元测试无法保证好的设计，但它们会对设计有帮助，会然设计更加简单。**

### 21 不同环境，就有不同问题

  > “只要代码能在你的机器上运行就可以了，谁会去关心她是否可以在其他平台上工作，你又不用其他平台。”

  如果厂商或者同事说了这样的套话：“哦，那不会有什么不同。”你可以打赌，他们错了，只要环境不同，就很可能会有不同的问题。

  Ventkat真正在项目中学到了这一课，他的一个同事抱怨说mVenkat的代码失败了。但奇怪的是，问题在于，这于再Venkat机器上通过的一个测试一模一样。实际上，它在一台机器上可以运行，在另一台机器上就不工作。

  最后，他们终于找到罪魁祸首：一个NET环境下的API在Windows XP 和Window3002上的行为不同。平台的不同，造成了结果不一样。

  他们算是幸运的，能够偶然发现这个问题，否则，很可能在产品投入使用的时候才会发现。如果很晚才发现这个问题，成本会非常昂贵———现象一下产品发表之后，才发现他并不支持应该支持的平台，那会怎么样。

  也许，你会要求测试团队在所有支持的平台上进行测试，如果他们的手工精细测试，可能并不是最可靠的测试办法，我们需要根据面向开发者的测试办法。

  你已经编写了单元测试，测试你的代码，每次在修改或者重构代码的时候在提交代码之前，你会运行测试办法，那么现在所要做的就是各种支持的平台和环境运行这些测试用例。

  如果你的应用程序在不同操作系统上运行（例如 MacOs，Linux，Windows等），或者一个操作系统的不同版本（例如：Windows 2000，Windows XP ，Windows 2003 等）你需要测试所有的操作系统。如果你的应用程序要在不同的版本的Java虚拟机或者不同的NET CLR中运行，你也需要测试他们。

  **但是，也许你已经有时间压力了，因此，你怎么可能哟时间在多个平台上运行测试呢？这就要靠持续集成来拯救了。**

  **我们在前面的保持可以发布中学过，用一个持续集成工具，周期性的从源代码控制系统中取得代码，并运行代码，如果有任何测试失败了，它会通知相关的开发者，通知方式可能是电子邮件，页面，RSS Feed，或者其他一些新颖的方式！**

  要在多个平台上测试，你只要为每个平台设置持续集成系统就行了，但你或者同事提交代码，测试会在每个平台上自动运行，这样，提交代码之后的几分钟，你就可以知道它是否可以在不同的平台上运行！这是多么英明的办法呀！

  构建机器的硬件成本相当于开发人员的几个小时而已。如果需要，你甚至可以是用VMware或Virtual PC这样的虚拟机产品，在一台机器上运行不同版本的操作系统 ，VM或CLR。

  > **不同环境有不同问题。使用持续集成工具，在每一种支持的平台和环境中运行单元测试，要积极地寻找问题，而不是等问题来找你。**

  切身感受

  感觉就像是单元测试，非但如此，而且还是跨越不同的世界的单元测试。

  平衡的艺术

  * 硬件比开发人员的时间更便宜，但如果你有很配置，要支持大量的平台，可以选择哪些平台需要内部测试。
  * 只因为不同的栈层顺序,不同的单词大小写但而过，就能发现很多的平台上的bug。因此，即使运行 Solaris的客户比用Linux的少的很多，你仍然要在两个系统上进行测试
  * 你不希望因为一个错误而收到5次通过轰炸（这就像双重征税，会导致电子游戏疲劳症）。可以设置一个主构建平台或者配置，降低其他的构建服务器的运行频率，这样在它失败的时候，你就哟足够多的时间来修复构建平台，或者汇总所以错误报告信息到一个地方，进行统一处理。

### 22 自动验收测试

  > “很好，你现在用单元测试来验证代码是否完成了你期望的行为，发给客户吧。我们很快会知道这是否算是用户期望的功能。”

  你于用户一起工作，开发他们想要的功能，但现在，你要能确保他们得到的数据库是正确的，至少在用户看来它是正确的。

  几年前，Andy做了一个项目，在项目中，他们的行业标准规定凌晨12:00点式一天的最后一分钟，在12:01是一天的最早一分钟（一般情况下，商业计算机系统任务凌晨11:59是一天的最后一分钟，12:00是一天的最早的一分钟）在验收测试的时候这个很小的细节导致一个严重的问题——无法进行正确的合计。

  **关键业务逻辑必须要独立精细严格的测试，并且最后需要通过用户的审批。**

  但你也不可能拉这用户，逐一检查每个单元测试运行结果。实际上你需要能自动比较用户期望和实际完成的工作。

  有一个办法是可以是验收测试不同于单元测试你应该让用户在不必学习编码的情况下，根据自己的需要进行添加，更新和修改数据，你有很多方法来实现它。

  Andy使用了一下架构，把测试数据放到一个页面文件中并且用户可以直接修改这些实际。Venkat实现Excel做过类似的事情，根据环境的不同，也可以找出一种能然偶那个号自然接收的方法（数据可以在页面的文件Excel 文件，数据库中）。或者可以考虑选择一个现成的测试工具，它们会会你完成很多功能。

  FIT，即集成测试框架，它很实用，可以更容易的使用HTML表格定义的测试用例，并比较测试结果的数据。

  使用FIT，客户可以定义带有新功能的使用样本，客户，测试人员和开发人员（根据样本）都可以成绩表格，为代码描述可能的输入和输出值，开发人员会参照带有正开发的代码结果在FIT表格中的样本编写测试代码，测试结果成功或者失败都会显示在HTML教程页面中，用户可以很方便的查阅。

  如果领域专家提供了业务的算法，运算后者方程式，为他们实现一套可以独立运行的测试（参考第136页习惯35）。要让这些测试都成为测试套件的一部分，你会在项目生命周期保持实现为他们提供正确的答案。

  > **为刻心的业务逻辑创建测试。让你的客户单独验证这些测试，要让他们像一般的测试一样可以自动运行。**

  切身感受

  它像是协作完成的单元测试：你仍然是在编写测试，但从其他人那里获取答案。

  平衡的艺术

  * 不是所有客户都恩能够给你提供正确的数据，如果他们已经有了正确的数据，就根本不需要新的系统了。
  * 你也许会在旧系统（运行时电脑系统，也是是人工系统）中发现一起根本不知道的bug，或者一起不存在的真正的问题
  * **使用客户的业务逻辑，但是不要陷于无边无际的文档写作之中。**.

### 23 度量真实的进度

  > “用自己的时间表报告工作进度，我们会用它做项目计划，不用管那些时间的工作时间，每周填满40小时就可以了。”

  **时间的消逝（通常很快）可以证明：判断工作进度最后是看实际花费的时间而不是估计的时间。**

  **哦，你说早已经用时间进行了追踪。不幸的是，几乎所有公司的时间表都是会工资会计准备的，不是用度量软件项目的开发进度的。**例如：如果你工作了60个小时，也许你的老板会让你在时间表上只填写40个小时，这是公司会计想到的，所以，时间表很难真实的反映工作完成的状况，因此它不可以用来进行羡慕计划,评估或表现评估。

  即使没有时间表，一下开发人员还是很难面对现实了解自己的真实进度，你曾经听到开发人员报告一个任务完成了80%吗？然而过了一天又一天，一周又周，那个任务仍然是完成了80%？随意用一个比率进行度量是没有意义的，这就好比说80%是对的（除非你是政客，否则对和错应该是布尔条件）。所以，**我们不应该去计算工作完成的百分比，而应该测试还剩下多少工作量没有完成。如果你最初估计这个任务需要40个小时，在开发35个小时之后，你认为你还需要另外30个小时的工作。那就得到了最重要的度量结果（这里诚实非常重要，隐瞒真相毫无意义）。**

  **在你最后真正完成一项任务时，要清楚知道完成这个任务真正花费的时间。奇怪的是，它花费的时间很有可能要比最初估计时间长。没有关系，我们希望这能作为下一次的参考，在为下一个任务估计工作量时，可以根据这次经验调整评估，如果你低估了一个任务，评估师2天，它最后花费了6天，那么系数就是3。除非是异常情况，否则你应该对下一次估计乘以系数3。你的评估会波动一段时间，有时候过低估计，有时候会过高估计。但随着时间的推移，你的评估会于事实接进近，你也会对任务所花费的时间更清楚地认识。**

  **如果能一直让下一步工作是可见的，会助于进度度量。组合的做法就是使用待办事项（backlog）。**

  待办事项就是等待完成的任务列表，当一个任务被完成了，它就会在列表中移动（逻辑上的，而物理上就是把它冲列表中划掉或者标识它是完成的状态）。当添加新新任务的时候，先排列他们的优先级，然后加入到待办事项中。你也可以由各人的待办事项,当前迭代的待办事项或者整个项目的待办事项。

  **通过代办事项，就可以随时知道下一步最重要的任务是什么。同事你的评估技巧也在不停的改进，你也会越来越清楚完成一些任务的花费的时间。**

  清楚项目的真实进度，是一项强大的技术。

  > **度量剩下的工作量。不要用不恰当的度量来欺骗自己或者团队，要评估那些需要完成的待办事项。，要让他们像一般的测试一样可以自动运行。**

  切身感受

  **你会觉得很舒服，因为你很清楚哪些任务已经完成，哪些是还没有完成，以及他们的优先级。**

  平衡的艺术

  * **6分钟作为一个时间单位，它的粒度实在是太细了，这不是敏捷的做法。**
  * **一周或者一个月的时间单元，它的粒度太粗了，这不是敏捷的做法。**
  * **关注功能，而不是日程表。**
  * 如果你在一个项目中花费了很多时间来了解你所花费的时间，而没有足够的时间进行工作，那么你在了解你所花费的时间上花费的时间久太多了，听懂了吗。
  * **一周工作40个小时，不是说你就有40个小时的编码时间，你需要减少去会议,电话,电子邮件以其他相关活动的时间。**

### 24 倾听用户的声音

  > “用户就是会抱怨，这不是你的过错，是用户太愚蠢了，连使用手册都看不懂。它不是bug，只是用户不明白如何使用而已，他们本应该知道更多”。

  Andy曾经在一家大公司工作过，为高端的Unix工作站开发产品。在这个环境中，你不是简单的运行setup.exe文件或者pkgadd命令，就可以完成软件的安装。你必须在工作站上复制文件并调整各种设置。

  Andy和他的团队成员们觉得一切工作的很顺利。直到一天，Andy走过几十支持部门的工作间，听到一个技术支持工程师对着电话大笑：“哦，这不是bug，你只是犯了一个每个人都会犯得错误。”并且，不只是这一个工程师，整个部门都在嘲笑这些可怜,天真和愚蠢的客户。

  倒霉的客户必须要配置那些包含以下魔法数字的模糊系统文件，否则系统根本运行不起来。系统即没有错误提示消息，也不会破溃,只是显示大黑屏和一个斗大的“退出”按钮。事实上，安装说明书中有一行提到了这样的问题，但显然80%的用户忽略了这个信息,因此只能求助公司的技术支持部门,并遭到他们的嘲笑.

  正如我们在第128页第7章中所说,当出了错误,你要尽可能地提供详细信息.黑屏和含义不明的”退出”按钮是很不友好的行为.更糟糕的是,在得到用户反馈的时候,还嘲笑用户愚蠢,而不去真正地解决问题.

  **不管它是否是产品的bug,还是文档的bug,或者是对用户社区理解的bug,它都是团队的问题.而不是用户的问题.**

  下面是一个案例是:一个昂贵的专业车间的控制系统,没有任何一个用户会使用.因为,使用系统的第一步是要输入用户名和密码,进行登录.但这个车间的大部分工人都是文盲,没有人去问过他们,也没有去收集他们的反馈.就这样,为用户安装了一个无用的系统.最后,花费巨大的费用,开发人员重新开发了一个基于图片的使用界面.

  **我们花费了很大的精力从单元测试之类的代码中获得反馈,但却容易忽略最终用户的反馈.你不仅需要和真实用户(不是他们的经理,也不是业务分析师之类的代理人)进行交谈,还分需要耐心地倾听.**

  即使他们说的内容很傻!

  > **每一个抱怨的背后都隐藏了一个事实.找出真相,修复真正的问题.**

  切身感受

  对客户的那些愚蠢抱怨,你既不会生气,也不会轻视,你会查看一下,找出背后真正的问题.

  平衡的艺术:
  
  * **没有愚蠢的用户.**
  * **只有愚蠢,自大的开发人员.**
  * **“它就是这样的.”这不是一个好的答案.**
  * **如果代码问题解决不了,也许可以考虑通过修改文档或者培训来弥补.**
  * **你的用户有可能会阅读所有的文档,记住其中的所有内容.但也可能不会.**

## 第6章　敏捷编码

## 第7章　敏捷调试

## 第8章　敏捷协作

### 38 定期安排会面时间

  > 会议安排得越多越好。实际上，我们要安排更多的会议，直到发现为什么工作总是完不成。”

  也许你个人很讨厌开会，但是沟通是项目成功的关键。我们不只要跟客户谈话，还应该与其他开发人员进行良好的沟通。

  **立会（站着开的会议）是将团队召集在一起，并让每个人了解当下进展状况的好办法。顾名思义，参与者们不允许在立会中就做，这可以保证会议快速进行。一个人坐下来之后，会由于感到舒适而让会议持续更长的时间。**

  要保证会议议题不会发散，每个人都应该只回答下述三个问题：

  * **昨天有什么收获？**
  * **今天计划要做哪些工作？**
  * **面临着哪些障碍？**

  **只能给予每个参与者很少的发言时间（大约2分钟）**。**也许要用计时器来帮助某些收不住话头的人**。如果要详细讨论某些问题，可以在立会结束之后，再召集相关人员。

  **通常，立会都是在每个工作日的早些时候，且大家都在上班时举行。但是不要把它安排为上班后的第一件事。要让大家有机会从刚才混乱的交通状况中回复状态，喝点咖啡，删除一些垃圾邮件什么的。要保证会议结束后又足够的时间，让大家在午餐之前做不少工作，同时也不要开始得过早，让每个人巴不得赶紧结束会议，去喝点东西。一般来说，在大家到公司之后的半个小时到一个小时之内举行，是个不错的选择。**

  > 猪与鸡
  >
  > Scrum将团队成员与非团队成员这两种角色命名为猪和鸡。团队成员是猪（自尊何在啊）非团队成员（管理层、支持人员、QA等）是鸡。这两个用语来自一个寓言，讲的是农场里的动物们打算一起开饭店，并且准备用意肉和鸡蛋作为早餐提供。对于鸡来说，当然是要参与进来了，可对于猪来讲，可就是放血投入了。
  >
  > 只有“猪”才允许参与 Scrum的每日立会。

  参加会议的人要遵守一些规则，以保证彼此不会分神，而且会议也不会跑题。**这些规则有：只有团队成员一一开发人员、产品所有者和协调者可以发言（查看上面对“猪”和“鸡”的描述）。他们必须回答上面的3个问题，而且不能展开深入讨论（讨论可以安排在会后进行）。管理层可以把要解决的问题记下来，但是不能试图将会议从每个人要回答的三个问题引开。**

  每日立会有诸多好处。

  * **让大家尽快投入到一天的工作中来。**
  * **如果某个开发人员在某一点上有问题，他可以趁此机会将问题公开，并积极寻求帮助。**
  * **帮助团队带头人或管理层了解哪些领域需要更多的帮助，并重新分配人手。**
  * **让团队成员知道项目其他部分的进展情况。**
  * **帮助团队识别是否在某些东西上有重复劳动而耗费了精力，或者是不是某个问题有人已有现成的解决方案。**
  * **通过促进代码和思路的共享，来提升开发速度。**
  * **鼓励向前的动力：看到别人报告的进度都在前进，会对彼此形成激励。**

  > 使用厨房计时器
  >
  > 开发者 Nancy Davis告诉我们她使用厨房计时器召开立会的经验
  >
  > “我们使用了妹妹去年圣诞节送给我的一个厨房计时器。它在运行时不会发出嘀哒”的声音，只会在时间到达后发出“可的一声。如果计时器停止了，我们就再加两分钟，并让下一个成员发言。有时会忘掉计时器的存在，并让会议持续需要的时间，但是大部分情况下，我们都会遵守计时器的提醒。”

  采取立会的形式需要管理层的承诺和参与。不过，团队中的开发人员可以帮助推行这个实践。如果开发人员无法说服管理层的参与，他们自己可以用非正式的形式召开立会。

  > 使用立会。立会可以让团队达成共识。保证会议短小精悍不跑题。

  切身感受

  **大家都盼望着立会。希望彼此了解各自的进度和手上的工作，而且不怕把各自遇到的问题拿出来公开讨论。**

  平衡的艺术

  * **会议会占用开发时间，所以要尽量保证投入的时间有较大的产出。立会的时间最长不能超过30分钟，10~15分钟比较理想。**
  * **如果要使用需提前预定的会议室，就把预定的时间设定为1小时吧。这样就有机会在15分钟的立会结束后，马上召开更小规模的会议。**
  * **虽然大多数团队需要每天都碰头，但对于小型团队来说，这样做可能有点过头了。不妨两天举行一次，或者一周两次，这对小团队来说足够了。**
  * **要注意报告的细节。在会议中要给出具体的进度，但是不要陷入细节之中。**
  * **迅速地开始可以保证会议短小。不要浪费时间等着会议开始。**
  * **如果觉得立会是在浪费时间，那可能是大家还没有形成真正的团队意识。这并不是坏事，有利于针对问题进行改进。**

### 39 架构师必须写代码

  > 我们的专家级架构师Fred会提供设计好的架构，供你编写代码。他经验丰富，拿的薪水很高，所以不要用一些愚蠢的问题或者实现上的难点来浪费他的时间。”

  软件开发业界中有许多挂着架构师称号的人。作为作者的我们不喜欢这个称号，为什么呢？架构不了能在weri片中进行偏师应该负责设计和指导，但是许多名片上印着“架You cant code in Powerpoint构师”的人配不上这个称号。**作为架构师，不应该只是画一些看起来很漂亮的设计图，说一些像“黑话”一样的词汇，使用一大堆设计模式一一这样的设计通常不会有效的。**

  **一个设计要解决的是眼前面临的特定问题，随着设计的实现，对问题的理解也会发生改变。想在开始实现之前，就做出一个很有效的详细设计是非常困难的（见第48页习惯11）**。因为没有足够的上下文，能得到的反馈也很少，甚至没有。设计会随着时间而演进，如果忽略了应用的现状（它的具体实现），要想设计一个新的功能，或者完成某个功能的提开是不可能的。

  **作为设计人员，如果不能理解系统的具体细节，就不可能做出有效的设计。只通过一些高度高阔的、粗略的设计图无法很好地理解系统。**

  这就像是尝试仅仅通过查看地图来指挥一场战役旦开打，仅有计划是不的。战略上的决策也许可以在后方进行，但是战术决策一一影响成败的决策需要对战场状况的明确了解

  > 可逆性
  >
  > 不存在所谓的最终决策。没有哪个决策做出之后就是板上钉钉了。实际上，就时间性来看，不妨把每个重要的决策，都看作是在变化之前所做出的预先规划。

  > 新系统的设计者
  >
  > **新系统的设计者必须要亲自投入到实现中去。**
  >
  > <p align="right">——Donald E Knuth</p>

  正像 Knuth说的，**好的设计者必须能够卷起袖子，加入开发队伍，毫不犹豫地参与实际编程**。真正的架构师，如果不允许参与编码的话，他们会提出强烈的抗议。有一句泰米尔谚语说：“只有一张蔬菜图无法做出好的咖理菜。”与之类似，纸上的设计也无法产生优秀的应用。应该根据设计开发出原型，经过测试，当然还有验证一它是要演化的。实现可用的设计，这是设计者或者说架构师的责任。

  Martin Fowler在题为“ Who Needs an Architect？”e的文章中提到：一个真正的架构师“…应该指导开发团队，提升他们的水平，以解决更为复杂的问题”

  他接着说：“我认为架构师最重要的任务是：通过找到移除软件设计不可逆性的方式，从而去除所谓架构的概念。”增强可逆性是注重实效的软件实现方式的关键构成部分。

  **要鼓励程序员参与设计。主力程序员应该试着担任架构师的角色，而且可以从事多种不同的角色。他会负责解决设计上的问题，同时也不会放弃编码的工作。如果开发人员不愿意承担设计的责任，要给他们配备一个有良好设计能力的人。程序员在拒绝设计的同时，也就放弃了思考。**

  > **优秀的设计从积极的程序员那里开始演化。积极的编程可以带来深入的理解。不要使用不愿意编程的架构师一一不知道系统的真实情况，是无法展开设计的。**

  切身感受

  **架构、设计、编码和测试，这些工作给人的感觉就像是同一个活动一一开发的不同方面。感觉它们彼此之间应该是不可分割的。**

  平衡的艺术

  * **如果有一位首席架构师，他可能没有足够的时间来参与编码工作。还是要让他参与，但是别让他开发在项目关键路径上的、工作量最大的代码。**
  * **不要允许任何人单独进行设计，特别是你自己。**

### 40 实行代码集体所有制

  > “不用担心那个烦人的bug，Joe下周假期结東回来后会把它解决掉的在此之前先想个权宜之计应付一下吧。”

  任何具备一定规模的应用，都需要多人协作进行开发。在这种状况下，不应该像国家宣称对领土的所有权一样，声明个人对代码的所有权。任何一位团队成员，只要理解某段代码的来龙去脉，就应该可以对其进行处理。**如果某一段代码只有一位开发人员能够处理，项目的风险无形中也就增加了。**

  相比找出谁的主意最好、谁的代码实现很烂而言，解决问题，并让应用满足用户的期望要更为重要。

  当多人同时开发时，代码会被频繁地检查、重构以及维护。如果需要修复bug，任何一名开发人员都可以完成这项工作。**同时有两个或两个以上的人，可以处理应用中不同部分的代码，可以让项目的日程安排也变得更为容易。**

  **在团队中实行任务轮换制，让每个成员都可以接触到不同部分的代码，可以提升团队整体的知识和专业技能**。当Joe接过Sally的代码，他可以对其进行重构，消除待处理的问题。在试图理解代码的时候，他会问些有用的问题，今早开始对问题领域的深入理解。

  **另一方面，知道别人将会接过自己的代码，就意味着自己要更守规矩。当知道别人在注意时，一定会更加小心。**

  **可能有人会说，如果一个开发者专门应对某一领域中的任务，他就可以精通该领域，并让后续的开发任务更加高效。这没错，但是眼光放长远一点，有好几双眼睛盯着某一段代码，是一定可以带来好处的。这样可以提升代码的整体质量，使其易于维护和理解，并降低出错率。**

  > 要强调代码的集体所有制。让开发人员轮换完成系统不同领域中不同模块的不同任务

  切身感受

  项目中绝大部分的代码都可以轻松应对。

  平衡的艺术

  * **不要无意间丧失了团队的专家技能。如果某个开发人员在某个领域中机器精通，不妨让他作为这方面的驻留专家，而且系统的其他部分代码也对他开放，这样对团队和项目都很有帮助。**
  * **在大型项目中，如果每个人都可以随意改变任何代码，一定会把项目弄得一团糟。代码集体所有制并不意味着可以随心所欲、到处破坏。**
  * **开发人员不必了解项目每一部分的每个细节，但是也不能因为要处理某个模块的代码而感到惊恐。**
  * **有些场合是不能采用代码集体所有制的。也许代码需要某些特定的知识、对特定领域的了解，比如一个高难度的实时控制系统。这些时候，人多了反而容易误事。**
  * **任何人都可能遭遇到诸如车祸等突发的灾难事故，或者有可能被竞争对手雇佣。如果不向整个团队分享知识，反而增加了丧失知识的风险。**

### 41 成为指导者

  > “你花费了大量的时间和精力，オ达到目前的水平。对别人要有所保留这样让你看起来更有水平。让队友对你超群的技能感到恐惧吧。”

  我们有时会发现自己在某些方面，比其他团队成员知道得更多。那要怎么对待这种新发现的“权威地位”呢？当然，用它来质疑别人，取笑他人做出的决策和 knowledge grows when given开发的代码一一有些人就是这样做的。不过，我们可以共享自己的知识，让身边的人变得更好

  > 好的想法不会因为被许多人了解而削弱。当我听到你的主意时，我得到了知识，你的主意也还是很棒。同样的道理，如果你用你的蜡烛点燃了我的，我在得到光明的同时，也没有让你的周围变暗。好主意就像火。可以引领这个世界，同时不削弱自己。

  **与团队其他人一起共事是很好的学习机会。知识有一些很独特的属性；假设你给别人钱的话，最后你的钱会变少，而他们的财富会增多。但如果是去教育别人，那双方都可以得到更多的知识。**

  **通过详细解释自己知道的东西，可以使自己的理解更深入。当别人提出问题时，也可以发现不同的角度。也许可以发现一些新技巧——听到一个声音这样告诉自己：“我以前还没有这样思考过这个问题。”**

  **与别人共事，激励他们变得更出色，同时可以提升团队的整体实力。遇到无法回答的问题时，说明这个领域的知识还不够完善，需要在这方面进一步增强。好的指导者在为他人提供建议时会做笔记。如果遇到需要花时间进一步观察和思考的问题，不妨先草草记录下来。此后将这些笔记加入到每日日志中。**

  成为指导者，并不意味着要手把手教团队成员怎么做，也不是说要在白板前进行讲座，或是开展小测验说明的，可以在进行自备午餐会时展开讨论。多数时候，成为指导者，是指在帮助团队成员提升水平的同时也提高自己。

  这个过程不必局限于自己的团队。可以开设个人博客，贴一些代码和技术在上面。不一定是多么伟大的项目，即使是一小段代码和解释，对别人也可能是有帮助的。

  成为指导者意味着要分享——而不是固守——自己的知识、经验和体会。意味着要对别人的所学和工作感兴趣，同时愿意为团队增加价值。一切都是为了提高队友和你的能力与水平，而不是为了毁掉团队。

  然而，努力爬到高处，再以蔑视的眼神轻视其他人，这似乎是人类本性。也许在没有意识到的情况下，沟通的障碍就已经建立起来了。团队中的其他人可能出于畏惧或尴尬，而不愿提出问题，这样就无法完成知识的交换了。这类团队中的专家，就像是拥有无数金银财宝的有钱人，却因健康原因无福享受。**我们要成为指导别人的人，而不是折磨别人的人。**

  > 成为指导者。分享自己的知识很有趣一一付出的同时便有收获。还可以激励别人获得更好的成果，而且提升了整个团队的实力。

  切身感受

  **你会感到给予别人教导，也是提升自己学识的一种方式，并且其他人亦开始相信你可以帮助他们。**

  平衡的艺术

  * **如果一直在就同一个主题向不通过的人反复阐述，不妨记录笔记，此后就此主题写一篇文章，甚至是一本书。**
  * **成为指导者是向团队进行投资的一种极佳的方式。**
  * **结对编程是一种进行高效指导的、很自然的环境。**
  * **如果总是被一些懒于自己寻找答案的人打扰。为团队成员在寻求帮助之前陷入某个问题的时间设定一个时限，一个小时应该是不错的选择。**

### 42 允许大家自己想办法

  “授人以鱼，三餐之需；授人以渔，终生之用。”告诉团队成员解决问题的方法，页要让他们知道如何解决问题的思路，这也是成为指导者的一部分。

  了解上个实践一一成为指导者一一之后，也许有人会倾向于直接给同事一个答案，以继续完成工作任务。要是只提供一些指引给他们，让他们自己想办法找到答案，又会如何？

  这并不是多么麻烦的事情；不要直接给出像“42”这样的答案，应该问你的队友“你有没有査看在事务管理者与应用的锁处理程序之间的交互关系？”

  这样做有下面几点好处：

  * 你在帮助他们学会如何解决问题。
  * 除了答案之外，他们可以学到更多东西。
  * **他们不会再就类似的问题反复问你。**
  * 这样做，可以帮助他们在你不能回答问题时自己想办法。
  * **他们可能想出你没有考虑到的解决方法或主意。这是最有趣的——你也可以学到新东西。**

  **如果有人还是没有任何线索，那就给更多提示吧（或者甚至是答案）。如果有人提出来某些想法，不妨帮他们分析每种想法的优劣之处。如果有人给出的答案或解决方法更好，那就从中汲取经验，然后分享你的体会吧。这对双方来说都是极佳的学习经验。**

  作为指导者，应该鼓励、引领大家思考如何解决问题。第20页提到过亚里士多德的话：“能欣赏自己并不接受的想法，表明你的头脑足够有学识。”应该接纳别人的想法和看问题的角度，在这个过程中，自己的头脑也得到了拓展。

  如果整个团队都能够采纳这样的态度，可以发现团队的知识资本在快速提升，而且将会完成一些极其出色的工作成果。

  > 给别人解决问题的机会。指给他们正确的方向，而不是直接提供解决方案。每个人都能从中学到不少东西

  切身感受

  **感觉不是在以填鸭式的方式给予别人帮助。不是有意掩饰，更非讳莫如深，而是带领大家找到自己的解决方案。**

  平衡的艺术

  * 用问题回答问题，可以引导提问的人走上正确的道路。
  * **如果有人真的陷入胶着状态，就不要折磨他们了。告诉他们答案，再解释为什么是这样。**

### 43 准备好后再共享代码

  >“别管是不是达到代码签入的要求，要尽可能频繁地提交代码，特别是在要下班的时候。

  让你猜个谜语：相对不使用版本控制系统，更坏的状况是什么？答案是：错误地使用了版本控制系统。使用版本控制系统的方式，会影响生产力、产品稳定性、产品质量和开发日程。特别地，诸如代码提交频率这样简单的东西都会有很大影响。

  **完成一项任务后，应该马上提交代码，不应该让代码在开发及其上多停留一分钟。**如果代码不能被别人集成使用，那又有什么用处呢？应该赶紧发布出去，并开始收集反馈。

  很明显，每周或每月一次提交代码，并不是令人满意的做法一一这样源代码控系统就不能发挥其作用了。也许总有种种原因来为这种懒散的做法解释。有人说开发人员是采取异地开发（of-site）或离岸开发（ offshore）的方式，访问源代码控制系统的速度很慢。这就是环境黏性（ environmental viscosity）的例子正事情做糟要比做好更容易。很明显，这是一个待解决的简单技术问题。

  另一方面，如果在任务完成之前就提交代码，会带来很多风险。这些代码可能还有编译错误，或者对其所做的某些变化与系统其它部分的代码不兼容。当其它开发者获取最新版本的代码时，也会受到这些代码的影响。

  向代码库中提交仍在开发的代码，会带来很多风险。这些代码可能还有编译错误，版本的代码时，也会受到这些代码的影响。或者对其所做的某些变化与系统其他部分的代码不兼容。当其他开发者获取最新版本的代码时，也会收到这些代码的影响。

  通常情况下，提交的文件应该与一个特定的任务或是一个bug的解决相关。而且应该是同时提交相关的文件，并注有日志信息，将来页能够知道修改了哪些地方，以及为什么要做修改。一旦需要对变更采取回滚操作，这种“原子”提交也是有帮助的。

  **要保证在提交代码之前，所有的单元测试都是可以通过的。使用持续集成是保证源代码控制系统中代码没有问题的一种良好方式。**

  > 代码不执行提交操作的其他安全选择
  > 
  > 如果需要将尚未完成的源代码碣传输或是保存起来，有如下选择。
  >
  > 使用远程访问。将代码留在工作地点，然后在家里使用远程访问获取，而不是将完成了一半的代码提交，再从家里签出
  >
  > 随身携带。将代码复制到U盘、CD或DVD中，以达到异地开发的目的。
  >
  > 使用带有底座扩展的笔记本电脑。如果是由于在多台电脑上开发造成的延续性问题，不妨考虑使用带有底座扩展的笔记本电脑，这样就可以带着代码到处走了。
  >
  > 使用源代码控制系统的特性。 Microsoft Visual Team System2005有一个shelving”特性，因为有些产品的某些代码在提交之前，需要被其他部分调用在CVS和 Subversion中，可以将尚未允许合并到主干的代码，设定为开发者的分支（查看[TH03]和Mas05]）

  > 准备好后再共享代码。绝不要提交尚未完成的代码。故意签入编译未通过或是没有通过单元测试的代码，对项目来说，应被视作玩忽职守的犯罪行为。

  **切身感受**

  **感觉好像整个团队就在源代码控制系统的另一端町着你。要知道一旦提交代码，别人就都可以访问了。**

  平衡的艺术

  * 有些源代码控制系统会区分“提交”和“可公开访问”两种代码权限。此时，完全可以进行临时的提交操作。（VS中TFS的搁置集？）
  * 有些人希望代码在提交之前可以进行复查操作。只要不会过久拖延提交代码的时间就没有问题。如果流程的某个部分产生了拖延，那就修正流程吧。
  * 仍然应该频繁提交代码。不能用“代码尚未完成”作为避免提交代码的借口。（至少在开发分支上是如此。）

### 44 做代码复查

  > “用户是最好的测试人员。别担心一一如果哪里出错了，他们会告诉我们的。”

代码刚刚完成时，是寻找问题的最佳时机。如果放任不管，它也不会变得更好。

  > 代码复查和缺陷移除
  >
  > 要寻找深藏不露的程序bug，正式地进行代码检查，其效果是任何已知形式测试的两倍，而且是移除80%缺陷的唯一已知方法。
  >
  > <p align="right">——Capers Jones的《估算软件成本》[Jon98]]</p>

  正如 Capers Jones指出的，代码复查或许是找到并解决问题的最佳方式。然而，有时很难说服管理层和开发人员使用它来完成开发工作。

  **管理层担心进行代码复查所耗费的时间。他们不希望团队停止编码，而去参加长时间的代码复査会议**。开发人员对代码复查感到担心，允许别人看他们的代码，会让他们有受威胁的感觉。这影响了他们的自尊心。他们担心在情感上受到打击。

  作者参与过的项目中，只要实施了代码复查，其成果都是非常显著的。

  Venkat最近参与了一个日程安排非常紧湊的项目，团队不少成员都是没有多少经验的开发者。通过严格的代码复查过程，他们可以提交质量极高而且稳定的代码当开发人员完成某项任务的编码和测试后，在签入源代码控制系统之前，会有另名开发人员对代码做彻底的复査。

  这个过程修复了很多问题。噢，代码复查不只针对初级开发者编写的代码一团队中每个开发人员的代码都应该进行复查，无论其经验丰富与否。

  那该如何进行代码复査呢？可以从下面这些不同的基本方式中进行选择。

  * ロ通宵复查。可以将整个团队召集在一起，预定好美食，每个月进行一次“恐怖的代码复査之夜”。但这可能不是进行代码复査最有效的方式（而且听起来也不太敏捷）。大規模团队的复査会议很容易陷入无体止的讨论之中。大范围的复查不仅没有必要，而且有可能对整个流程造成损害。我们不建议这种方式。
  * **捡拾游戏。当某些代码编写完成、通过编译、完成测试，并已经准备签入时，其他开发人员就可以“捡拾”起这些代码开始复查。类似的“提交复查”是种快速而非正式的方式，保证代码在提交之前是可以被接受的。为了消除行为上的惯性，要在开发人员之间进行轮换**。比如，如果Joey的代码上次是由Jane复査的，这次不妨让Mak来复查。这是一种很有效的技术。
  * **结对编程。在极限编程中，不存在一个人独立进行编码的情况。编程总是成对进行的：一个人在键盘旁边（担任司机的角色），另一个人坐在后面担任导航员。他们会不时变换角色。有第二双眼睛在旁边盯着，就像是在进行持续的代码复査活动，也就不必安排单独的特定复查时间了。**

  在代码复查中要看什么呢？你可能会制订出要检查的一些特定问题列表（所有的异常处理程序不允许空，所有的数据库调用都要在包的事务中进行，等等），不过这里是一个可供启动的最基本的检查列表
  
  * **代码能否被读懂和理解？**
  * **是否有任何明显的错误？**
  * **代码是否会对应用的其他部分产生不良影响？**
  * **是否存在重复的代码（在复查的这部分代码中，或是在系统的其他部分代码）？口是否存在可以改进或重构的部分？**

  此外，还可以考虑使用诸如 Similarity Analyzeri或 Jester这样的代码分析工具。如果这些工具产生的静态分析结果对项目有帮助，就把它们集成到持续构建中去吧

  > 复查所有的代码。对于提升代码质量和降低错误率来说，代码复查是无价之宝，如果以正确的方式进行，复查可以产生非常实用而高效的成果要让不同的开发人员在每个任务完成后复查代码吗。

  切身感受

  代码复査随着开发活动持续进行，而且每次针对的代码量相对较少。感觉复查活动就像是项目正在进行的一部分，而不是一种令人畏惧的事情。

  平衡的艺术

  * 不进行思考、类似于橡皮图章一样的代码复查没有任何价值。
  * **代码复查需要积极评估代码的设计和清晰程度，而不只是考量变量名和代码格式是否符合组织的标准。**
  * **同样的功能，不同开发人员的代码实现可能不同。差异并不意味着不好。除非你可以让某段代码明确变得更好，否则不要随意批评别人的代码。**
  * **如果不及时跟进讨论中给出的建议，代码复查是没有实际价值的。可以安排跟进会议，或者使用代码标记系统，来标识需要完成的工作，跟踪己经处理完的部分。**
  * **要确保代码复査参与人员得到每次复査活动的反馈。作为结果，要让每个人知道复查完成后所采取的行动。**

### 45 及时通报进展与问题

  > “管理层、项目团队以及业务所有方，都仰仗你来完成任务。如果他们想知道进展状况，会主动找你要的。还是埋头继续做事吧

  接受一个任务，也就意味着做出了要准时交付的承诺。不过，遇到各种问题从而导致延迟，这种情形并不少见。截止日期来临，大家都等着你在演示会议上展示工作成果。如果你到会后通知大家工作还没有完成，会有什么后果？除了感到窘迫，这对你的事业发展也没有什么好处。

  **如果等到截止时间才发布坏消息，就等于是为经理和技术主管提供了对你进行微观管理（ micromanagement）的机会。他们会担心你再次让他们失望，并开始每天多次检查你的工作进度。你的生活就开始变得像呆伯特的漫画一样了。**

  假定现在你手上有一个进行了一半的任务，由于技术上的难题，看起来不能准时完成了。如果这时积极通知其他相关各方，就等于给机会让他们提前找出解决问题的方案。也许他们可以向另外的开发人员寻求帮助，也许他们可以将工作重新分配给更加熟悉相关技术的人，也许他们可以提供更多需要的资源，或者调整目前这个送代中要完成的工作范围。客户会愿意将这个任务用其他同等重要的任务进行交换的。

  **及时通报进展与问题，有情况发生时，就不会让别人感到突然，而且他们也很愿意了解目前的进展状况。他们会知道何时应提供帮助，而且你也获得了他们的信任。**

  发送电子邮件，用即时贴传递信息，或快速电话通知，这都是通报大家的传统方式。还可以使用 Alistair Cockburn提出的“信息辐射器”。°信息辐射器类似于墙上的海报，提供变更的信息。路人可以很方便地了解其中的内容。以推送的方式传递信息，他们就不必再来问问题了。信息辐射器中可以展示目前的任务进度，和团队、管理层或客户可能会感兴趣的其他内容。

  也可以使用海报、网站、Wiki、博客或者 RSS Feed.。只要让人们可以有规律地查看到需要的信息，这就可以了。

  整个团队可以使用信息辐射器来发布他们的状态、代码设计、研究出的好点子等内容。现在只要绕着团队的工作区走一圈，就可以学到不少新东西，而且管理层也就可以知道目前的状况如何了。

  > **及时通报进展与问题。发布进展状况、新的想法和目前正在关注的主题不要等着别人来问项目状态如何。**

  **切身感受**

  **当经理或同事来询问工作进展、最新的设计，或研究状况时，不会感到头痛。**

  **平衡的艺术**

  * **每日立会（见第148页习惯38）可以让每个人都能明确了解最新的进展和形势。**
  * **在展示进度状况时，要照顾到受众关注的细节程度。举例来说，CEO和企业主是不会关心抽象基类设计的具体细节的。**
  * **别花费太多时间在进展与问题通报上面，还是应该保证开发任务的顺利完成。**
  * **经常抬头看看四周，而不是只埋头于自己的工作。**

## 第9章　尾声：走向敏捷
