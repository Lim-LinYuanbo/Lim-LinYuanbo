<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/12/30/vim-study-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/30/vim-study-notes/" class="post-title-link" itemprop="url">vim 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-30 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+00:00">2019-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 13:18:12" itemprop="dateModified" datetime="2022-01-04T13:18:12+00:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vim/" itemprop="url" rel="index"><span itemprop="name">vim</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>为什么我要用 VIM ？是的，第一，我喜欢装逼；第二， VIM 确实非常好用可以完全把双手放在键盘之上，把鼠标丢进垃圾桶。</p>
<p>个人学习总结，因为以前我使用 VIM 至少在单个文本上编辑的，在项目工程上都是使用 source insight ，项目工程上一般会有很多文件直接的关联，所以我觉得可以先使用 VIM 阅读代码，然后再进入编辑阶段。</p>
</blockquote>
<p>我的工作环境：</p>
<p>操作系统：Windows 10</p>
<p>Linux系统：WSL Ubuntu 18.04 LTS</p>
<p>Vim版本: VIM - Vi IMproved 8.0</p>
<p>仓库地址：<a target="_blank" rel="noopener" href="https://github.com/Lim-LinYuanbo/vim-init">vim-init</a></p>
<h3 id="代码阅读篇"><a href="#代码阅读篇" class="headerlink" title="代码阅读篇"></a>代码阅读篇</h3><h4 id="从-source-insight-到-vim"><a href="#从-source-insight-到-vim" class="headerlink" title="从 source insight 到 vim"></a>从 source insight 到 vim</h4><ol>
<li><p>搭建属于自己的环境，出于偷懒，可以直接使用 <a target="_blank" rel="noopener" href="https://github.com/skywind3000/vim-init">vim-init</a> 快速完成这个过程。</p>
<p> 根据 vim-init 的文档，安装过程如下：</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 .vim 文件夹 与 .vimrc 文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir .vim</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch .vimrc</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 克隆工程到本地</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .vim/</span></span><br><span class="line">/.vim$ git clone https://github.com/Lim-LinYuanbo/vim-init</span><br><span class="line">Cloning into &#x27;vim-init&#x27;...</span><br><span class="line">remote: Enumerating objects: 14, done.</span><br><span class="line">remote: Counting objects: 100% (14/14), done.</span><br><span class="line">remote: Compressing objects: 100% (11/11), done.</span><br><span class="line">remote: Total 400 (delta 7), reused 9 (delta 3), pack-reused 386</span><br><span class="line">Receiving objects: 100% (400/400), 257.20 KiB | 345.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (235/235), done.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加如下配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vi ~/.vimrc</span></span><br><span class="line">source ~/.vim/vim-init/init.vim</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 vi 运行 :PlugInstall</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示安装完成：Finishing ... Done!</span></span><br></pre></td></tr></table></figure></li>
<li><p>额外需要安装的插件，如下：</p>
<p> <del><a target="_blank" rel="noopener" href="https://ctags.io/">ctags</a> 上古时期的还是挺好用的，安装指令：<code>sudo apt-get install exuberant-ctags</code>。</del></p>
<p> <del><a target="_blank" rel="noopener" href="http://cscope.sourceforge.net/">cscope</a> 同样感觉是上古时期的工具，安装指令：<code>sudo apt-get install cscope</code>。</del></p>
<p> <a target="_blank" rel="noopener" href="https://www.gnu.org/software/global/">global</a> 使用<a target="_blank" rel="noopener" href="https://github.com/ludovicchabant/vim-gutentags">gutentags</a>似乎需要安装global这个玩意，直接 <code>sudo apt-get install global</code> 安装即可。</p>
</li>
<li><p>source insight 新建工程，同步代码阶段。</p>
<p> 以 <a target="_blank" rel="noopener" href="https://github.com/RT-Thread/rt-thread">RT-Thread</a> 源码工程为例，在工程目录，这是一个 git 目录，无需创建 .root 文件。</p>
<blockquote>
<p>补充：假如如果使用 .git 所处层级的源码太多，那么可以在指定曾经创建一个 .root 来指定项目根目录（已经实测，感觉没有毛病）</p>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/skywind3000/vim-init/blob/master/init/init-plugins.vim">https://github.com/skywind3000/vim-init/blob/master/init/init-plugins.vim</a></p>
<p>“———————————————————————-</p>
<p>“ 自动生成 ctags/gtags，并提供自动索引功能</p>
<p>“ 不在 git/svn 内的项目，需要在项目根目录 touch 一个空的 .root 文件</p>
<p>“ 详细用法见：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36279445">https://zhuanlan.zhihu.com/p/36279445</a></p>
<p>“———————————————————————-</p>
</blockquote>
<p> 进入项目文件并使用 vi 打开文件之后，就会创建上述索引缓冲区 <code>~/.cache/tags/home-ubuntu-rt-thread</code></p>
</li>
<li><p>文件树菜单，该功能类似 source insight 的 Project Folder Browser 。</p>
<blockquote>
<p>具体配置参考：<a target="_blank" rel="noopener" href="https://github.com/skywind3000/vim-init/blob/master/init/init-plugins.vim">init-plugins.vim</a></p>
<p>使用 <a target="_blank" rel="noopener" href="https://github.com/preservim/nerdtree">nerdtree</a> 打开文件</p>
<p>1.在源码根目录下触发 <code>vi .</code> 就可以直接触发</p>
<p>2.在 vi 下普通模式，按下 <code>space nt</code>(<code>space nt</code> 默认配置按键) 或 运行 <code>:NERDTree</code></p>
<p>3.在 NERDTree 窗口中，按下 <code>o</code> 可以打开文件并将光标跳转到文件窗口，按下 <code>go</code> 则为打开文件但光标不跳转到文件窗口</p>
<p>4.在 NERDTree 窗口中，按下 <code>t</code> 或 <code>T</code> 可以以新标签形式打开文件，<code>t</code> 与 <code>T</code> 的区别类似 <code>o</code> 与 <code>go</code></p>
<p>5.基于第4点，打开多个标签可以使用 <code>alt+数字键</code> 切换标签，具体按键配置参考：<a target="_blank" rel="noopener" href="https://github.com/skywind3000/vim-init/blob/master/init/init-keymaps.vim">init-keymaps.vim</a></p>
</blockquote>
</li>
<li><p>文件模糊查找，该功能类似 source insight 的 Project File List 。</p>
<blockquote>
<p>具体配置参考：<a target="_blank" rel="noopener" href="https://github.com/skywind3000/vim-init/blob/master/init/init-plugins.vim">init-plugins.vim</a></p>
<p>“———————————————————————-</p>
<p>“ LeaderF：CtrlP / FZF 的超级代替者，文件模糊匹配，tags/函数名 选择</p>
<p>“———————————————————————-</p>
<p>默认启动方式与常用功能：</p>
<ol>
<li><p>在 vi 下普通模式 <code>&lt;c-p&gt;</code> 触发，输入文件名后回车确认</p>
</li>
<li><p>在模糊查找窗口，使用 <code>&lt;c-j&gt;</code> 和 <code>&lt;c-k&gt;</code> 进行文件上下选择</p>
</li>
</ol>
</blockquote>
</li>
<li><p>函数列表，该功能类似 source insight 的 Symbol Window 。</p>
<blockquote>
<p>具体配置参考：<a target="_blank" rel="noopener" href="https://github.com/skywind3000/vim-init/blob/master/init/init-plugins.vim">init-plugins.vim</a></p>
<p>“ ALT+p 打开函数列表，按 i 进入模糊匹配，ESC 退出</p>
<p><code>noremap &lt;m-p&gt; :LeaderfFunction!&lt;cr&gt;</code></p>
</blockquote>
</li>
<li><p>代码阅读之跳转</p>
<blockquote>
<p>具体配置参考：<a target="_blank" rel="noopener" href="https://github.com/skywind3000/vim-init/blob/master/init/init-plugins.vim">init-plugins.vim</a><br><a target="_blank" rel="noopener" href="https://github.com/skywind3000/gutentags_plus">gutentags_plus</a></p>
<p>使用 <code>&lt;leader&gt;cs</code> 搜索之后底部弹窗 Preview，选中之后：</p>
<p>1.回车打开；</p>
<p>2.小写p打开新窗口预览；</p>
<p>3.大写P关闭窗口预览；</p>
</blockquote>
</li>
<li><p>搜索</p>
</li>
</ol>
<hr>
<h3 id="代码编写篇"><a href="#代码编写篇" class="headerlink" title="代码编写篇"></a>代码编写篇</h3><h4 id="第一阶段：参考-简明-VIM-练级攻略-（耗子叔的这篇文章真的很棒）"><a href="#第一阶段：参考-简明-VIM-练级攻略-（耗子叔的这篇文章真的很棒）" class="headerlink" title="第一阶段：参考 简明 VIM 练级攻略 （耗子叔的这篇文章真的很棒）"></a>第一阶段：参考 <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/5426.html">简明 VIM 练级攻略</a> （耗子叔的这篇文章真的很棒）</h4><h4 id="第二阶段：使用-spf13-vim-中的插件提升编码效率"><a href="#第二阶段：使用-spf13-vim-中的插件提升编码效率" class="headerlink" title="第二阶段：使用 spf13-vim 中的插件提升编码效率"></a>第二阶段：使用 <del>spf13-vim</del> 中的插件提升编码效率</h4><ol>
<li><p>注释</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/preservim/nerdcommenter">nerdcommenter</a> 常用的使用方法：…，效果如图：</p>
</li>
<li><p>自动补全</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Shougo/neocomplete.vim">neocomplete</a> spf13-vim 默认使用的插件</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ycm-core/YouCompleteMe">youcompleteme</a> google开发的工具，安装有点麻烦</p>
<p>至于两个工具的比较，网上已经铺天盖地，效果如下：</p>
<p>贴个动图…</p>
</li>
</ol>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="YouCompleteMe"><a href="#YouCompleteMe" class="headerlink" title="YouCompleteMe"></a>YouCompleteMe</h4><ol>
<li><p>使用 vi 打开 .c 文件之后提示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoExtraConfDetected: No .ycm_extra_conf.py file detected, so no compile flags are available. Thus no semantic suppor...</span><br></pre></td></tr></table></figure>

<p> 通过查阅网上资料与官方说明：</p>
<ol>
<li><p>在官方说明 <code>C-family Semantic Completion</code> 章节有说到与 <code>.ycm_extra_conf.py</code> 文件相关的说法。</p>
</li>
<li><p>目前网上一些解决方案应该使用的是 <code>Option 2: Provide the flags manually</code>。</p>
</li>
</ol>
<p> 以下是我参考网上的做法与我的理解，解决该问题步骤如下：</p>
<ol>
<li><p>首先创建 <code>.ycm_extra_conf.py</code> 文件（文件位置自定义）</p>
</li>
<li><p>填写 <code>.ycm_extra_conf.py</code> 文件内容，参考 <a target="_blank" rel="noopener" href="https://github.com/ycm-core/YouCompleteMe/issues/2249">issues</a></p>
</li>
<li><p>在你的 <code>.vimrc</code> 中使用 <code>let g:ycm_global_ycm_extra_conf = xxx</code> 指定你的 <code>.ycm_extra_conf.py</code> 路径</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/09/dts-gpio-keys/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/09/dts-gpio-keys/" class="post-title-link" itemprop="url">GPIO-KEY 学习调试笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-09T00:00:00+00:00">2019-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 13:18:12" itemprop="dateModified" datetime="2022-01-04T13:18:12+00:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">设备驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="GPIO-KEY-学习调试笔记"><a href="#GPIO-KEY-学习调试笔记" class="headerlink" title="GPIO-KEY 学习调试笔记"></a>GPIO-KEY 学习调试笔记</h3><p>硬件平台:<a target="_blank" rel="noopener" href="http://www.topeetboard.com/Product/iMX6UL.html">iMX6UL开发板</a></p>
<p>u-boot版本:uboot-imx(rel_imx_4.1.15_2.0.0_ga)</p>
<p>kernel版本:linux-imx(rel_imx_4.1.15_2.0.0_ga)</p>
<p>步骤一:修改设备树内容</p>
<p>参考资料:</p>
<blockquote>
<p>linux-imx/Documentation/devicetree/bindings/input/gpio-keys.txt</p>
</blockquote>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">/ &#123;</span></span><br><span class="line"><span class="class">    <span class="class">keys_test </span>&#123;</span></span><br><span class="line"><span class="class">        compatible = <span class="string">&quot;gpio-keys&quot;</span>;</span></span><br><span class="line"><span class="class">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span></span><br><span class="line"><span class="class">        pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_keys</span>&gt;</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        key-<span class="class">test </span>&#123;</span></span><br><span class="line"><span class="class">            gpios = <span class="params">&lt;<span class="variable">&amp;gpio1</span> <span class="number">01</span> GPIO_ACTIVE_LOW&gt;</span>;</span></span><br><span class="line"><span class="class">            label = <span class="string">&quot;key-test&quot;</span>;</span></span><br><span class="line"><span class="class">            linux,code = <span class="params">&lt;KEY_ESC&gt;</span>;</span></span><br><span class="line"><span class="class">        &#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;iomuxc</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="symbol">    pinctrl_keys:</span> <span class="class">keygrp </span>&#123;</span><br><span class="line">            fsl,pins = <span class="params">&lt;</span></span><br><span class="line"><span class="params">                MX6UL_PAD_GPIO1_IO01__GPIO1_IO01        <span class="number">0x17059</span></span></span><br><span class="line"><span class="params">            &gt;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>步骤二:重新更新设备树之后,进入系统(<strong>确保系统已经使能gpio-keys驱动</strong>)</p>
<p>参考资料:</p>
<blockquote>
<p>linux-imx/Documentation/input/input.txt</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">~ # cat /proc/bus/input/devices</span><br><span class="line">...</span><br><span class="line">I: Bus=0019 Vendor=0001 Product=0001 Version=0100</span><br><span class="line">N: Name=&quot;keys_test&quot;</span><br><span class="line">P: Phys=gpio-keys/input0</span><br><span class="line">S: Sysfs=/devices/platform/keys_test/input/input3</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=kbd event2</span><br><span class="line">B: PROP=0</span><br><span class="line">B: EV=3</span><br><span class="line">B: KEY=2</span><br><span class="line">...</span><br><span class="line">~ # ls /dev/input/</span><br><span class="line">event0  event1  event2  mice    mouse0</span><br></pre></td></tr></table></figure>

<p>通过查看 <code>cat /proc/bus/input/devices</code> 和 <code>ls /dev/input/</code> 可以看见新的事件添加</p>
<p>以上步骤完成确认设备树添加已经正确</p>
<p>步骤三:编写测试代码,查看运行结果</p>
<p>参考资料:</p>
<blockquote>
<p>input subsystem programing</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_DEV_PATH <span class="meta-string">&quot;/dev/input/event0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(INPUT_DEV_PATH, O_RDONLY);</span><br><span class="line">    assert(fd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;goto for\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;event, <span class="number">0</span>, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        ret = read(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read fail ret=[%d]\n&quot;</span>, ret);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;type=[%d], code=[%d], value=[%d]\n&quot;</span>, event.type, event.code, event.value);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sec=[%lu], usec=[%lu]\n&quot;</span>, event.time.tv_sec, event.time.tv_usec);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:略…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/09/dts-i2c-gpio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/09/dts-i2c-gpio/" class="post-title-link" itemprop="url">I2C-GPIO 学习调试笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-09T00:00:00+00:00">2019-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 13:18:12" itemprop="dateModified" datetime="2022-01-04T13:18:12+00:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">设备驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="I2C-GPIO-学习调试笔记"><a href="#I2C-GPIO-学习调试笔记" class="headerlink" title="I2C-GPIO 学习调试笔记"></a>I2C-GPIO 学习调试笔记</h3><p>硬件平台:<a target="_blank" rel="noopener" href="http://www.topeetboard.com/Product/iMX6UL.html">iMX6UL开发板</a></p>
<p>u-boot版本:uboot-imx(rel_imx_4.1.15_2.0.0_ga)</p>
<p>kernel版本:linux-imx(rel_imx_4.1.15_2.0.0_ga)</p>
<p>步骤一:修改设备树内容</p>
<p>参考资料:</p>
<blockquote>
<p>linux-imx/Documentation/devicetree/bindings/i2c/i2c-gpio.txt</p>
</blockquote>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">/ &#123;</span></span><br><span class="line"><span class="class">    <span class="class">i2c2@0 </span>&#123;</span></span><br><span class="line"><span class="class">        compatible = <span class="string">&quot;i2c-gpio&quot;</span>;</span></span><br><span class="line"><span class="class">        i2c-gpio,sda-open-drain;</span></span><br><span class="line"><span class="class">        i2c-gpio,scl-open-drain;</span></span><br><span class="line"><span class="class">        i2c-gpio,delay-us = <span class="params">&lt;<span class="number">2</span>&gt;</span>;    <span class="comment">/* ~100 kHz */</span> <span class="comment">/* 目前这个值与速率没搞懂 */</span></span></span><br><span class="line"><span class="class">        #address-cells = <span class="params">&lt;<span class="number">1</span>&gt;</span>;</span></span><br><span class="line"><span class="class">        #size-cells = <span class="params">&lt;<span class="number">0</span>&gt;</span>;</span></span><br><span class="line"><span class="class">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span></span><br><span class="line"><span class="class">        pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_i2c2</span>&gt;</span>;</span></span><br><span class="line"><span class="class">        gpios = <span class="params">&lt;</span></span></span><br><span class="line"><span class="params"><span class="class">            <span class="variable">&amp;gpio1</span> <span class="number">31</span> GPIO_ACTIVE_HIGH /* SDA */</span></span></span><br><span class="line"><span class="params"><span class="class">            <span class="variable">&amp;gpio1</span> <span class="number">30</span> GPIO_ACTIVE_HIGH /* SCL */</span></span></span><br><span class="line"><span class="params"><span class="class">        &gt;</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        <span class="comment">/* i2c device node */</span></span></span><br><span class="line"><span class="class">    &#125;;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable">&amp;iomuxc</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="symbol">    pinctrl_i2c2:</span> <span class="class">i2c2grp </span>&#123;</span><br><span class="line">            fsl,pins = <span class="params">&lt;</span></span><br><span class="line"><span class="params">                /* 目前IO是否复用方式可以通过 i.MX Pins Tool v5 查看 */</span></span><br><span class="line"><span class="params">                MX6UL_PAD_UART5_TX_DATA__GPIO1_IO30 <span class="number">0x4001b8b0</span></span></span><br><span class="line"><span class="params">                /* 但是IO后面这个数值没有搞清具体含义,似乎和硬件外围电路有关 */</span></span><br><span class="line"><span class="params">                MX6UL_PAD_UART5_RX_DATA__GPIO1_IO31 <span class="number">0x4001b8b0</span></span></span><br><span class="line"><span class="params">            &gt;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>步骤二:重新更新设备树之后,进入系统(<strong>确保系统已经使能 GPIO-based bitbanging I2C 驱动</strong>)</p>
<p>参考资料:</p>
<blockquote>
<p>linux-imx/Documentation/i2c/*</p>
<p>这里文档较多,但是随便过一下配合GOOGLE就能知道如何使用</p>
</blockquote>
<p>我使用的是i2c-tools作为测试工具,但是目前没有找到这个工具各个参数含义的文档,工具本身 help 命令能提供的描述也特别少.</p>
<p>所以,这个工具我也只是搜索学习了一下使用方法,因为首先我要先确保I2C驱动和设备树是成功添加的.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@debian:~# ls /dev/i2c*</span><br><span class="line">/dev/i2c-4</span><br><span class="line">root@debian:~# ./i2cdetect -l</span><br><span class="line">i2c-4   i2c         i2c2@0                              I2C adapter</span><br><span class="line">root@debian:~# ./i2cdetect -r -y 4</span><br><span class="line">     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f</span><br><span class="line">00:          -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">30: -- -- 32 -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">40: -- -- -- -- -- -- -- -- UU -- -- -- -- -- -- --</span><br><span class="line">50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">70: -- -- -- -- -- -- -- --</span><br></pre></td></tr></table></figure>

<p>通过以上运行结果,可以看到有两个I2C设备,地址分别是:0x32,0x48</p>
<p>步骤三:基础程序验证</p>
<p>参考资料:</p>
<blockquote>
<p>linux-imx/Documentation/i2c/dev-interface</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c-dev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_BUS_PATH <span class="meta-string">&quot;/dev/i2c-1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_DEV_ADDR 0x48</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(I2C_BUS_PATH, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open fail fd=[%d]\n&quot;</span>, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, I2C_RETRIES, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> read_buf[<span class="number">8</span>] = &#123;<span class="number">0x0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">i2c_msg_read</span>[] =</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;I2C_DEV_ADDR, I2C_M_RD, <span class="keyword">sizeof</span>(read_buf), read_buf&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_rdwr_ioctl_data</span> <span class="title">i2c_rw_data</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        .msgs = i2c_msg_read,</span><br><span class="line">        .nmsgs = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ret = ioctl(fd, I2C_RDWR, &amp;i2c_rw_data);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read size=[%d], read data=\n&quot;</span>, <span class="keyword">sizeof</span>(read_buf));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(read_buf); ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%02x]&quot;</span>, read_buf[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果:(略)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/09/dts-led/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/09/dts-led/" class="post-title-link" itemprop="url">LED 学习调试笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-09T00:00:00+00:00">2019-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 13:18:12" itemprop="dateModified" datetime="2022-01-04T13:18:12+00:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">设备驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="LED-学习调试笔记"><a href="#LED-学习调试笔记" class="headerlink" title="LED 学习调试笔记"></a>LED 学习调试笔记</h3><p>硬件平台:<a target="_blank" rel="noopener" href="http://www.topeetboard.com/Product/iMX6UL.html">iMX6UL开发板</a></p>
<p>u-boot版本:uboot-imx(rel_imx_4.1.15_2.0.0_ga)</p>
<p>kernel版本:linux-imx(rel_imx_4.1.15_2.0.0_ga)</p>
<p>步骤一:修改设备树内容</p>
<p>参考资料:</p>
<blockquote>
<p>linux-imx\Documentation\devicetree\bindings\leds</p>
</blockquote>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">/ &#123;</span></span><br><span class="line"><span class="class">    ...</span></span><br><span class="line"><span class="class">    <span class="class">leds_test </span>&#123;</span></span><br><span class="line"><span class="class">        compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span></span><br><span class="line"><span class="class">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span></span><br><span class="line"><span class="class">        pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_leds</span>&gt;</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        led-<span class="class">test </span>&#123;</span></span><br><span class="line"><span class="class">            gpios = <span class="params">&lt;<span class="variable">&amp;gpio3</span> <span class="number">13</span> GPIO_ACTIVE_LOW&gt;</span>;</span></span><br><span class="line"><span class="class">            label = <span class="string">&quot;led-test&quot;</span>;</span></span><br><span class="line"><span class="class">            default-state = <span class="string">&quot;off&quot;</span>;</span></span><br><span class="line"><span class="class">        &#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;iomuxc</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="symbol">    pinctrl_leds:</span> <span class="class">ledgrp </span>&#123;</span><br><span class="line">        fsl,pins = <span class="params">&lt;</span></span><br><span class="line"><span class="params">            MX6UL_PAD_LCD_DATA08__GPIO3_IO13        <span class="number">0x17059</span> // 目前我依然没有知晓后面这个值是什么意思,如何设定</span></span><br><span class="line"><span class="params">        &gt;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>步骤二:重新更新设备树之后,进入系统(<strong>确保系统已经使能gpio-leds驱动</strong>)</p>
<p>参考资料:</p>
<blockquote>
<p>linux-imx\Documentation\leds</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~ # ls /sys/class/leds/</span><br><span class="line">led-test  mmc0::    mmc1::</span><br><span class="line">~ # cd /sys/class/leds/led-test/</span><br><span class="line">/sys/devices/platform/leds_test/leds/led-test # ls</span><br><span class="line">brightness      max_brightness  subsystem       uevent</span><br><span class="line">device          power           trigger</span><br><span class="line">/sys/devices/platform/leds_test/leds/led-test # cat trigger</span><br><span class="line">[none] rc-feedback nand-disk mmc0 mmc1 timer oneshot heartbeat backlight gpio</span><br></pre></td></tr></table></figure>

<p>进入 <code>/sys/class/leds</code> 之后会有新的目录 <code>led-test</code>,该名字与设备树中label对应</p>
<p>进入 <code>/sys/class/leds/led-test</code> 之后可以可以看到几项</p>
<blockquote>
<p>brightness - 亮度,在触发器 none 模式下只有亮/灭两种,通过 cat 可以查看</p>
<p>max_brightness - 最大亮度</p>
<p>trigger - 触发器,触发器分类可以通过 cat 查看</p>
<p>其他项目目前不详,没有测试…</p>
</blockquote>
<p>步骤三:改变触发器,测试各项内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/leds_test/leds/led-test # echo timer &gt; trigger</span><br><span class="line">/sys/devices/platform/leds_test/leds/led-test # ls</span><br><span class="line">brightness      delay_on        max_brightness  subsystem       uevent</span><br><span class="line">delay_off       device          power           trigger</span><br></pre></td></tr></table></figure>

<p>目前测试结论:</p>
<blockquote>
<p>delay_on - 点亮延迟,单位毫秒</p>
<p>delay_off - 熄灭延迟,单位毫秒</p>
<p>写入其他值给触发器项目没有测试…</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/09/mfg-tools-nand-flash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/09/mfg-tools-nand-flash/" class="post-title-link" itemprop="url">imx6ul 配合 mfgtools 使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-09T00:00:00+00:00">2019-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 13:18:12" itemprop="dateModified" datetime="2022-01-04T13:18:12+00:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">设备驱动</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>步骤一:删除多余的 .vbs ,只留下 mfgtool2-yocto-mx-evk-nand.vbs</p>
<blockquote>
<p>为什么?太多碍眼,板子是类似imx6ull-14x14-evk的吧!其他貌似都不合适,所以选了 mfgtool2-yocto-mx-evk-nand.vbs 这个.</p>
</blockquote>
<p>步骤二:删除 files和firmware 多余的文件,只留下fsl-image-mfgtool-initramfs-imx_mfgtools.cpio.gz.u-boot</p>
<blockquote>
<p>为什么?太多碍眼,uboot(<em>.imx) kernel(zImage) dtb(</em>.dtb) rootfs(*.tar.bz2)确实是需要的,但是后续通过更改 ucl2.xml 可以确定需要的文件,通过 MfgTool.log 也可以查看错误和缺少的文件,fsl-image-mfgtool-initramfs-imx_mfgtools.cpio.gz.u-boot 这个文件是运行于RAM的rootfs,不能删除,并且里面有一些命令,比如:nand read和nand write</p>
</blockquote>
<p>步骤三:查看 ucl2.xml 文件(重要)</p>
<blockquote>
<p>只看 <code>ifdev=&quot;MX6ULL&quot;</code> 部分</p>
</blockquote>
<blockquote>
<p>只看 <code>&lt;LIST name=&quot;NAND Flash&quot; desc=&quot;Choose NAND as media&quot;&gt;</code> 部分</p>
</blockquote>
<blockquote>
<p>删除多余内容,整理之后,清晰多了</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LIST</span> <span class="attr">name</span>=<span class="string">&quot;NAND Flash&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;Choose NAND as media&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- file =&quot;firmware/u-boot.imx&quot; 这是 firmware 中u-boot镜像 ,改个名字 u-boot.imx,方便直接替换u-boot不要再次改名了 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;BootStrap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;boot&quot;</span> <span class="attr">body</span>=<span class="string">&quot;BootStrap&quot;</span> <span class="attr">file</span> =<span class="string">&quot;firmware/u-boot.imx&quot;</span> <span class="attr">ifdev</span>=<span class="string">&quot;MX6ULL&quot;</span>&gt;</span>Loading U-boot<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- file=&quot;firmware/zImage&quot; 这是 firmware 中的内核镜像, address=&quot;0x80800000&quot; 中这个 &quot;0x80800000&quot; 是位于RAM中的地址 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;BootStrap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;load&quot;</span> <span class="attr">file</span>=<span class="string">&quot;firmware/zImage&quot;</span> <span class="attr">address</span>=<span class="string">&quot;0x80800000&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">loadSection</span>=<span class="string">&quot;OTH&quot;</span> <span class="attr">setSection</span>=<span class="string">&quot;OTH&quot;</span> <span class="attr">HasFlashHeader</span>=<span class="string">&quot;FALSE&quot;</span> <span class="attr">ifdev</span>=<span class="string">&quot;MX6SL MX6SX MX7D MX6UL MX6ULL&quot;</span>&gt;</span>Loading Kernel.<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- file=&quot;firmware/%initramfs%&quot; 这是 firmware 中的rootfs, address=&quot;0x83800000&quot; 中这个 &quot;0x83800000&quot; 是位于RAM中的地址 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;BootStrap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;load&quot;</span> <span class="attr">file</span>=<span class="string">&quot;firmware/%initramfs%&quot;</span> <span class="attr">address</span>=<span class="string">&quot;0x83800000&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">loadSection</span>=<span class="string">&quot;OTH&quot;</span> <span class="attr">setSection</span>=<span class="string">&quot;OTH&quot;</span> <span class="attr">HasFlashHeader</span>=<span class="string">&quot;FALSE&quot;</span> <span class="attr">ifdev</span>=<span class="string">&quot;MX6SL MX6SX MX7D MX6UL MX6ULL&quot;</span>&gt;</span>Loading Initramfs.<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- file=&quot;firmware/imx6ull-14x14-evk-test.dtb&quot; 这是 firmware 中的dtb, 改个名字 imx6ull-14x14-evk-test.dtb, address=&quot;0x83000000&quot; 中这个 &quot;0x83000000&quot; 是位于RAM中的地址 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;BootStrap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;load&quot;</span> <span class="attr">file</span>=<span class="string">&quot;firmware/imx6ull-14x14-evk-test.dtb&quot;</span> <span class="attr">address</span>=<span class="string">&quot;0x83000000&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">loadSection</span>=<span class="string">&quot;OTH&quot;</span> <span class="attr">setSection</span>=<span class="string">&quot;OTH&quot;</span> <span class="attr">HasFlashHeader</span>=<span class="string">&quot;FALSE&quot;</span> <span class="attr">ifdev</span>=<span class="string">&quot;MX6ULL&quot;</span>&gt;</span>Loading device tree.<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;BootStrap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;jump&quot;</span> &gt;</span> Jumping to OS image. <span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 下面files中文件名也改一下 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 例如:flash_erase,nandwrite...这些命令都是上面这个rootfs提供的,所以不能删除原始的rootfs(即:fsl-image-mfgtool-initramfs-imx_mfgtools.cpio.gz.u-boot) --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 例如:/dev/mtd...这些分区都是 uboot 通过参数传递上来的,所以下面会说到 `bootcmd_mfg` 这个参数传递的分区信息要与 `mtdparts` 匹配,至少我是这样理解的 --&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--burn the uboot to NAND: --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ mount -t debugfs debugfs /sys/kernel/debug&quot;</span>&gt;</span>Mounting debugfs<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ flash_erase /dev/mtd%part_uboot% 0 0&quot;</span>&gt;</span>Erasing Boot partition<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;send&quot;</span> <span class="attr">file</span>=<span class="string">&quot;files/u-boot.imx&quot;</span> <span class="attr">ifdev</span>=<span class="string">&quot;MX6ULL&quot;</span>&gt;</span>Sending u-boot.bin<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ kobs-ng init -x -v --chip_0_device_path=/dev/mtd%part_uboot% $FILE&quot;</span>&gt;</span>Flashing Bootloader<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--burn the kernel to NAND: --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ flash_erase /dev/mtd%part_kernel% 0 0&quot;</span>&gt;</span>Erasing Kernel partition<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;send&quot;</span> <span class="attr">file</span>=<span class="string">&quot;files/zImage&quot;</span>&gt;</span>Sending kernel zImage<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ nandwrite -p /dev/mtd%part_kernel% -p $FILE&quot;</span>&gt;</span>Flashing Kernel<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ flash_erase /dev/mtd%part_dtb% 0 0&quot;</span>&gt;</span>Erasing dtb partition<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;send&quot;</span> <span class="attr">file</span>=<span class="string">&quot;files/imx6ull-14x14-evk-test.dtb&quot;</span> <span class="attr">ifdev</span>=<span class="string">&quot;MX6ULL&quot;</span>&gt;</span>Sending Device Tree file<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ nandwrite -p /dev/mtd%part_dtb% -p $FILE&quot;</span>&gt;</span>Flashing dtb<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--burn the rootfs to NAND: --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ flash_erase /dev/mtd%part_rootfs% 0 0&quot;</span>&gt;</span>Erasing rootfs partition<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ ubiformat /dev/mtd%part_rootfs%&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ ubiattach /dev/ubi_ctrl -m %part_rootfs%&quot;</span>&gt;</span>Attaching UBI partition<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ ubimkvol /dev/ubi0 -Nrootfs -m&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ mkdir -p /mnt/mtd%part_rootfs%&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ mount -t ubifs ubi0:rootfs /mnt/mtd%part_rootfs%&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;pipe tar -jxv -C /mnt/mtd%part_rootfs%&quot;</span> <span class="attr">file</span>=<span class="string">&quot;files/rootfs.tar.bz2&quot;</span> <span class="attr">ifdev</span>=<span class="string">&quot;MX6UL MX7D MX6ULL&quot;</span>&gt;</span>Sending and writting rootfs<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;frf&quot;</span>&gt;</span>Finishing rootfs write<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ umount /mnt/mtd%part_rootfs%&quot;</span>&gt;</span>Unmounting rootfs partition<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">CMD</span> <span class="attr">state</span>=<span class="string">&quot;Updater&quot;</span> <span class="attr">type</span>=<span class="string">&quot;push&quot;</span> <span class="attr">body</span>=<span class="string">&quot;$ echo Update Complete!&quot;</span>&gt;</span>Done<span class="tag">&lt;/<span class="name">CMD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LIST</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以语句 <code>&lt;CMD state=&quot;BootStrap&quot; type=&quot;jump&quot; &gt; Jumping to OS image. &lt;/CMD&gt;</code> 之后RAM内存分区大致如下:</p>
<p><img src="../posts/2019/10/09/MX6ULL-Nand-Flash-MFGTools2.png" alt="mfg_tools Memory organization"></p>
<p><img src="MX6ULL-Nand-Flash-MFGTools2.png" alt="mfg_tools Memory organization"></p>
</blockquote>
<p>步骤三:修改 u-boot 源码+编译(重要)</p>
<blockquote>
<p>源码:<a target="_blank" rel="noopener" href="http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/">http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/</a></p>
</blockquote>
<blockquote>
<p>版本:rel_imx_4.1.15_2.1.0_ga</p>
</blockquote>
<blockquote>
<p>修改文件:./uboot-imx/include/configs/mx6ullevk.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_SDRAM_SIZE <span class="comment">// 修改 RAM 大小,为什么改这里?听别人说的</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区的大小,这个应该是任意的,但是要和 bootcmd 符合吧???我觉得应该是,因为在 ucl2.xml 中要擦除和写入 files 中的内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MFG_NAND_PARTITION <span class="meta-string">&quot;mtdparts=gpmi-nand:4m(boot),16m(kernel),4m(dtb),-(rootfs) &quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MFG_ENV_SETTINGS \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;mfgtool_args=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; &quot;</span> \</span></span><br><span class="line"><span class="meta">    CONFIG_BOOTARGS_CMA_SIZE \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;rdinit=/linuxrc &quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;g_mass_storage.stall=0 g_mass_storage.removable=1 &quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;g_mass_storage.file=/fat g_mass_storage.ro=1 &quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF &quot;</span>\</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;g_mass_storage.iSerialNumber=\&quot;\&quot; &quot;</span>\</span></span><br><span class="line"><span class="meta">	CONFIG_MFG_NAND_PARTITION \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;clk_ignore_unused &quot;</span>\</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;bootcmd_mfg=run mfgtool_args;bootz 0x80800000 0x83800000 0x83000000;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SYS_BOOT_NAND)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_EXTRA_ENV_SETTINGS \</span></span><br><span class="line"><span class="meta">    CONFIG_MFG_ENV_SETTINGS \</span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;panel=TFT43AB\0&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;console=ttymxc0\0&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;bootargs=console=ttymxc0,115200 ubi.mtd=3 &quot;</span>  \</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;root=ubi0:rootfs rootfstype=ubifs &quot;</span>		     \</span></span><br><span class="line"><span class="meta">        CONFIG_BOOTARGS_CMA_SIZE \</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;mtdparts=gpmi-nand:4m(boot),16m(kernel),4m(dtb),-(rootfs)\0&quot;</span>\    <span class="comment">// 类似 CONFIG_MFG_NAND_PARTITION</span></span></span><br><span class="line">    <span class="string">&quot;bootcmd=nand read 0x80800000 0x400000 0x1000000;&quot;</span>\ <span class="comment">// 加载kernel nand read 目标地址(RAM地址) 源地址(nandflash偏移地址) 大小</span></span><br><span class="line">        <span class="string">&quot;nand read 0x83000000 0x1400000 0x400000;&quot;</span>\ <span class="comment">// 加载dtb</span></span><br><span class="line">        <span class="string">&quot;bootz 0x80800000 - 0x83000000\0&quot;</span> <span class="comment">// 这个目前不知道是啥意思</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>语句<code>#define CONFIG_MFG_ENV_SETTINGS</code>中的参数需要与 ucl2.xml 中设定的地址匹配,希望我的理解是正确的 QAQ</p>
<p>语句<code>#define CONFIG_MFG_NAND_PARTITION</code>中的分区设置是在 USB OTG mfg_tools 情况下启动后,对 NAND FLASH 的分区???我是这样理解的</p>
<p>语句<code>mtdparts=gpmi-nand:4m(boot),16m(kernel),4m(dtb),-(rootfs)\0</code>中的分区设置是在 NAND FLASH 情况下启动后,传递给 kernel 或 重新设置分区 的参数???</p>
<p>语句<code>bootcmd=...</code>中偏移量与大小需要与<code>mtdparts=gpmi-nand:...</code>匹配,如上设置之后, NAND FLASH 的具体分区如下:</p>
<p><img src="../posts/2019/10/09/MX6ULL-Nand-Flash-Startup.png" alt="NandFlash Startup Memory organization"></p>
<p><img src="MX6ULL-Nand-Flash-Startup.png" alt="NandFlash Startup Memory organization"></p>
</blockquote>
<p>步骤四:修改 kernel 源码+编译(重要)</p>
<blockquote>
<p>源码:<a target="_blank" rel="noopener" href="http://git.freescale.com/git/cgit.cgi/imx/linux-imx.git/">http://git.freescale.com/git/cgit.cgi/imx/linux-imx.git/</a></p>
</blockquote>
<blockquote>
<p>版本:rel_imx_4.1.15_2.1.0_ga</p>
</blockquote>
<blockquote>
<p>修改文件:./linux-imx/arch/arm/boot/dts/imx6ull-14x14-evk-gpmi-weim.dts</p>
</blockquote>
<blockquote>
<p>为什么修改这个?在没有任何修改 mfg_tools 工具内容之前我直接运行 mfgtool2-yocto-mx-evk-nand.vbs 是需要 imx6ull-14x14-evk-gpmi-weim.dts.dtb 的,所以就顺便看看.</p>
</blockquote>
<blockquote>
<p>原来这个文件里面的内容有 nand flash 相关的内容,虽然我看不懂,但是多少有点关系.<br>另外 &amp;qspi + &amp;usdhc2 我不知道有啥用,删除了吧!应该不影响.<br>修改文件:./linux-imx/arch/arm/boot/dts/imx6ull-14x14-evk.dts<br>这里面也有很多看不懂的东西,只能GOOGLE一下搜索看看,看不懂或者感觉没用的我都删除了.</p>
</blockquote>
<blockquote>
<p>make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm imx_v7_mfg_defconfig</p>
</blockquote>
<blockquote>
<p>make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm zImage</p>
</blockquote>
<blockquote>
<p>生成zImage,覆盖 mfg_tools 中的 files 和 firmware 文件夹中的zImage</p>
</blockquote>
<blockquote>
<p>make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm dtbs</p>
</blockquote>
<blockquote>
<p>生成对应的.dtb,覆盖 mfg_tools 中的 files 和 firmware 文件夹中的dtb</p>
</blockquote>
<hr>
<p>感谢阅读,如果有什么问题或者我理解错误的地方请帮忙矫正,万分感谢!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/09/script-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/09/script-notes/" class="post-title-link" itemprop="url">Xshell/secureCRT脚本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-09T00:00:00+00:00">2019-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 13:18:12" itemprop="dateModified" datetime="2022-01-04T13:18:12+00:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index"><span itemprop="name">tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>xshell vbs script</p>
<p> 建议使用本地帮助文档，如果没有本地文档可以使用在线文档：<a target="_blank" rel="noopener" href="https://netsarang.atlassian.net/wiki/spaces/ENSUP/overview">online</a>。</p>
<p> example :</p>
 <figure class="highlight vbs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">xsh.Screen.Synchronous = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> Main</span><br><span class="line">    <span class="comment">&#x27; send crlf ???</span></span><br><span class="line">    xsh.Screen.Send VbCr</span><br><span class="line">    <span class="comment">&#x27; wait for string &quot;#&quot;yy</span></span><br><span class="line">    xsh.Screen.WaitForString <span class="string">&quot;#&quot;</span></span><br><span class="line">    <span class="comment">&#x27; send command &quot;ls&quot; + crlf ???</span></span><br><span class="line">    xsh.Screen.Send <span class="string">&quot;ls&quot;</span> &amp; VbCr</span><br><span class="line">    <span class="comment">&#x27; wait for string &quot;#&quot;yy</span></span><br><span class="line">    xsh.Screen.WaitForString <span class="string">&quot;#&quot;</span></span><br><span class="line">    <span class="comment">&#x27; sleep 1000ms</span></span><br><span class="line">    xsh.Sleep <span class="number">1000</span></span><br><span class="line">    <span class="comment">&#x27; after 1000ms send command &quot;ls&quot; + crlf ???</span></span><br><span class="line">    xsh.Screen.Send <span class="string">&quot;ls&quot;</span> &amp; VbCr</span><br><span class="line">    <span class="comment">&#x27; wait for string &quot;#&quot;yy</span></span><br><span class="line">    xsh.Screen.WaitForString <span class="string">&quot;#&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure></li>
<li><p>secureCRT vbs script</p>
<p> 这个工具目前用得比较少了，所以GOOGLE一下吧，</p>
<p> example :</p>
 <figure class="highlight vbs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">crt.Screen.Synchronous = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> Main</span><br><span class="line">    <span class="comment">&#x27; send crlf ???</span></span><br><span class="line">    crt.Screen.Send VbCr</span><br><span class="line">    <span class="comment">&#x27; wait for string &quot;#&quot;yy</span></span><br><span class="line">    crt.Screen.WaitForString <span class="string">&quot;#&quot;</span></span><br><span class="line">    <span class="comment">&#x27; send command &quot;ls&quot; + crlf ???</span></span><br><span class="line">    crt.Screen.Send <span class="string">&quot;ls&quot;</span> &amp; VbCr</span><br><span class="line">    <span class="comment">&#x27; wait for string &quot;#&quot;yy</span></span><br><span class="line">    crt.Screen.WaitForString <span class="string">&quot;#&quot;</span></span><br><span class="line">    <span class="comment">&#x27; sleep 1000ms</span></span><br><span class="line">    crt.Sleep <span class="number">1000</span></span><br><span class="line">    <span class="comment">&#x27; after 1000ms send command &quot;ls&quot; + crlf ???</span></span><br><span class="line">    crt.Screen.Send <span class="string">&quot;ls&quot;</span> &amp; VbCr</span><br><span class="line">    <span class="comment">&#x27; wait for string &quot;#&quot;yy</span></span><br><span class="line">    crt.Screen.WaitForString <span class="string">&quot;#&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/09/08/practices-of-an-agile-developer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/08/practices-of-an-agile-developer/" class="post-title-link" itemprop="url">高效程序员的45个习惯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-08T00:00:00+00:00">2019-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 13:18:12" itemprop="dateModified" datetime="2022-01-04T13:18:12+00:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/" itemprop="url" rel="index"><span itemprop="name">博览群书</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中文版：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/4164024/">豆瓣读书</a></p>
<p>英文版：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1767907/">豆瓣读书</a></p>
<h3 id="第1章-敏捷——高效软件开发之道"><a href="#第1章-敏捷——高效软件开发之道" class="headerlink" title="第1章　敏捷——高效软件开发之道"></a>第1章　敏捷——高效软件开发之道</h3><h3 id="第2章-态度决定一切"><a href="#第2章-态度决定一切" class="headerlink" title="第2章　态度决定一切"></a>第2章　态度决定一切</h3><h3 id="第3章-学无止境"><a href="#第3章-学无止境" class="headerlink" title="第3章　学无止境"></a>第3章　学无止境</h3><h3 id="第4章-交付用户想要的软件"><a href="#第4章-交付用户想要的软件" class="headerlink" title="第4章　交付用户想要的软件"></a>第4章　交付用户想要的软件</h3><h4 id="10-让客户做决定"><a href="#10-让客户做决定" class="headerlink" title="10 让客户做决定"></a>10 让客户做决定</h4><blockquote>
<p>“开发者兼具创新和智慧，最了解应用程序。因此，所有关键决定都应该由开发者定夺。每次业务人员介入的时候，都会弄得一团糟，他们无法理解我们做事的逻辑。”</p>
</blockquote>
<p>  在设计方面，做决定的时候必须有开发者参与。可是，在一个项目中，他们不应该做所有的决定，特别是业务方面的决定。</p>
<p>  就拿项目经理Pat的例子来说吧。Pat的项目是远程开发，一切按计划且在预算内进行着——就像是个可以写入教科书的明星项目。Pat高高兴兴地把代码带到客户那里，给客户演示，却败兴而归。</p>
<p>  原来，Pat的业务分析师没有和用户讨论，而是自作主张，决定了所有的问题。在整个开发过程中，企业主根本没有参与具体的决策。项目离完成还早着呢，就已经不能满足用户的需要了。这个项目一定会延期，又成为一个经典的失败案例。</p>
<p>  因而，你只有一个选择：<strong>要么现在就让用户做决定，要么现在就开始开发，迟些让用户决定，不过要付出较高的成本。如果你在开发阶段回避这些问题，就增加了风险，但是你要能越早解决这些问题，就越有可能避免繁重的重新设计和编码。甚至在接近项目最终期限的时候，也能避免与日俱增的时间压力</strong>。</p>
<p>  假设你要完成一个任务，有两种实现方式。第一种方式的实现比较快，但是对用户有一点限制。第二种方式实现起来需要更多的时间，但是可以提供更大的灵活性。很显然，你有时间的压力（什么项目没有时间压力呢），那么你就用第一种很快的方式吗？你凭什么做出这样的决定呢？是投硬币吗？询问同事或者项目经理了吗？</p>
<p>  作者之一Venkat最近的一个项目就遇到了类似的问题。项目经理为了节约时间，采取了第一种方式。也许你会猜到，在Beta版测试的时候，软件暴露出的局限让用户震惊，甚至愤怒。结果还得重做，花费了团队更多的金钱、时间和精力。</p>
<p>  开发者（及项目经理）能做的一个最重要的决定就是：<strong>判断哪些是自己决定不了的，应该让企业主做决定。你不需要自己给业务上的关键问题做决定。毕竟，那不是你的事情。如果遇到了一个问题，会影响到系统的行为或者如何使用系统，把这个问题告诉业务负责人。如果项目领导或经理试图全权负责这些问题，要委婉地劝说他们，这些问题最好还是和真正的业务负责人或者客户商议</strong>。</p>
<p>  当你和客户讨论问题的时候，准备好几种可选择的方案。<strong>不是从技术的角度，而是从业务的角度，介绍每种方案的优缺点，以及潜在的成本和利益。和他们讨论每个选择对时间和预算的影响，以及如何权衡</strong>。无论他们做出了什么决定，他们必须接受它，所以最好让他们了解一切之后再做这些决定。如果事后他们又想要其他的东西，可以公正地就成本和时间重新谈判。</p>
<p>  毕竟，这是他们的决定。</p>
<blockquote>
<p><strong>让你的客户做决定。开发者、经理或者业务分析师不应该做业务方面的决定。用业务负责人能够理解的语言，向他们详细解释遇到的问题，并让他们做决定。</strong></p>
</blockquote>
<h4 id="11-让设计指导而不是操纵开发"><a href="#11-让设计指导而不是操纵开发" class="headerlink" title="11 让设计指导而不是操纵开发"></a>11 让设计指导而不是操纵开发</h4><blockquote>
<p>“设计文档应该尽可能详细，这样，低级的代码工人只要敲入代码就可以了。在高层方面，详细描述对象的关联关系；在低层方面，详细描述对象之间的交互。其中一定要包括方法的实现信息和参数的注释。也不要忘记给出类里面的所有字段。编写代码的时候，无论你发现了什么，绝不能偏离了设计文档。”</p>
</blockquote>
<p>  “设计”是软件开发过程不可缺少的步骤。它帮助你理解系统的细节，理解部件和子系统之间的关系，并且指导你的实现。一些成熟的方法论很强调设计，例如，统一过程（Unified Process，UP）十分重视和产品相关的文档。项目管理者和企业主常常为开发细节困扰，他们希望在开始编码之前，先有完整的设计和文档。毕竟，那也是你如何管理桥梁或建筑项目的，难道不是吗？</p>
<p>  另一方面，敏捷方法建议你早在开发初期就开始编码。是否那就意味着没有设计呢？不，绝对不是，好的设计仍然十分重要。画关键工作图（例如，用UML）是必不可少的，因为要使用类及其交互关系来描绘系统是如何组织的。在做设计的时候，你需要花时间去思考（讨论）各种不同选择的缺陷和益处，以及如何做权衡。</p>
<p>  然后，下一步才考虑是否需要开始编码。如果你在前期没有考虑清楚这些问题，就草草地开始编码，很可能会被很多意料之外的问题搞晕。甚至在建筑工程方面也有类似的情况。在锯一根木头的时候，通常的做法就是先锯一块比需要稍微长一点的木块，最后细致地修整，直到它正好符合需求。</p>
<p>  但是，即使之前已经提交了设计文档，也还会有一些意料之外的情况出现。时刻谨记，此阶段提出的设计只是基于你目前对需求的理解而已。一旦开始了编码，一切都会改变。设计及其代码实现会不停地发展和变化。</p>
<p>  一些项目领导和经理认为设计应该尽可能地详细，这样就可以简单地交付给“代码工人们”。他们认为代码工人不需要做任何决定，只要简单地把设计转化成代码就可以了。就我而言，没有一个愿意在这样的团队中做纯粹的打字员。我们猜想你也不愿意。</p>
<p>  如果设计师们把自己的想法绘制成精美的文档，然后把它们扔给程序员去编码，那会发生什么？程序员会在压力下，完全按照设计或者图画的样子编码。如果系统和已有代码的现状表明接收到的设计不够理想，那该怎么办？太糟糕了！时间已经花费在设计上，没有工夫回头重新设计了。团队会死撑下去，用代码实现了明明知道是错误的设计。这听起来是不是很愚蠢？是够愚蠢的，但是有一些公司真的就是这样做的。</p>
<p>  严格的需求—设计—代码—测试开发流程源于理想化的瀑布式 开发方法，它导致在前面进行了过度的设计。这样在项目的生命周期中，更新和维护这些详细的设计文档变成了主要工作，需要时间和资源方面的巨大投资，却只有很少的回报。我们本可以做得更好。</p>
<p>  <strong>设计可以分为两层：战略和战术。前期的设计属于战略，通常只有在没有深入理解需求的时候需要这样的设计。更确切地说，它应该只描述总体战略，不应深入到具体的细节。</strong></p>
<blockquote>
<p>做到精确</p>
<p>如果你自己都不清楚所谈论的东西，就根本不可能精确地描述它。</p>
<p align="right">——约翰·冯·诺依曼</p>
</blockquote>
<p>  前面刚说过，战略级别的设计不应该具体说明程序方法、参数、字段和对象交互精确顺序的细节。那应该留到战术设计阶段，它应该在项目开发的时候再具体展开。</p>
<p>  <strong>良好的战略设计应该扮演地图的角色，指引你向正确的方向前进。任何设计仅是一个起跑点：它就像你的代码一样，在项目的生命周期中，会不停地进一步发展和提炼。</strong></p>
<p>  下面的故事会给我们一些启发。在1804年，Lewis与Clark进行了横穿美国的壮举，他们的“设计”就是穿越蛮荒。但是，他们不知道在穿越殖民地时会遇到什么样的问题。他们只知道自己的目标和制约条件，但是不知道旅途的细节。</p>
<p>  软件项目中的设计也与此类似。在没有穿越殖民地的时候，你不可能知道会出现什么情况。所以，不要事先浪费时间规划如何徒步穿越河流，只有当你走到河岸边的时候，才能真正评估和规划如何穿越。只有到那时，你才开始真正的战术设计。</p>
<p>  不要一开始就进行战术设计，它的重点是集中在单个的方法或数据类型上。这时，更适合讨论如何设计类的职责。因为这仍然是一个高层次、面向目标的设计。事实上，CRC（类—职责—协作）卡片的设计方法就是用来做这个事情的。每个类按照下面的术语描述。</p>
<ul>
<li>类名。</li>
<li>职责：它应该做什么？</li>
<li>协作者：要完成工作它要与其他什么对象一起工作？</li>
</ul>
<p>  如何知道一个设计是好的设计，或者正合适？代码很自然地为设计的好坏提供了最好的反馈。如果需求有了小的变化，它仍然容易去实现，那么它就是好的设计。而如果小的需求变化就带来一大批基础代码的破坏，那么设计就需要改进。</p>
<p>  <strong>好设计是一张地图，它也会进化。设计指引你向正确的方向前进，它不是殖民地，它不应该标识具体的路线。你不要被设计（或者设计师）操纵。</strong></p>
<p>  <strong>切身感受</strong></p>
<p>  <strong>好的设计应该是正确的，而不是精确的。也就是说，它描述的一切必须是正确的，不应该涉及不确定或者可能会发生变化的细节。它是目标，不是具体的处方。</strong></p>
<p>  <strong>平衡的艺术</strong></p>
<ul>
<li><p><strong>“不要在前期做大量的设计”并不是说不要设计。只是说在没有经过真正的代码验证之前，不要陷入太多的设计任务。当对设计一无所知的时候，投入编码也是一件危险的事。如果深入编码只是为了学习或创造原型，只要你随后能把这些代码扔掉，那也是一个不错的办法。</strong></p>
</li>
<li><p><strong>即使初始的设计到后面不再管用，你仍需设计：设计行为是无价的。正如美国总统艾森豪威尔所说：“计划是没有价值的，但计划的过程是必不可少的。”在设计过程中学习是有价值的，但设计本身也许没有太大的用处。</strong></p>
</li>
<li><p><strong>白板、草图、便利贴都是非常好的设计工具。复杂的建模工具只会让你分散精力，而不是启发你的工作。</strong></p>
</li>
</ul>
<h4 id="12-合理地使用技术"><a href="#12-合理地使用技术" class="headerlink" title="12 合理地使用技术"></a>12 合理地使用技术</h4><blockquote>
<p>“你开始了一个新的项目，在你面前有一长串关于新技术和应用框架的列表。这些都是好东西，你真的需要使用列表中所有的技术。想一想，你的简历上将留下漂亮的一笔，用那些伟大的框架，你的新应用将具有极高技术含量。”</p>
</blockquote>
<p>  从前，作者之一Venkat的同事Lisa向他解释自己的提议：她打算使用EJB。Venkat表示对EJB有些顾虑，觉得它不适合那个特殊的项目。然后Lisa回答道：“我已经说服了我们经理，这是正确的技术路线，所以现在不要再扔‘炸弹’了。”这是一个典型的“简历驱动设计”的例子，之所以选择这个技术，是因为它很美，也许还能提高程序员的技能。但是，盲目地为项目选择技术框架，就好比是为了节省税款而生孩子，这是没有道理的。</p>
<p>  <strong>在考虑引入新技术或框架之前，先要把你需要解决的问题找出来。你的表述方式不同，会让结果有很大差异。如果你说“我们需要xyzzy技术，是因为……”，那么就不太靠谱。你应该这样说：“……太难了”或者是“……花的时间太长了”，或者类似的句子</strong>。找到了需要解决的问题，接下来就要考虑：</p>
<ul>
<li><p><strong>这个技术框架真能解决这个问题吗？是的，也许这是显而易见的。但是，这个技术真能解决你面临的那个问题吗？或者，更尖锐一点说，你是如何评估这个技术的？是通过市场宣传还是道听途说？要确保它能解决你的问题，并没有任何的毒副作用。如果需要，先做一个小的原型。</strong></p>
</li>
<li><p><strong>你将会被它拴住吗？一些技术是贼船，一旦你使用了它，就会被它套牢，再也不可能回头了。它缺乏可取消性，当条件发生变化时，这可能对项目有致命打击。我们要考虑它是开放技术还是专利技术，如果是开放的技术，那又开放到什么程度？</strong></p>
</li>
<li><p><strong>维护成本是多少？会不会随着时间的推移，维护成本变得非常昂贵？毕竟，方案的花费不应该高于要解决的问题，否则就是一次失败的投资。我们听说，有个项目的合同是支持一个规则引擎，引擎一年的维护费用是5万美元，但是这个数据库只有30条规则。这也太贵了。</strong></p>
</li>
</ul>
<p>  当你在考察一个框架（或者任何技术）的时候，也许会被它提供的各种功能吸引。接着，在验证是否使用这个框架的时候，你可能只会考虑已经发现的另外一些功能。但是，你真的需要这些功能吗？也许为了迎合你发现的功能，你正在为它们找问题。这很像站在结账处一时冲动而买些无用的小零碎（那也正是商场把那些小玩意儿放到那里的原因）。</p>
<p>  不久前，Venkat遇到了一个项目。咨询师Brad把一个专有框架卖给了这个项目的管理者。在Venkat看来，这个框架本身也许还有点儿意思，但是它根本不适合这个项目。</p>
<p>  尽管如此，管理者却坚决认为他们要使用它。Venkat非常礼貌地停手不干了。他不想成为绊脚石，阻碍他们的工作进度。一年之后项目还没有完成——他们花了好几个月的时间编写代码来维护这个框架，为了适应这个框架，他们还修改了自己的代码。</p>
<p>  Andy有过相似的经历：他的客户想完全透明地利用开源，他们拥有“新技术大杂烩”，其中的东西太多，以至于无法让所有的部分协同工作。</p>
<p>  如果你发现自己在做一些花哨的东西（比如从头创建自己的框架），那就醒醒吧，闻闻烟味有多大，马上该起火了。你的代码写得越少，需要维护的东西就越少。</p>
<p>  例如，如果你想开发自己的持久层框架，记住Ted Neward的评论：对象—关系的映射就是计算机科学的越南战场3。你可以把更多的时间和精力投入到应用的开发——领域或具体应用中。</p>
<blockquote>
<p><strong>根据需要选择技术。首先决定什么是你需要的，接着为这些具体的问题评估使用技术。对任何要使用的技术，多问一些挑剔的问题，并真实地作出回答。</strong></p>
</blockquote>
<p>  <strong>切身感受</strong></p>
<p>  <strong>新技术就应该像是新的工具，可以帮助你更好地工作，它自己不应该成为你的工作。</strong></p>
<p>  <strong>平衡的艺术</strong></p>
<ul>
<li><p><strong>也许在项目中真正评估技术方案还为时太早。那就好。如果你在做系统原型并要演示给客户看，也许一个简单的散列表就可以代替数据库了。如果你还没有足够的经验，不要急于决定用什么技术。</strong></p>
</li>
<li><p><strong>每一门技术都会有优点和缺点，无论它是开源的还是商业产品、框架、工具或者语言，一定要清楚它的利弊。</strong></p>
</li>
<li><p><strong>不要开发那些你容易下载到的东西。虽然有时需要从最基础开发所有你需要的东西，但那是相当危险和昂贵的。</strong></p>
</li>
</ul>
<h4 id="13-保持可以发布"><a href="#13-保持可以发布" class="headerlink" title="13  保持可以发布"></a>13  保持可以发布</h4><blockquote>
<p>“我们刚试用的时候发现了一个问题，你需要立即修复它。放下你手头的工作，去修复那个刚发现的问题，不需要经过正规的程序。不用告诉其他任何人——赶快让它工作就行了。”</p>
</blockquote>
<p>  这听起来似乎没什么问题。有一个关键修复的代码必须要提交到代码库。这只是一件小事，而且又很紧急，所以你就答应了。</p>
<p>  修复工作成功地完成了。你提交了代码，继续回到以前那个高优先级的任务中。忽然一声尖叫。太晚了，你发现同事提交的代码和你的代码发生了冲突，现在你使得每个人都无法使用系统了。这将会花费很多精力（和时间）才能让系统重新回到可发布的状态。现在你有麻烦了。你必须告诉大家，你不能交付你承诺的修复代码了。而魔鬼在嘲笑：“哈哈哈！”</p>
<p>  这时候，你的处境会很糟糕：系统无法发布了。你弄坏了系统，也许会带来更糟糕的后果。</p>
<p>  1836年，当时的墨西哥总统安东尼奧·洛佩斯·德·圣安那将军，率领部队穿越得克萨斯州西部，追赶败退的萨姆·休斯顿将军。当圣安那的部队到达得克萨斯州东南方向的布法罗河岸的沼泽地带的时候，他命令自己的部队就地休息。传说中认为他是太过自信，甚至没有安排哨兵。就在那个傍晚，休斯顿发动了突然袭击，这时圣安那的部队已经来不及编队了。他们溃不成军，输掉了这场决定性的战争，从此永远改变了得克萨斯州的历史4。</p>
<p>  任何时候只要你没有准备好，那就是敌人进攻你的最佳时机。好好想一想，你的项目进入不可发布状态的频率是多少？你的源代码服务器中的代码，是不是像圣安那在那个决定性的黄昏一样——没有进行编队，遇到紧急情况无法立即启动。</p>
<p>  在团队里工作，修改一些东西的时候必须很谨慎。你要时刻警惕，每次改动都会影响系统的状态和整个团队的工作效率。在办公室的厨房里，你不能容忍任何人乱丢垃圾，为什么就可以容忍一些人给项目带来垃圾代码呢？</p>
<p>  下面是一个简单的工作流程，可以防止你提交破坏系统的代码。</p>
<ul>
<li><p><strong>在本地运行测试。先保证你完成的代码可以编译，并且能通过所有的单元测试。接着确保系统中的其他测试都可以通过。</strong></p>
</li>
<li><p><strong>检出最新的代码。从版本控制系统中更新代码到最新的版本，再编译和运行测试。这样往往会发现让你吃惊的事情：其他人提交的新代码和你的代码发生了冲突。</strong></p>
</li>
<li><p><strong>提交代码。现在是最新的代码了，并且通过了编译和测试，你可以提交它们了。</strong></p>
</li>
</ul>
<p>  在做上面事情的时候，也许你会遇到这样一个问题——其他人提交了一些代码，但是没有通过编译或者测试。如果发生了这样的事情，要立即让他们知道，如果有需要，可以同时警告其他的同事。当然，最好的办法是，你有一个持续集成系统，可以自动集成并报告集成结果。</p>
<p>  这听起来似乎有点恐怖，其实很简单。持续集成系统就是在后台不停地检出、构建和测试代码的应用。你可以自己使用脚本快速实现这样的方式，但如果你选择已有的免费、开源的解决方案，它们会提供更多的功能且更加稳定。有兴趣的话，可以看一看Martin Fowler的文章5，或者是Mike Clark编著的图书《项目自动化之道》。</p>
<p>  再深入一点，假设你得知即将进行的一次重大修改很可能会破坏系统，不要任其发生，应该认真地警告大家，在代码提交之前，找出可以避免破坏系统的方法。选择可以帮助你平滑地引入和转换这些修改的方法，从而在开发过程中，系统可以得到持续的测试和反馈。</p>
<p>  虽然保持系统可发布非常重要，但不会总是那么容易，例如，修改了数据库的表结构、外部文件的格式，或者消息的格式。这些修改，通常会影响应用的大部分代码，甚至导致应用暂时不可用，直到大量的代码修改完成。尽管如此，你还是有办法减轻这样的痛苦。</p>
<p>  为数据库的表结构、外部文件，甚至引用它的API提供版本支持，这样所有相关变化都可以进行测试。有了版本功能，所做的变化可以与其他代码基相隔离，所以应用的其他方面仍然可以继续开发和测试。</p>
<p>  你也可以在版本控制系统中添加一个分支，专门处理这个问题（使用分支需要十分小心，不好的分支也许会给你带来更多的麻烦。详情可以查阅《版本控制之道——CVS》或《版本控制之道——Subversion》）。</p>
<blockquote>
<p>保持你的项目时刻可以发布。保证你的系统随时可以编译、运行、测试并立即部署。</p>
</blockquote>
<p>  切身感受</p>
<p>  你会觉得，不管什么时候，你的老板、董事长、质量保障人员、客户或者你的配偶来公司参观项目的时候，你都能很自信并毫不犹豫地给他们演示最新构建的软件。你的项目一直处于可以运行的稳定状态。</p>
<p>  <strong>平衡的艺术</strong></p>
<ul>
<li><p><strong>有时候，做一些大的改动后，你无法花费太多的时间和精力去保证系统一直可以发布。如果总共需要一个月的时间才能保证它一周内可以发布，那就算了。但这只应该是例外，不能养成习惯。</strong></p>
</li>
<li><p><strong>如果你不得不让系统长期不可以发布，那就做一个（代码和架构的）分支版本，你可以继续进行自己的实验，如果不行，还可以撤销，从头再来。千万不能让系统既不可以发布，又不可以撤销。</strong></p>
</li>
</ul>
<h4 id="14-提早集成，频繁集成"><a href="#14-提早集成，频繁集成" class="headerlink" title="14 提早集成，频繁集成"></a>14 提早集成，频繁集成</h4><blockquote>
<p>“只要没有到开发的末尾阶段，就不要过早地浪费时间去想如何集成你的代码，至少也要等开发差不多的时候，才开始考虑它。毕竟，还没有完成开发，为什么要操心集成的事情呢！在项目的末尾，你有充裕的时间来集成代码。”</p>
</blockquote>
<p>  我们说过，敏捷的一个主要特点就是持续开发，而不是三天打鱼两天晒网似地工作。特别是在几个人一起开发同一个功能的时候，更应该频繁地集成代码。</p>
<p>  很多开发者用一些美丽的借口，推迟集成的时间。有时，不过是为了多写一些代码，或者是另一个子系统还有很多的工作要完成。他们很容易就会这样想：“现在手头上的工作压力够大了，到最后我才能做更多的工作，才能考虑其他人代码。”经常会听到这样的借口：“我没有时间进行集成”或者“在我机器上设置集成环境太费事了，我现在不想做它”。</p>
<p>  但是，在产品的开发过程中，集成是一个主要的风险区域。让你的子系统不停地增长，不去做系统集成，就等于一步一步把自己置于越来越大的风险中，世界没有了你仍然会转动，潜在的分歧会继续增加。相反，尽可能早地集成也更容易发现风险，这样风险及相关的代价就会相当低。而等的时间越长，你也就会越痛苦。</p>
<p>  作者之一Venkat小时候生活在印度钦奈市，经常赶火车去学校。像其他的大城市一样，印度的交通非常拥挤。他每次必须在车还没有停稳的时候，就跳上去或者跳下来。但，你不能从站的地方一下子跳上运行的火车，我们在物理课上学习过这种运动定律。而应该是，首先你要沿着火车行驶的方向跑，边跑边抓住火车上的扶手，然后跳入火车中。</p>
<p>  软件集成就像这一样。如果你不断地独立开发，忽然有一天跳到集成这一步，千万不要为受到打击而吃惊。也许你自己在项目中就有这样的体会：每次到项目结束的时候都觉得非常不爽，大家需要日日夜夜地进行集成。</p>
<blockquote>
<p><strong>你能集成并且独立</strong></p>
<p><strong>集成和独立不是互相矛盾的，你可以一边进行集成，一边进行独立开发。</strong></p>
<p><strong>使用mock对象来隔离对象之间的依赖关系，这样在集成之前就可以先做测试，用一个mock对象模拟真实的对象（或者子系统）。就像是拍电影时在光线的掩饰下使用替身一样，mock对象就是真实对象的替身，它并不提供真实对象的功能，但是它更容易控制，能够模仿需要的行为，使测试更加简单。</strong></p>
<p><strong>你可以使用mock对象，编写独立的单元测试，而不需要立刻就集成和测试其他系统，只有当你自信它能工作的时候，才可以开始集成。</strong></p>
</blockquote>
<p>  当你在公司昏天黑地地加班时，唯一的好处就是可以享受到免费的披萨。</p>
<p>  独立开发和早期集成之间是具有张力的。当你独立开发时，会发现开发速度更快，生产率更高，你可以更有效地解决出现的问题。但那并不意味着要你避免或延迟集成。你一般需要每天集成几次，最好不要2~3天才集成一次。</p>
<p>  当早期就进行集成的时候，你会看到子系统之间的交互和影响，你就可以估算它们之间通信和共享的信息数据。你越早弄清楚这些问题，越早解决它们，工作量就越小。就好比是，刚开始有3个开发者，开发着5万行的代码，后来是5000个开发者进行3000万行代码的开发。相反，如果你推迟集成的时间，解决这些问题就会变得很难，需要大量和大范围地修改代码，会造成项目延期和一片混乱。</p>
<blockquote>
<p><strong>提早集成，频繁集成。代码集成是主要的风险来源。要想规避这个风险，只有提早集成，持续而有规律地进行集成。</strong></p>
</blockquote>
<p>  切身感受</p>
<p>  如果你真正做对了，集成就不再会是一个繁重的任务。它只是编写代码周期中的一部分。集成时产生的问题，都会是小问题并且容易解决。</p>
<p>  平衡的艺术</p>
<ul>
<li><p>成功的集成就意味着所有的单元测试不停地通过。正如医学界希波克拉底的誓言：首先，不要造成伤害。</p>
</li>
<li><p>通常，每天要和团队其他的成员一起集成代码好几次，比如平均每天5~10次，甚至更多。但如果你每次修改一行代码就集成一次，那效用肯定会缩水。如果你发现自己的大部分时间都在集成，而不是写代码，那你一定是集成得过于频繁了。</p>
</li>
<li><p>如果你集成得不够频繁（比如，你一天集成一次，一周一次，甚至更糟），也许就会发现整天在解决代码集成带来的问题，而不是在专心写代码。如果你集成的问题很大，那一定是做得不够频繁。</p>
</li>
<li><p>对那些原型和实验代码，也许你想要独立开发，而不要想在集成上浪费时间。但是不能独立开发太长的时间。一旦你有了经验，就要快速地开始集成。</p>
</li>
</ul>
<h4 id="15-提早实现自动化部署"><a href="#15-提早实现自动化部署" class="headerlink" title="15 提早实现自动化部署"></a>15 提早实现自动化部署</h4><blockquote>
<p>“没问题，可以手工安装产品，尤其是给质量保证人员安装。而且你不需要经常自己动手，他们都很擅长复制需要的所有文件。”</p>
</blockquote>
<p>  系统能在你的机器上运行，或者能在开发者和测试人员的机器上运行，当然很好。但是，它同时也需要能够部署在用户的机器上。如果系统能运行在开发服务器上，那很好，但是它同时也要运行在生产环境中。</p>
<p>  这就意味着，你要能用一种可重复和可靠的方式，在目标机器上部署你的应用。不幸的是，大部分开发者只会在项目的尾期才开始考虑部署问题。结果经常出现部署失败，要么是少了依赖的组件，要么是少了一些图片，要么就是目录结构有误。</p>
<p>  如果开发者改变了应用的目录结构，或者是在不同的应用之间创建和共享图片目录，很可能会导致安装过程失败。当这些变化在人们印象中还很深的时候，你可以快速地找到各种问题。但是几周或者几个月之后查找它们，特别是在给客户演示的时候，可就不是一件闹着玩的事情了。</p>
<p>  如果现在你还是手工帮助质量保证人员安装应用，花一些时间，考虑如何将安装过程自动化。这样，只要用户需要，你就可以随时为他们安装系统。要提早实现它，这样让质量保证团队既可以测试应用，又可以测试安装过程。如果还是手工安装应用，那么最后把应用部署到生产环境时会发生什么呢？就算公司给你加班费，你也不愿意为不同用户的机器或不同地点的服务器上一遍又一遍地安装应用。</p>
<p>  有了自动化部署系统后，在项目开发的整个过程中，会更容易适应互相依赖的变化。很可能你在安装系统的时候，会忘记添加需要的库或组件——在任意一台机器上运行自动化安装程序，你很快就会知道什么丢失了。如果因为缺少了一些组件或者库不兼容而导致安装失败，这些问题会很快浮现出来。</p>
<blockquote>
<p>Andy如是说……</p>
<p>从第一天起就开始交付</p>
<p>一开始就进行全面部署，而不是等到项目的后期，这会有很多好处。事实上，有些项目在正式开发之前，就设置好了所有的安装环境。</p>
<p>在我们公司，要求大家为预期客户实现一个简单的功能演示——验证一个概念的可行性。即使项目还没有正式开始，我们就有了单元测试、持续集成和基于窗口的安装程序。<strong>这样，我们就可以更容易更简单地给用户交付这个演示系统：用户所要做的工作，就是从我们的网站上点击一个链接，然后就可以自己在各种不同的机器上安装这个演示系统了。</strong></p>
<p><strong>在签约之前，就能提供出如此强大的演示，这无疑证明了我们非常专业，具有强大的开发能力。</strong></p>
</blockquote>
<blockquote>
<p><strong>一开始就实现自动化部署应用。使用部署系统安装你的应用，在不同的机器上用不同的配置文件测试依赖的问题。质量保证人员要像测试应用一样测试部署。</strong></p>
</blockquote>
<p>  切身感受</p>
<p>  这些工作都应该是无形的。系统的安装或者部署应该简单、可靠及可重复。一切都很自然。</p>
<p>  平衡的艺术</p>
<ul>
<li><p><strong>一般产品在安装的时候，都需要有相应的软、硬件环境</strong>。比如，Java或Ruby的某个版本、外部数据库或者操作系统。这些环境的不同很可能会导致很多技术支持的电话。所以检查这些依赖关系，也是安装过程的一部分。</p>
</li>
<li><p><strong>在没有询问并征得用户的同意之前，安装程序绝对不能删除用户的数据。</strong></p>
</li>
<li><p><strong>部署一个紧急修复的bug应该很简单，特别是在生产服务器的环境中。你知道这会发生，而且你不想在压力之下，在凌晨3点半，你还在手工部署系统。</strong></p>
</li>
<li><p>用户应该可以安全并且完整地卸载安装程序，特别是在质量保证人员的机器环境中。</p>
</li>
<li><p>如果维护安装脚本变得很困难，那很可能是一个早期警告，预示着——很高的维护成本（或者不好的设计决策）。</p>
</li>
<li><p>如果你打算把持续部署系统和产品CD或者DVD刻录机连接到一起，你就可以自动地为每个构建制作出一个完整且有标签的光盘。任何人想要最新的构建，只要从架子上拿最上面的一张光盘安装即可。</p>
</li>
</ul>
<h4 id="16-使用演示获得频繁反馈"><a href="#16-使用演示获得频繁反馈" class="headerlink" title="16 使用演示获得频繁反馈"></a>16 使用演示获得频繁反馈</h4><blockquote>
<p>“这不是你的过错，问题出在我们的客户——那些麻烦的最终客户和用户身上。他们不停地更改需求，导致我们严重地延期。他们一次就应该想清楚所有想要的东西，然后把这些需求给我们，这样我们才能开发出令他们满意的系统。这才是正确的工作方式。”</p>
</blockquote>
<blockquote>
<p>Andy如是说……</p>
<p>维护项目术语表</p>
<p><strong>不一致的术语是导致需求误解的一个主要原因。企业喜欢用看似普遍浅显的词语来表达非常具体、深刻的意义。</strong></p>
<p><strong>我经常看到这样的事情：团队中的程序员们，使用了和用户或者业务人员不同的术语，最后因为“阻抗失调”导致bug和设计错误。</strong></p>
<p><strong>为了避免这类问题，需维护一份项目术语表。人们应该可以公开访问它，一般是在企业内部网或者Wiki上。这听起来似乎是一件小事情——只是一个术语列表及其定义。但是，它可以帮助你，确保你真正地和用户进行沟通。</strong></p>
<p><strong>在项目的开发过程中，从术语表中为程序结构——类、方法、模型、变量等选择合适的名字，并且要检查和确保这些定义一直符合用户的期望。</strong></p>
</blockquote>
<blockquote>
<p><strong>清晰可见的开发。在开发的时候，要保持应用可见（而且客户心中也要了解）。每隔一周或者两周，邀请所有的客户，给他们演示最新完成的功能，积极获得他们的反馈。</strong></p>
</blockquote>
<p>  切身感受</p>
<p>  项目启动了一段时间之后，你应该进入一种舒适的状态，团队和客户建立了一种健康的富有创造性的关系。<strong>突发事件应极少发生。客户应该能感觉到，他们可以在一定程度上控制项目的方向。</strong></p>
<blockquote>
<p>跟踪问题</p>
<p>随着项目的进展，你会得到很多反馈——修正、建议、变更要求、功能增强、bug修复等。要注意的信息很多。随机的邮件和潦草的告示帖是无法应付的。所以，要有一个跟踪系统记录所有这些日志，可能是用Web界面的系统。更多详情参阅《软件项目成功之道》。</p>
</blockquote>
<p>  平衡的艺术</p>
<ul>
<li><p><strong>当你第一次试图用这种方法和客户一起工作的时候，也许他们被这么多的发布吓到了。所以，要让他们知道，这些都是内部的发布（演示），是为了他们自己的利益，不需要发布给全部的最终用户。</strong></p>
</li>
<li><p><strong>一些客户，也许会觉得没有时间应付每天、每周甚至是每两周的会议。毕竟，他们还有自己的全职工作。</strong></p>
</li>
<li><p><strong>所以要尊重客户的时间。如果客户只可以接受一个月一次会议，那么就定一个月。</strong></p>
</li>
<li><p><strong>一些客户的联络人的全职工作就是参加演示会议。他们巴不得每隔1小时就有一次演示和反馈。你会发现这么频繁的会议很难应付，而且还要开发代码让他们看。缩减次数，只有在你做完一些东西可以给他们演示的时候，大家才碰面。</strong></p>
</li>
<li><p>演示是用来让客户提出反馈的，有助于驾驭项目的方向。<strong>如果缺少功能或者稳定性的时候，不应该拿来演示，那只能让人生气。可以及早说明期望的功能：让客户知道，他们看到的是一个正在开发中的应用，而不是一个最终已经完成的产品。</strong></p>
</li>
</ul>
<h3 id="第5章-敏捷反馈"><a href="#第5章-敏捷反馈" class="headerlink" title="第5章　敏捷反馈"></a>第5章　敏捷反馈</h3><h4 id="19-守护天使"><a href="#19-守护天使" class="headerlink" title="19 守护天使"></a>19 守护天使</h4><p>  单元测试的理由：</p>
<ul>
<li><p><strong>单元测试能及时提供反馈</strong>.你的代码会重复得到锻炼.但若修改或者重写了代码,测试用例就会检查你是否破坏了已有的功能.你可以快速得到反馈,并很容易的修复他们.</p>
</li>
<li><p><strong>单元测试让你的代码更加健壮</strong>.测试帮助你全面思考代码的行为,帮你练习正面和反面以及异常情况.</p>
</li>
<li><p><strong>单元测试是有用的设计工具</strong>.正如我们在实践20中谈论到的,单元测试有助于实现简单的,注重实效的设计.</p>
</li>
<li><p><strong>单元测试是让你自信的后台</strong>.你测试代码,了解它在各种不同条件下的行为.这会让你在面对新的任务,时间紧迫的巨大压力之下,找到自信.</p>
</li>
<li><p><strong>单元测试是解决问题是的探测器</strong>. 单元测试就像是测试印制电路板的示波镜.当问题出现的时候,你可以快速地给代码发送一个脉冲信号.这为你提供了一个很自然的发现和解决问题的方法(见习惯35,第136页).</p>
</li>
<li><p><strong>单元测试是可信的文档</strong>.当你开始学习新API的时候,它的单元测试是最精确的可靠的文档.</p>
</li>
<li><p><strong>单元测试是学习工具</strong>.在你开始学习新API的时候,可以为这个API写个单元测试,从而加深自己的理解.这写学习用的测试,不仅能帮助你理解API的行为,还能保证你快速找到以后可能引入的,无法与现有代码兼容的变化.</p>
</li>
</ul>
<blockquote>
<p><strong>使用自动化的单元测试</strong>.好的单元测试能够为你的代码问题提供及时的警报.如果没有到位的单元测试,不要进行任何设计和代码修改.</p>
</blockquote>
<p>  切身感受</p>
<p>  你依赖与单元测试.如果代码没有测试,你会觉得很不舒服,就像是在高空作业没有系安全带一样.</p>
<p>  <strong>平衡的艺术</strong></p>
<ul>
<li><strong>单元测试是优质股,值得投资.但一些简单的属性访问方法或者价值不大的方法,是不值得花费时间进行测试的.</strong></li>
<li>人们不编写单元测试的很多借口都是因为代码中的设计缺陷.通常,抗议越强烈,就说明越糟糕.</li>
<li><strong>单元测试只有在达到一定测试覆盖率的时候,才能真正地发挥作用.你可以使用一些测试覆盖率工具,大致了解自己的单元测试的翻盖情况.</strong></li>
<li><strong>不测试越多质量就会越高,测试必须要有效.如果测试无法发现任何问题,也许它们就是没有测试对路.</strong></li>
</ul>
<h4 id="20-先用它在来实现它"><a href="#20-先用它在来实现它" class="headerlink" title="20 先用它在来实现它"></a>20 先用它在来实现它</h4><blockquote>
<p>“请进，先完成所有的代码库，后面会有大量时间看到用户是否是如何思考，现在只有把代码仍过去就可以了，我保证它没有问题”</p>
</blockquote>
<p>  很多成功的公司都是靠着“吃自己的狗食”活着。<strong>也就是说，如果要让你的产品尽可能的好，自己先要积极地使用它。</strong></p>
<p>  幸运的是，我们不是在狗食业务，但是，我们的业务是要创造出能调用的API和可以使用的接口，事实上，在你刚做完设计但还没完成后面的实现的时候，应使用它，这个可行吗？</p>
<p>  使用 被称为TDD（Test Driven Development，测试驱动开发的技术，你总是在一个失败的单元测试后才开始编码，测试）失败要么是因为测试方法不存在，要么是因为方法的逻辑不足以让测试通过。</p>
<p>  <strong>先测试，你就会站在代码用户的角度去思考，而不仅仅是一个单纯的实现者，这样就是很大区别，你就会发现以为自己要使用它们，所以能设计一个更有，更一致的接口。</strong></p>
<p>  TDD有机会让你编写的代码之前（或者至少深入到实现之前），可以深思熟虑将如何用它，这会迫使你去思考它的可用性和便利性，并然你的设计更加注重实效。</p>
<p>  <strong>当然，设计不是开始编码的时候就结束了，你需要在它色生命周期中持续地添加测试，添加代码，并重新设计代码（更多信息参考第133也习惯28）。</strong></p>
<blockquote>
<p>先用它在来实现它。将TDD作为设计工具，它会为你带来更简单游实数的设计。</p>
</blockquote>
<p>  切身感受</p>
<p>  这种感受就是，只在有具体理由的时候才开始编码，你可以专注设计接口。而不会被很多实现的细节干扰</p>
<p>  平衡的艺术</p>
<ul>
<li>不要把测试优先和提交代码之前的测试等同起来，测试先行可以帮助你改进设计，但是你还是需要在提交代码之前做的测试。</li>
<li>任何一个设计都可以被改进。</li>
<li><strong>你在验证一个想法或者设计一个原型的时候，单元测试也许不适合，但是。万一这些代码不幸仓促演变成一个真正的系统，就必须要为他们添加测试（但是最后重新开始设计系统）。</strong></li>
<li><strong>单纯的单元测试无法保证好的设计，但它们会对设计有帮助，会然设计更加简单。</strong></li>
</ul>
<h4 id="21-不同环境，就有不同问题"><a href="#21-不同环境，就有不同问题" class="headerlink" title="21 不同环境，就有不同问题"></a>21 不同环境，就有不同问题</h4><blockquote>
<p>“只要代码能在你的机器上运行就可以了，谁会去关心她是否可以在其他平台上工作，你又不用其他平台。”</p>
</blockquote>
<p>  如果厂商或者同事说了这样的套话：“哦，那不会有什么不同。”你可以打赌，他们错了，只要环境不同，就很可能会有不同的问题。</p>
<p>  Ventkat真正在项目中学到了这一课，他的一个同事抱怨说mVenkat的代码失败了。但奇怪的是，问题在于，这于再Venkat机器上通过的一个测试一模一样。实际上，它在一台机器上可以运行，在另一台机器上就不工作。</p>
<p>  最后，他们终于找到罪魁祸首：一个NET环境下的API在Windows XP 和Window3002上的行为不同。平台的不同，造成了结果不一样。</p>
<p>  他们算是幸运的，能够偶然发现这个问题，否则，很可能在产品投入使用的时候才会发现。如果很晚才发现这个问题，成本会非常昂贵———现象一下产品发表之后，才发现他并不支持应该支持的平台，那会怎么样。</p>
<p>  也许，你会要求测试团队在所有支持的平台上进行测试，如果他们的手工精细测试，可能并不是最可靠的测试办法，我们需要根据面向开发者的测试办法。</p>
<p>  你已经编写了单元测试，测试你的代码，每次在修改或者重构代码的时候在提交代码之前，你会运行测试办法，那么现在所要做的就是各种支持的平台和环境运行这些测试用例。</p>
<p>  如果你的应用程序在不同操作系统上运行（例如 MacOs，Linux，Windows等），或者一个操作系统的不同版本（例如：Windows 2000，Windows XP ，Windows 2003 等）你需要测试所有的操作系统。如果你的应用程序要在不同的版本的Java虚拟机或者不同的NET CLR中运行，你也需要测试他们。</p>
<p>  <strong>但是，也许你已经有时间压力了，因此，你怎么可能哟时间在多个平台上运行测试呢？这就要靠持续集成来拯救了。</strong></p>
<p>  <strong>我们在前面的保持可以发布中学过，用一个持续集成工具，周期性的从源代码控制系统中取得代码，并运行代码，如果有任何测试失败了，它会通知相关的开发者，通知方式可能是电子邮件，页面，RSS Feed，或者其他一些新颖的方式！</strong></p>
<p>  要在多个平台上测试，你只要为每个平台设置持续集成系统就行了，但你或者同事提交代码，测试会在每个平台上自动运行，这样，提交代码之后的几分钟，你就可以知道它是否可以在不同的平台上运行！这是多么英明的办法呀！</p>
<p>  构建机器的硬件成本相当于开发人员的几个小时而已。如果需要，你甚至可以是用VMware或Virtual PC这样的虚拟机产品，在一台机器上运行不同版本的操作系统 ，VM或CLR。</p>
<blockquote>
<p><strong>不同环境有不同问题。使用持续集成工具，在每一种支持的平台和环境中运行单元测试，要积极地寻找问题，而不是等问题来找你。</strong></p>
</blockquote>
<p>  切身感受</p>
<p>  感觉就像是单元测试，非但如此，而且还是跨越不同的世界的单元测试。</p>
<p>  平衡的艺术</p>
<ul>
<li>硬件比开发人员的时间更便宜，但如果你有很配置，要支持大量的平台，可以选择哪些平台需要内部测试。</li>
<li>只因为不同的栈层顺序,不同的单词大小写但而过，就能发现很多的平台上的bug。因此，即使运行 Solaris的客户比用Linux的少的很多，你仍然要在两个系统上进行测试</li>
<li>你不希望因为一个错误而收到5次通过轰炸（这就像双重征税，会导致电子游戏疲劳症）。可以设置一个主构建平台或者配置，降低其他的构建服务器的运行频率，这样在它失败的时候，你就哟足够多的时间来修复构建平台，或者汇总所以错误报告信息到一个地方，进行统一处理。</li>
</ul>
<h4 id="22-自动验收测试"><a href="#22-自动验收测试" class="headerlink" title="22 自动验收测试"></a>22 自动验收测试</h4><blockquote>
<p>“很好，你现在用单元测试来验证代码是否完成了你期望的行为，发给客户吧。我们很快会知道这是否算是用户期望的功能。”</p>
</blockquote>
<p>  你于用户一起工作，开发他们想要的功能，但现在，你要能确保他们得到的数据库是正确的，至少在用户看来它是正确的。</p>
<p>  几年前，Andy做了一个项目，在项目中，他们的行业标准规定凌晨12:00点式一天的最后一分钟，在12:01是一天的最早一分钟（一般情况下，商业计算机系统任务凌晨11:59是一天的最后一分钟，12:00是一天的最早的一分钟）在验收测试的时候这个很小的细节导致一个严重的问题——无法进行正确的合计。</p>
<p>  <strong>关键业务逻辑必须要独立精细严格的测试，并且最后需要通过用户的审批。</strong></p>
<p>  但你也不可能拉这用户，逐一检查每个单元测试运行结果。实际上你需要能自动比较用户期望和实际完成的工作。</p>
<p>  有一个办法是可以是验收测试不同于单元测试你应该让用户在不必学习编码的情况下，根据自己的需要进行添加，更新和修改数据，你有很多方法来实现它。</p>
<p>  Andy使用了一下架构，把测试数据放到一个页面文件中并且用户可以直接修改这些实际。Venkat实现Excel做过类似的事情，根据环境的不同，也可以找出一种能然偶那个号自然接收的方法（数据可以在页面的文件Excel 文件，数据库中）。或者可以考虑选择一个现成的测试工具，它们会会你完成很多功能。</p>
<p>  FIT，即集成测试框架，它很实用，可以更容易的使用HTML表格定义的测试用例，并比较测试结果的数据。</p>
<p>  使用FIT，客户可以定义带有新功能的使用样本，客户，测试人员和开发人员（根据样本）都可以成绩表格，为代码描述可能的输入和输出值，开发人员会参照带有正开发的代码结果在FIT表格中的样本编写测试代码，测试结果成功或者失败都会显示在HTML教程页面中，用户可以很方便的查阅。</p>
<p>  如果领域专家提供了业务的算法，运算后者方程式，为他们实现一套可以独立运行的测试（参考第136页习惯35）。要让这些测试都成为测试套件的一部分，你会在项目生命周期保持实现为他们提供正确的答案。</p>
<blockquote>
<p><strong>为刻心的业务逻辑创建测试。让你的客户单独验证这些测试，要让他们像一般的测试一样可以自动运行。</strong></p>
</blockquote>
<p>  切身感受</p>
<p>  它像是协作完成的单元测试：你仍然是在编写测试，但从其他人那里获取答案。</p>
<p>  平衡的艺术</p>
<ul>
<li>不是所有客户都恩能够给你提供正确的数据，如果他们已经有了正确的数据，就根本不需要新的系统了。</li>
<li>你也许会在旧系统（运行时电脑系统，也是是人工系统）中发现一起根本不知道的bug，或者一起不存在的真正的问题</li>
<li><strong>使用客户的业务逻辑，但是不要陷于无边无际的文档写作之中。</strong>.</li>
</ul>
<h4 id="23-度量真实的进度"><a href="#23-度量真实的进度" class="headerlink" title="23 度量真实的进度"></a>23 度量真实的进度</h4><blockquote>
<p>“用自己的时间表报告工作进度，我们会用它做项目计划，不用管那些时间的工作时间，每周填满40小时就可以了。”</p>
</blockquote>
<p>  <strong>时间的消逝（通常很快）可以证明：判断工作进度最后是看实际花费的时间而不是估计的时间。</strong></p>
<p>  <strong>哦，你说早已经用时间进行了追踪。不幸的是，几乎所有公司的时间表都是会工资会计准备的，不是用度量软件项目的开发进度的。</strong>例如：如果你工作了60个小时，也许你的老板会让你在时间表上只填写40个小时，这是公司会计想到的，所以，时间表很难真实的反映工作完成的状况，因此它不可以用来进行羡慕计划,评估或表现评估。</p>
<p>  即使没有时间表，一下开发人员还是很难面对现实了解自己的真实进度，你曾经听到开发人员报告一个任务完成了80%吗？然而过了一天又一天，一周又周，那个任务仍然是完成了80%？随意用一个比率进行度量是没有意义的，这就好比说80%是对的（除非你是政客，否则对和错应该是布尔条件）。所以，<strong>我们不应该去计算工作完成的百分比，而应该测试还剩下多少工作量没有完成。如果你最初估计这个任务需要40个小时，在开发35个小时之后，你认为你还需要另外30个小时的工作。那就得到了最重要的度量结果（这里诚实非常重要，隐瞒真相毫无意义）。</strong></p>
<p>  <strong>在你最后真正完成一项任务时，要清楚知道完成这个任务真正花费的时间。奇怪的是，它花费的时间很有可能要比最初估计时间长。没有关系，我们希望这能作为下一次的参考，在为下一个任务估计工作量时，可以根据这次经验调整评估，如果你低估了一个任务，评估师2天，它最后花费了6天，那么系数就是3。除非是异常情况，否则你应该对下一次估计乘以系数3。你的评估会波动一段时间，有时候过低估计，有时候会过高估计。但随着时间的推移，你的评估会于事实接进近，你也会对任务所花费的时间更清楚地认识。</strong></p>
<p>  <strong>如果能一直让下一步工作是可见的，会助于进度度量。组合的做法就是使用待办事项（backlog）。</strong></p>
<p>  待办事项就是等待完成的任务列表，当一个任务被完成了，它就会在列表中移动（逻辑上的，而物理上就是把它冲列表中划掉或者标识它是完成的状态）。当添加新新任务的时候，先排列他们的优先级，然后加入到待办事项中。你也可以由各人的待办事项,当前迭代的待办事项或者整个项目的待办事项。</p>
<p>  <strong>通过代办事项，就可以随时知道下一步最重要的任务是什么。同事你的评估技巧也在不停的改进，你也会越来越清楚完成一些任务的花费的时间。</strong></p>
<p>  清楚项目的真实进度，是一项强大的技术。</p>
<blockquote>
<p><strong>度量剩下的工作量。不要用不恰当的度量来欺骗自己或者团队，要评估那些需要完成的待办事项。，要让他们像一般的测试一样可以自动运行。</strong></p>
</blockquote>
<p>  切身感受</p>
<p>  <strong>你会觉得很舒服，因为你很清楚哪些任务已经完成，哪些是还没有完成，以及他们的优先级。</strong></p>
<p>  平衡的艺术</p>
<ul>
<li><strong>6分钟作为一个时间单位，它的粒度实在是太细了，这不是敏捷的做法。</strong></li>
<li><strong>一周或者一个月的时间单元，它的粒度太粗了，这不是敏捷的做法。</strong></li>
<li><strong>关注功能，而不是日程表。</strong></li>
<li>如果你在一个项目中花费了很多时间来了解你所花费的时间，而没有足够的时间进行工作，那么你在了解你所花费的时间上花费的时间久太多了，听懂了吗。</li>
<li><strong>一周工作40个小时，不是说你就有40个小时的编码时间，你需要减少去会议,电话,电子邮件以其他相关活动的时间。</strong></li>
</ul>
<h4 id="24-倾听用户的声音"><a href="#24-倾听用户的声音" class="headerlink" title="24 倾听用户的声音"></a>24 倾听用户的声音</h4><blockquote>
<p>“用户就是会抱怨，这不是你的过错，是用户太愚蠢了，连使用手册都看不懂。它不是bug，只是用户不明白如何使用而已，他们本应该知道更多”。</p>
</blockquote>
<p>  Andy曾经在一家大公司工作过，为高端的Unix工作站开发产品。在这个环境中，你不是简单的运行setup.exe文件或者pkgadd命令，就可以完成软件的安装。你必须在工作站上复制文件并调整各种设置。</p>
<p>  Andy和他的团队成员们觉得一切工作的很顺利。直到一天，Andy走过几十支持部门的工作间，听到一个技术支持工程师对着电话大笑：“哦，这不是bug，你只是犯了一个每个人都会犯得错误。”并且，不只是这一个工程师，整个部门都在嘲笑这些可怜,天真和愚蠢的客户。</p>
<p>  倒霉的客户必须要配置那些包含以下魔法数字的模糊系统文件，否则系统根本运行不起来。系统即没有错误提示消息，也不会破溃,只是显示大黑屏和一个斗大的“退出”按钮。事实上，安装说明书中有一行提到了这样的问题，但显然80%的用户忽略了这个信息,因此只能求助公司的技术支持部门,并遭到他们的嘲笑.</p>
<p>  正如我们在第128页第7章中所说,当出了错误,你要尽可能地提供详细信息.黑屏和含义不明的”退出”按钮是很不友好的行为.更糟糕的是,在得到用户反馈的时候,还嘲笑用户愚蠢,而不去真正地解决问题.</p>
<p>  <strong>不管它是否是产品的bug,还是文档的bug,或者是对用户社区理解的bug,它都是团队的问题.而不是用户的问题.</strong></p>
<p>  下面是一个案例是:一个昂贵的专业车间的控制系统,没有任何一个用户会使用.因为,使用系统的第一步是要输入用户名和密码,进行登录.但这个车间的大部分工人都是文盲,没有人去问过他们,也没有去收集他们的反馈.就这样,为用户安装了一个无用的系统.最后,花费巨大的费用,开发人员重新开发了一个基于图片的使用界面.</p>
<p>  <strong>我们花费了很大的精力从单元测试之类的代码中获得反馈,但却容易忽略最终用户的反馈.你不仅需要和真实用户(不是他们的经理,也不是业务分析师之类的代理人)进行交谈,还分需要耐心地倾听.</strong></p>
<p>  即使他们说的内容很傻!</p>
<blockquote>
<p><strong>每一个抱怨的背后都隐藏了一个事实.找出真相,修复真正的问题.</strong></p>
</blockquote>
<p>  切身感受</p>
<p>  对客户的那些愚蠢抱怨,你既不会生气,也不会轻视,你会查看一下,找出背后真正的问题.</p>
<p>  平衡的艺术:</p>
<ul>
<li><strong>没有愚蠢的用户.</strong></li>
<li><strong>只有愚蠢,自大的开发人员.</strong></li>
<li><strong>“它就是这样的.”这不是一个好的答案.</strong></li>
<li><strong>如果代码问题解决不了,也许可以考虑通过修改文档或者培训来弥补.</strong></li>
<li><strong>你的用户有可能会阅读所有的文档,记住其中的所有内容.但也可能不会.</strong></li>
</ul>
<h3 id="第6章-敏捷编码"><a href="#第6章-敏捷编码" class="headerlink" title="第6章　敏捷编码"></a>第6章　敏捷编码</h3><h3 id="第7章-敏捷调试"><a href="#第7章-敏捷调试" class="headerlink" title="第7章　敏捷调试"></a>第7章　敏捷调试</h3><h3 id="第8章-敏捷协作"><a href="#第8章-敏捷协作" class="headerlink" title="第8章　敏捷协作"></a>第8章　敏捷协作</h3><h4 id="38-定期安排会面时间"><a href="#38-定期安排会面时间" class="headerlink" title="38 定期安排会面时间"></a>38 定期安排会面时间</h4><blockquote>
<p>会议安排得越多越好。实际上，我们要安排更多的会议，直到发现为什么工作总是完不成。”</p>
</blockquote>
<p>  也许你个人很讨厌开会，但是沟通是项目成功的关键。我们不只要跟客户谈话，还应该与其他开发人员进行良好的沟通。</p>
<p>  <strong>立会（站着开的会议）是将团队召集在一起，并让每个人了解当下进展状况的好办法。顾名思义，参与者们不允许在立会中就做，这可以保证会议快速进行。一个人坐下来之后，会由于感到舒适而让会议持续更长的时间。</strong></p>
<p>  要保证会议议题不会发散，每个人都应该只回答下述三个问题：</p>
<ul>
<li><p><strong>昨天有什么收获？</strong></p>
</li>
<li><p><strong>今天计划要做哪些工作？</strong></p>
</li>
<li><p><strong>面临着哪些障碍？</strong></p>
</li>
<li><p>*只能给予每个参与者很少的发言时间（大约2分钟）<strong>。</strong>也许要用计时器来帮助某些收不住话头的人**。如果要详细讨论某些问题，可以在立会结束之后，再召集相关人员。</p>
</li>
<li><p><em>通常，立会都是在每个工作日的早些时候，且大家都在上班时举行。但是不要把它安排为上班后的第一件事。要让大家有机会从刚才混乱的交通状况中回复状态，喝点咖啡，删除一些垃圾邮件什么的。要保证会议结束后又足够的时间，让大家在午餐之前做不少工作，同时也不要开始得过早，让每个人巴不得赶紧结束会议，去喝点东西。一般来说，在大家到公司之后的半个小时到一个小时之内举行，是个不错的选择。</em>*</p>
</li>
</ul>
<blockquote>
<p>猪与鸡</p>
<p>Scrum将团队成员与非团队成员这两种角色命名为猪和鸡。团队成员是猪（自尊何在啊）非团队成员（管理层、支持人员、QA等）是鸡。这两个用语来自一个寓言，讲的是农场里的动物们打算一起开饭店，并且准备用意肉和鸡蛋作为早餐提供。对于鸡来说，当然是要参与进来了，可对于猪来讲，可就是放血投入了。</p>
<p>只有“猪”才允许参与 Scrum的每日立会。</p>
</blockquote>
<p>  参加会议的人要遵守一些规则，以保证彼此不会分神，而且会议也不会跑题。<strong>这些规则有：只有团队成员一一开发人员、产品所有者和协调者可以发言（查看上面对“猪”和“鸡”的描述）。他们必须回答上面的3个问题，而且不能展开深入讨论（讨论可以安排在会后进行）。管理层可以把要解决的问题记下来，但是不能试图将会议从每个人要回答的三个问题引开。</strong></p>
<p>  每日立会有诸多好处。</p>
<ul>
<li><strong>让大家尽快投入到一天的工作中来。</strong></li>
<li><strong>如果某个开发人员在某一点上有问题，他可以趁此机会将问题公开，并积极寻求帮助。</strong></li>
<li><strong>帮助团队带头人或管理层了解哪些领域需要更多的帮助，并重新分配人手。</strong></li>
<li><strong>让团队成员知道项目其他部分的进展情况。</strong></li>
<li><strong>帮助团队识别是否在某些东西上有重复劳动而耗费了精力，或者是不是某个问题有人已有现成的解决方案。</strong></li>
<li><strong>通过促进代码和思路的共享，来提升开发速度。</strong></li>
<li><strong>鼓励向前的动力：看到别人报告的进度都在前进，会对彼此形成激励。</strong></li>
</ul>
<blockquote>
<p>使用厨房计时器</p>
<p>开发者 Nancy Davis告诉我们她使用厨房计时器召开立会的经验</p>
<p>“我们使用了妹妹去年圣诞节送给我的一个厨房计时器。它在运行时不会发出嘀哒”的声音，只会在时间到达后发出“可的一声。如果计时器停止了，我们就再加两分钟，并让下一个成员发言。有时会忘掉计时器的存在，并让会议持续需要的时间，但是大部分情况下，我们都会遵守计时器的提醒。”</p>
</blockquote>
<p>  采取立会的形式需要管理层的承诺和参与。不过，团队中的开发人员可以帮助推行这个实践。如果开发人员无法说服管理层的参与，他们自己可以用非正式的形式召开立会。</p>
<blockquote>
<p>使用立会。立会可以让团队达成共识。保证会议短小精悍不跑题。</p>
</blockquote>
<p>  切身感受</p>
<p>  <strong>大家都盼望着立会。希望彼此了解各自的进度和手上的工作，而且不怕把各自遇到的问题拿出来公开讨论。</strong></p>
<p>  平衡的艺术</p>
<ul>
<li><strong>会议会占用开发时间，所以要尽量保证投入的时间有较大的产出。立会的时间最长不能超过30分钟，10~15分钟比较理想。</strong></li>
<li><strong>如果要使用需提前预定的会议室，就把预定的时间设定为1小时吧。这样就有机会在15分钟的立会结束后，马上召开更小规模的会议。</strong></li>
<li><strong>虽然大多数团队需要每天都碰头，但对于小型团队来说，这样做可能有点过头了。不妨两天举行一次，或者一周两次，这对小团队来说足够了。</strong></li>
<li><strong>要注意报告的细节。在会议中要给出具体的进度，但是不要陷入细节之中。</strong></li>
<li><strong>迅速地开始可以保证会议短小。不要浪费时间等着会议开始。</strong></li>
<li><strong>如果觉得立会是在浪费时间，那可能是大家还没有形成真正的团队意识。这并不是坏事，有利于针对问题进行改进。</strong></li>
</ul>
<h4 id="39-架构师必须写代码"><a href="#39-架构师必须写代码" class="headerlink" title="39 架构师必须写代码"></a>39 架构师必须写代码</h4><blockquote>
<p>我们的专家级架构师Fred会提供设计好的架构，供你编写代码。他经验丰富，拿的薪水很高，所以不要用一些愚蠢的问题或者实现上的难点来浪费他的时间。”</p>
</blockquote>
<p>  软件开发业界中有许多挂着架构师称号的人。作为作者的我们不喜欢这个称号，为什么呢？架构不了能在weri片中进行偏师应该负责设计和指导，但是许多名片上印着“架You cant code in Powerpoint构师”的人配不上这个称号。<strong>作为架构师，不应该只是画一些看起来很漂亮的设计图，说一些像“黑话”一样的词汇，使用一大堆设计模式一一这样的设计通常不会有效的。</strong></p>
<p>  <strong>一个设计要解决的是眼前面临的特定问题，随着设计的实现，对问题的理解也会发生改变。想在开始实现之前，就做出一个很有效的详细设计是非常困难的（见第48页习惯11）</strong>。因为没有足够的上下文，能得到的反馈也很少，甚至没有。设计会随着时间而演进，如果忽略了应用的现状（它的具体实现），要想设计一个新的功能，或者完成某个功能的提开是不可能的。</p>
<p>  <strong>作为设计人员，如果不能理解系统的具体细节，就不可能做出有效的设计。只通过一些高度高阔的、粗略的设计图无法很好地理解系统。</strong></p>
<p>  这就像是尝试仅仅通过查看地图来指挥一场战役旦开打，仅有计划是不的。战略上的决策也许可以在后方进行，但是战术决策一一影响成败的决策需要对战场状况的明确了解</p>
<blockquote>
<p>可逆性</p>
<p>不存在所谓的最终决策。没有哪个决策做出之后就是板上钉钉了。实际上，就时间性来看，不妨把每个重要的决策，都看作是在变化之前所做出的预先规划。</p>
</blockquote>
<blockquote>
<p>新系统的设计者</p>
<p><strong>新系统的设计者必须要亲自投入到实现中去。</strong></p>
<p align="right">——Donald E Knuth</p>
</blockquote>
<p>  正像 Knuth说的，<strong>好的设计者必须能够卷起袖子，加入开发队伍，毫不犹豫地参与实际编程</strong>。真正的架构师，如果不允许参与编码的话，他们会提出强烈的抗议。有一句泰米尔谚语说：“只有一张蔬菜图无法做出好的咖理菜。”与之类似，纸上的设计也无法产生优秀的应用。应该根据设计开发出原型，经过测试，当然还有验证一它是要演化的。实现可用的设计，这是设计者或者说架构师的责任。</p>
<p>  Martin Fowler在题为“ Who Needs an Architect？”e的文章中提到：一个真正的架构师“…应该指导开发团队，提升他们的水平，以解决更为复杂的问题”</p>
<p>  他接着说：“我认为架构师最重要的任务是：通过找到移除软件设计不可逆性的方式，从而去除所谓架构的概念。”增强可逆性是注重实效的软件实现方式的关键构成部分。</p>
<p>  <strong>要鼓励程序员参与设计。主力程序员应该试着担任架构师的角色，而且可以从事多种不同的角色。他会负责解决设计上的问题，同时也不会放弃编码的工作。如果开发人员不愿意承担设计的责任，要给他们配备一个有良好设计能力的人。程序员在拒绝设计的同时，也就放弃了思考。</strong></p>
<blockquote>
<p><strong>优秀的设计从积极的程序员那里开始演化。积极的编程可以带来深入的理解。不要使用不愿意编程的架构师一一不知道系统的真实情况，是无法展开设计的。</strong></p>
</blockquote>
<p>  切身感受</p>
<p>  <strong>架构、设计、编码和测试，这些工作给人的感觉就像是同一个活动一一开发的不同方面。感觉它们彼此之间应该是不可分割的。</strong></p>
<p>  平衡的艺术</p>
<ul>
<li><strong>如果有一位首席架构师，他可能没有足够的时间来参与编码工作。还是要让他参与，但是别让他开发在项目关键路径上的、工作量最大的代码。</strong></li>
<li><strong>不要允许任何人单独进行设计，特别是你自己。</strong></li>
</ul>
<h4 id="40-实行代码集体所有制"><a href="#40-实行代码集体所有制" class="headerlink" title="40 实行代码集体所有制"></a>40 实行代码集体所有制</h4><blockquote>
<p>“不用担心那个烦人的bug，Joe下周假期结東回来后会把它解决掉的在此之前先想个权宜之计应付一下吧。”</p>
</blockquote>
<p>  任何具备一定规模的应用，都需要多人协作进行开发。在这种状况下，不应该像国家宣称对领土的所有权一样，声明个人对代码的所有权。任何一位团队成员，只要理解某段代码的来龙去脉，就应该可以对其进行处理。<strong>如果某一段代码只有一位开发人员能够处理，项目的风险无形中也就增加了。</strong></p>
<p>  相比找出谁的主意最好、谁的代码实现很烂而言，解决问题，并让应用满足用户的期望要更为重要。</p>
<p>  当多人同时开发时，代码会被频繁地检查、重构以及维护。如果需要修复bug，任何一名开发人员都可以完成这项工作。<strong>同时有两个或两个以上的人，可以处理应用中不同部分的代码，可以让项目的日程安排也变得更为容易。</strong></p>
<p>  <strong>在团队中实行任务轮换制，让每个成员都可以接触到不同部分的代码，可以提升团队整体的知识和专业技能</strong>。当Joe接过Sally的代码，他可以对其进行重构，消除待处理的问题。在试图理解代码的时候，他会问些有用的问题，今早开始对问题领域的深入理解。</p>
<p>  <strong>另一方面，知道别人将会接过自己的代码，就意味着自己要更守规矩。当知道别人在注意时，一定会更加小心。</strong></p>
<p>  <strong>可能有人会说，如果一个开发者专门应对某一领域中的任务，他就可以精通该领域，并让后续的开发任务更加高效。这没错，但是眼光放长远一点，有好几双眼睛盯着某一段代码，是一定可以带来好处的。这样可以提升代码的整体质量，使其易于维护和理解，并降低出错率。</strong></p>
<blockquote>
<p>要强调代码的集体所有制。让开发人员轮换完成系统不同领域中不同模块的不同任务</p>
</blockquote>
<p>  切身感受</p>
<p>  项目中绝大部分的代码都可以轻松应对。</p>
<p>  平衡的艺术</p>
<ul>
<li><strong>不要无意间丧失了团队的专家技能。如果某个开发人员在某个领域中机器精通，不妨让他作为这方面的驻留专家，而且系统的其他部分代码也对他开放，这样对团队和项目都很有帮助。</strong></li>
<li><strong>在大型项目中，如果每个人都可以随意改变任何代码，一定会把项目弄得一团糟。代码集体所有制并不意味着可以随心所欲、到处破坏。</strong></li>
<li><strong>开发人员不必了解项目每一部分的每个细节，但是也不能因为要处理某个模块的代码而感到惊恐。</strong></li>
<li><strong>有些场合是不能采用代码集体所有制的。也许代码需要某些特定的知识、对特定领域的了解，比如一个高难度的实时控制系统。这些时候，人多了反而容易误事。</strong></li>
<li><strong>任何人都可能遭遇到诸如车祸等突发的灾难事故，或者有可能被竞争对手雇佣。如果不向整个团队分享知识，反而增加了丧失知识的风险。</strong></li>
</ul>
<h4 id="41-成为指导者"><a href="#41-成为指导者" class="headerlink" title="41 成为指导者"></a>41 成为指导者</h4><blockquote>
<p>“你花费了大量的时间和精力，オ达到目前的水平。对别人要有所保留这样让你看起来更有水平。让队友对你超群的技能感到恐惧吧。”</p>
</blockquote>
<p>  我们有时会发现自己在某些方面，比其他团队成员知道得更多。那要怎么对待这种新发现的“权威地位”呢？当然，用它来质疑别人，取笑他人做出的决策和 knowledge grows when given开发的代码一一有些人就是这样做的。不过，我们可以共享自己的知识，让身边的人变得更好</p>
<blockquote>
<p>好的想法不会因为被许多人了解而削弱。当我听到你的主意时，我得到了知识，你的主意也还是很棒。同样的道理，如果你用你的蜡烛点燃了我的，我在得到光明的同时，也没有让你的周围变暗。好主意就像火。可以引领这个世界，同时不削弱自己。</p>
</blockquote>
<p>  <strong>与团队其他人一起共事是很好的学习机会。知识有一些很独特的属性；假设你给别人钱的话，最后你的钱会变少，而他们的财富会增多。但如果是去教育别人，那双方都可以得到更多的知识。</strong></p>
<p>  <strong>通过详细解释自己知道的东西，可以使自己的理解更深入。当别人提出问题时，也可以发现不同的角度。也许可以发现一些新技巧——听到一个声音这样告诉自己：“我以前还没有这样思考过这个问题。”</strong></p>
<p>  <strong>与别人共事，激励他们变得更出色，同时可以提升团队的整体实力。遇到无法回答的问题时，说明这个领域的知识还不够完善，需要在这方面进一步增强。好的指导者在为他人提供建议时会做笔记。如果遇到需要花时间进一步观察和思考的问题，不妨先草草记录下来。此后将这些笔记加入到每日日志中。</strong></p>
<p>  成为指导者，并不意味着要手把手教团队成员怎么做，也不是说要在白板前进行讲座，或是开展小测验说明的，可以在进行自备午餐会时展开讨论。多数时候，成为指导者，是指在帮助团队成员提升水平的同时也提高自己。</p>
<p>  这个过程不必局限于自己的团队。可以开设个人博客，贴一些代码和技术在上面。不一定是多么伟大的项目，即使是一小段代码和解释，对别人也可能是有帮助的。</p>
<p>  成为指导者意味着要分享——而不是固守——自己的知识、经验和体会。意味着要对别人的所学和工作感兴趣，同时愿意为团队增加价值。一切都是为了提高队友和你的能力与水平，而不是为了毁掉团队。</p>
<p>  然而，努力爬到高处，再以蔑视的眼神轻视其他人，这似乎是人类本性。也许在没有意识到的情况下，沟通的障碍就已经建立起来了。团队中的其他人可能出于畏惧或尴尬，而不愿提出问题，这样就无法完成知识的交换了。这类团队中的专家，就像是拥有无数金银财宝的有钱人，却因健康原因无福享受。<strong>我们要成为指导别人的人，而不是折磨别人的人。</strong></p>
<blockquote>
<p>成为指导者。分享自己的知识很有趣一一付出的同时便有收获。还可以激励别人获得更好的成果，而且提升了整个团队的实力。</p>
</blockquote>
<p>  切身感受</p>
<p>  <strong>你会感到给予别人教导，也是提升自己学识的一种方式，并且其他人亦开始相信你可以帮助他们。</strong></p>
<p>  平衡的艺术</p>
<ul>
<li><strong>如果一直在就同一个主题向不通过的人反复阐述，不妨记录笔记，此后就此主题写一篇文章，甚至是一本书。</strong></li>
<li><strong>成为指导者是向团队进行投资的一种极佳的方式。</strong></li>
<li><strong>结对编程是一种进行高效指导的、很自然的环境。</strong></li>
<li><strong>如果总是被一些懒于自己寻找答案的人打扰。为团队成员在寻求帮助之前陷入某个问题的时间设定一个时限，一个小时应该是不错的选择。</strong></li>
</ul>
<h4 id="42-允许大家自己想办法"><a href="#42-允许大家自己想办法" class="headerlink" title="42 允许大家自己想办法"></a>42 允许大家自己想办法</h4><p>  “授人以鱼，三餐之需；授人以渔，终生之用。”告诉团队成员解决问题的方法，页要让他们知道如何解决问题的思路，这也是成为指导者的一部分。</p>
<p>  了解上个实践一一成为指导者一一之后，也许有人会倾向于直接给同事一个答案，以继续完成工作任务。要是只提供一些指引给他们，让他们自己想办法找到答案，又会如何？</p>
<p>  这并不是多么麻烦的事情；不要直接给出像“42”这样的答案，应该问你的队友“你有没有査看在事务管理者与应用的锁处理程序之间的交互关系？”</p>
<p>  这样做有下面几点好处：</p>
<ul>
<li><p>你在帮助他们学会如何解决问题。</p>
</li>
<li><p>除了答案之外，他们可以学到更多东西。</p>
</li>
<li><p><strong>他们不会再就类似的问题反复问你。</strong></p>
</li>
<li><p>这样做，可以帮助他们在你不能回答问题时自己想办法。</p>
</li>
<li><p><strong>他们可能想出你没有考虑到的解决方法或主意。这是最有趣的——你也可以学到新东西。</strong></p>
</li>
<li><p><em>如果有人还是没有任何线索，那就给更多提示吧（或者甚至是答案）。如果有人提出来某些想法，不妨帮他们分析每种想法的优劣之处。如果有人给出的答案或解决方法更好，那就从中汲取经验，然后分享你的体会吧。这对双方来说都是极佳的学习经验。</em>*</p>
</li>
</ul>
<p>  作为指导者，应该鼓励、引领大家思考如何解决问题。第20页提到过亚里士多德的话：“能欣赏自己并不接受的想法，表明你的头脑足够有学识。”应该接纳别人的想法和看问题的角度，在这个过程中，自己的头脑也得到了拓展。</p>
<p>  如果整个团队都能够采纳这样的态度，可以发现团队的知识资本在快速提升，而且将会完成一些极其出色的工作成果。</p>
<blockquote>
<p>给别人解决问题的机会。指给他们正确的方向，而不是直接提供解决方案。每个人都能从中学到不少东西</p>
</blockquote>
<p>  切身感受</p>
<p>  <strong>感觉不是在以填鸭式的方式给予别人帮助。不是有意掩饰，更非讳莫如深，而是带领大家找到自己的解决方案。</strong></p>
<p>  平衡的艺术</p>
<ul>
<li>用问题回答问题，可以引导提问的人走上正确的道路。</li>
<li><strong>如果有人真的陷入胶着状态，就不要折磨他们了。告诉他们答案，再解释为什么是这样。</strong></li>
</ul>
<h4 id="43-准备好后再共享代码"><a href="#43-准备好后再共享代码" class="headerlink" title="43 准备好后再共享代码"></a>43 准备好后再共享代码</h4><blockquote>
<p>“别管是不是达到代码签入的要求，要尽可能频繁地提交代码，特别是在要下班的时候。</p>
</blockquote>
<p>  让你猜个谜语：相对不使用版本控制系统，更坏的状况是什么？答案是：错误地使用了版本控制系统。使用版本控制系统的方式，会影响生产力、产品稳定性、产品质量和开发日程。特别地，诸如代码提交频率这样简单的东西都会有很大影响。</p>
<p>  <strong>完成一项任务后，应该马上提交代码，不应该让代码在开发及其上多停留一分钟。</strong>如果代码不能被别人集成使用，那又有什么用处呢？应该赶紧发布出去，并开始收集反馈。</p>
<p>  很明显，每周或每月一次提交代码，并不是令人满意的做法一一这样源代码控系统就不能发挥其作用了。也许总有种种原因来为这种懒散的做法解释。有人说开发人员是采取异地开发（of-site）或离岸开发（ offshore）的方式，访问源代码控制系统的速度很慢。这就是环境黏性（ environmental viscosity）的例子正事情做糟要比做好更容易。很明显，这是一个待解决的简单技术问题。</p>
<p>  另一方面，如果在任务完成之前就提交代码，会带来很多风险。这些代码可能还有编译错误，或者对其所做的某些变化与系统其它部分的代码不兼容。当其它开发者获取最新版本的代码时，也会受到这些代码的影响。</p>
<p>  向代码库中提交仍在开发的代码，会带来很多风险。这些代码可能还有编译错误，版本的代码时，也会受到这些代码的影响。或者对其所做的某些变化与系统其他部分的代码不兼容。当其他开发者获取最新版本的代码时，也会收到这些代码的影响。</p>
<p>  通常情况下，提交的文件应该与一个特定的任务或是一个bug的解决相关。而且应该是同时提交相关的文件，并注有日志信息，将来页能够知道修改了哪些地方，以及为什么要做修改。一旦需要对变更采取回滚操作，这种“原子”提交也是有帮助的。</p>
<p>  <strong>要保证在提交代码之前，所有的单元测试都是可以通过的。使用持续集成是保证源代码控制系统中代码没有问题的一种良好方式。</strong></p>
<blockquote>
<p>代码不执行提交操作的其他安全选择</p>
<p>如果需要将尚未完成的源代码碣传输或是保存起来，有如下选择。</p>
<p>使用远程访问。将代码留在工作地点，然后在家里使用远程访问获取，而不是将完成了一半的代码提交，再从家里签出</p>
<p>随身携带。将代码复制到U盘、CD或DVD中，以达到异地开发的目的。</p>
<p>使用带有底座扩展的笔记本电脑。如果是由于在多台电脑上开发造成的延续性问题，不妨考虑使用带有底座扩展的笔记本电脑，这样就可以带着代码到处走了。</p>
<p>使用源代码控制系统的特性。 Microsoft Visual Team System2005有一个shelving”特性，因为有些产品的某些代码在提交之前，需要被其他部分调用在CVS和 Subversion中，可以将尚未允许合并到主干的代码，设定为开发者的分支（查看[TH03]和Mas05]）</p>
</blockquote>
<blockquote>
<p>准备好后再共享代码。绝不要提交尚未完成的代码。故意签入编译未通过或是没有通过单元测试的代码，对项目来说，应被视作玩忽职守的犯罪行为。</p>
</blockquote>
<p>  <strong>切身感受</strong></p>
<p>  <strong>感觉好像整个团队就在源代码控制系统的另一端町着你。要知道一旦提交代码，别人就都可以访问了。</strong></p>
<p>  平衡的艺术</p>
<ul>
<li>有些源代码控制系统会区分“提交”和“可公开访问”两种代码权限。此时，完全可以进行临时的提交操作。（VS中TFS的搁置集？）</li>
<li>有些人希望代码在提交之前可以进行复查操作。只要不会过久拖延提交代码的时间就没有问题。如果流程的某个部分产生了拖延，那就修正流程吧。</li>
<li>仍然应该频繁提交代码。不能用“代码尚未完成”作为避免提交代码的借口。（至少在开发分支上是如此。）</li>
</ul>
<h4 id="44-做代码复查"><a href="#44-做代码复查" class="headerlink" title="44 做代码复查"></a>44 做代码复查</h4><blockquote>
<p>“用户是最好的测试人员。别担心一一如果哪里出错了，他们会告诉我们的。”</p>
</blockquote>
<p>代码刚刚完成时，是寻找问题的最佳时机。如果放任不管，它也不会变得更好。</p>
<blockquote>
<p>代码复查和缺陷移除</p>
<p>要寻找深藏不露的程序bug，正式地进行代码检查，其效果是任何已知形式测试的两倍，而且是移除80%缺陷的唯一已知方法。</p>
<p align="right">——Capers Jones的《估算软件成本》[Jon98]]</p>
</blockquote>
<p>  正如 Capers Jones指出的，代码复查或许是找到并解决问题的最佳方式。然而，有时很难说服管理层和开发人员使用它来完成开发工作。</p>
<p>  <strong>管理层担心进行代码复查所耗费的时间。他们不希望团队停止编码，而去参加长时间的代码复査会议</strong>。开发人员对代码复查感到担心，允许别人看他们的代码，会让他们有受威胁的感觉。这影响了他们的自尊心。他们担心在情感上受到打击。</p>
<p>  作者参与过的项目中，只要实施了代码复查，其成果都是非常显著的。</p>
<p>  Venkat最近参与了一个日程安排非常紧湊的项目，团队不少成员都是没有多少经验的开发者。通过严格的代码复查过程，他们可以提交质量极高而且稳定的代码当开发人员完成某项任务的编码和测试后，在签入源代码控制系统之前，会有另名开发人员对代码做彻底的复査。</p>
<p>  这个过程修复了很多问题。噢，代码复查不只针对初级开发者编写的代码一团队中每个开发人员的代码都应该进行复查，无论其经验丰富与否。</p>
<p>  那该如何进行代码复査呢？可以从下面这些不同的基本方式中进行选择。</p>
<ul>
<li>ロ通宵复查。可以将整个团队召集在一起，预定好美食，每个月进行一次“恐怖的代码复査之夜”。但这可能不是进行代码复査最有效的方式（而且听起来也不太敏捷）。大規模团队的复査会议很容易陷入无体止的讨论之中。大范围的复查不仅没有必要，而且有可能对整个流程造成损害。我们不建议这种方式。</li>
<li><strong>捡拾游戏。当某些代码编写完成、通过编译、完成测试，并已经准备签入时，其他开发人员就可以“捡拾”起这些代码开始复查。类似的“提交复查”是种快速而非正式的方式，保证代码在提交之前是可以被接受的。为了消除行为上的惯性，要在开发人员之间进行轮换</strong>。比如，如果Joey的代码上次是由Jane复査的，这次不妨让Mak来复查。这是一种很有效的技术。</li>
<li><strong>结对编程。在极限编程中，不存在一个人独立进行编码的情况。编程总是成对进行的：一个人在键盘旁边（担任司机的角色），另一个人坐在后面担任导航员。他们会不时变换角色。有第二双眼睛在旁边盯着，就像是在进行持续的代码复査活动，也就不必安排单独的特定复查时间了。</strong></li>
</ul>
<p>  在代码复查中要看什么呢？你可能会制订出要检查的一些特定问题列表（所有的异常处理程序不允许空，所有的数据库调用都要在包的事务中进行，等等），不过这里是一个可供启动的最基本的检查列表</p>
<ul>
<li><strong>代码能否被读懂和理解？</strong></li>
<li><strong>是否有任何明显的错误？</strong></li>
<li><strong>代码是否会对应用的其他部分产生不良影响？</strong></li>
<li><strong>是否存在重复的代码（在复查的这部分代码中，或是在系统的其他部分代码）？口是否存在可以改进或重构的部分？</strong></li>
</ul>
<p>  此外，还可以考虑使用诸如 Similarity Analyzeri或 Jester这样的代码分析工具。如果这些工具产生的静态分析结果对项目有帮助，就把它们集成到持续构建中去吧</p>
<blockquote>
<p>复查所有的代码。对于提升代码质量和降低错误率来说，代码复查是无价之宝，如果以正确的方式进行，复查可以产生非常实用而高效的成果要让不同的开发人员在每个任务完成后复查代码吗。</p>
</blockquote>
<p>  切身感受</p>
<p>  代码复査随着开发活动持续进行，而且每次针对的代码量相对较少。感觉复查活动就像是项目正在进行的一部分，而不是一种令人畏惧的事情。</p>
<p>  平衡的艺术</p>
<ul>
<li>不进行思考、类似于橡皮图章一样的代码复查没有任何价值。</li>
<li><strong>代码复查需要积极评估代码的设计和清晰程度，而不只是考量变量名和代码格式是否符合组织的标准。</strong></li>
<li><strong>同样的功能，不同开发人员的代码实现可能不同。差异并不意味着不好。除非你可以让某段代码明确变得更好，否则不要随意批评别人的代码。</strong></li>
<li><strong>如果不及时跟进讨论中给出的建议，代码复查是没有实际价值的。可以安排跟进会议，或者使用代码标记系统，来标识需要完成的工作，跟踪己经处理完的部分。</strong></li>
<li><strong>要确保代码复査参与人员得到每次复査活动的反馈。作为结果，要让每个人知道复查完成后所采取的行动。</strong></li>
</ul>
<h4 id="45-及时通报进展与问题"><a href="#45-及时通报进展与问题" class="headerlink" title="45 及时通报进展与问题"></a>45 及时通报进展与问题</h4><blockquote>
<p>“管理层、项目团队以及业务所有方，都仰仗你来完成任务。如果他们想知道进展状况，会主动找你要的。还是埋头继续做事吧</p>
</blockquote>
<p>  接受一个任务，也就意味着做出了要准时交付的承诺。不过，遇到各种问题从而导致延迟，这种情形并不少见。截止日期来临，大家都等着你在演示会议上展示工作成果。如果你到会后通知大家工作还没有完成，会有什么后果？除了感到窘迫，这对你的事业发展也没有什么好处。</p>
<p>  <strong>如果等到截止时间才发布坏消息，就等于是为经理和技术主管提供了对你进行微观管理（ micromanagement）的机会。他们会担心你再次让他们失望，并开始每天多次检查你的工作进度。你的生活就开始变得像呆伯特的漫画一样了。</strong></p>
<p>  假定现在你手上有一个进行了一半的任务，由于技术上的难题，看起来不能准时完成了。如果这时积极通知其他相关各方，就等于给机会让他们提前找出解决问题的方案。也许他们可以向另外的开发人员寻求帮助，也许他们可以将工作重新分配给更加熟悉相关技术的人，也许他们可以提供更多需要的资源，或者调整目前这个送代中要完成的工作范围。客户会愿意将这个任务用其他同等重要的任务进行交换的。</p>
<p>  <strong>及时通报进展与问题，有情况发生时，就不会让别人感到突然，而且他们也很愿意了解目前的进展状况。他们会知道何时应提供帮助，而且你也获得了他们的信任。</strong></p>
<p>  发送电子邮件，用即时贴传递信息，或快速电话通知，这都是通报大家的传统方式。还可以使用 Alistair Cockburn提出的“信息辐射器”。°信息辐射器类似于墙上的海报，提供变更的信息。路人可以很方便地了解其中的内容。以推送的方式传递信息，他们就不必再来问问题了。信息辐射器中可以展示目前的任务进度，和团队、管理层或客户可能会感兴趣的其他内容。</p>
<p>  也可以使用海报、网站、Wiki、博客或者 RSS Feed.。只要让人们可以有规律地查看到需要的信息，这就可以了。</p>
<p>  整个团队可以使用信息辐射器来发布他们的状态、代码设计、研究出的好点子等内容。现在只要绕着团队的工作区走一圈，就可以学到不少新东西，而且管理层也就可以知道目前的状况如何了。</p>
<blockquote>
<p><strong>及时通报进展与问题。发布进展状况、新的想法和目前正在关注的主题不要等着别人来问项目状态如何。</strong></p>
</blockquote>
<p>  <strong>切身感受</strong></p>
<p>  <strong>当经理或同事来询问工作进展、最新的设计，或研究状况时，不会感到头痛。</strong></p>
<p>  <strong>平衡的艺术</strong></p>
<ul>
<li><strong>每日立会（见第148页习惯38）可以让每个人都能明确了解最新的进展和形势。</strong></li>
<li><strong>在展示进度状况时，要照顾到受众关注的细节程度。举例来说，CEO和企业主是不会关心抽象基类设计的具体细节的。</strong></li>
<li><strong>别花费太多时间在进展与问题通报上面，还是应该保证开发任务的顺利完成。</strong></li>
<li><strong>经常抬头看看四周，而不是只埋头于自己的工作。</strong></li>
</ul>
<h3 id="第9章-尾声：走向敏捷"><a href="#第9章-尾声：走向敏捷" class="headerlink" title="第9章　尾声：走向敏捷"></a>第9章　尾声：走向敏捷</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/07/27/effective-programming-more-than-writing-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/effective-programming-more-than-writing-code/" class="post-title-link" itemprop="url">高效能程序员的修炼</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-27 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-27T00:00:00+00:00">2019-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 13:18:12" itemprop="dateModified" datetime="2022-01-04T13:18:12+00:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/" itemprop="url" rel="index"><span itemprop="name">博览群书</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://www.goodreads.com/book/show/15746409-effective-programming">goodreads</a></p>
<p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/24868904">豆瓣读书</a></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><p>入门须知</p>
<ul>
<li><p>程序员的八种境界</p>
<p>1.<strong>不朽的程序员这是最高境界！虽然人已经走了，但是他的代码却依然活着。</strong>他成为计算机博物馆中的一个永久收藏。其他为数众多的程序员都在学习他的作品。他在生前可能得到过图灵奖，或者发表了大量有影响力的论文，或者是发明了一些影响到计算机专业课程设置的基础技术。他已经不仅仅只是拥有一个维基百科的条目，事实上，有很多专门的网站来讲述他的作品以及他生平的事迹。在人的有生之年能够达到这一境界的程序员屈指可数。代表人物：Dijkstra、Knuth、Kay。译者注：Dijkstra是一名荷兰的计算机科学家，他因发明了计算机编程语言而于1972年获得了图灵奖。Knuth是《计算机程序设计艺术》一书的作者，他被称为算法分析之父。Kay是一名美国的计算机科学家，是面向对象编程、视窗图形用户界面设计的先驱者，他有一句名言是：“预测未来的最好办法是创造未来。”</p>
<p>2.成功的程序员成功的程序员不仅拥有广泛的知名度，同时还运营着一个不错的公司，甚至控制了整个产业链。他们拥有绝对的自由，可以做着自己想做的事情。他们同时还有着把“自由”带给广大程序员同胞的梦想。这一境界的程序员最受人羡慕。要到达这一境界，更多的是需要商业上的才能，而不是你的编程能力。代表人物：比尔·盖茨、Carmack、DHH。译者注：比尔·盖茨是微软公司的创始人，他是个电脑神童，13岁开始编程，20岁开始领导微软；他同时也是个商业奇才，他利用自己的远见卓识和精明的商业头脑让微软名噪天下，把软件做成了人们生活中不可或缺的东西，成就了今日的微软帝国。Carmack是Id软件公司的创始人，该公司主要从事电脑游戏以及游戏引擎的开发，作品有《半条命》、《反恐精英》、《毁灭战士》等。DHH是一名丹麦的程序员，他建立了“RubyonRails”Web应用架构,并与人合写了《Web开发敏捷之道：应用Rails进行敏捷Web开发》一书。</p>
<p>3.知名程序员进入这一境界的程序员也不错，当然前提是，你得有一份不错的工作。这个境界的程序员虽然在圈子里很有名，但是成为名人并不意味着你可以靠这个赚取收入并且养活自己。出名固然不错，但成功更为关键。你可能在一家非常知名的大型技术公司工作，也可能在一家很有影响力的小公司，或者是在一个很有希望的创业团队。不管怎么样，其他的程序员都或多或少地听说过你，并且你对你所在的领域有着积极的影响。</p>
<p>4.胜任的程序员你作为一名软件工程师非常成功，因为你的能力使你在工作中游刃有余。你从来不会为找一份满意的工作而发愁。你的同事也非常尊敬你。每一家你工作过的公司都因为你的加盟而在某些方面得到了提升。<strong>但问题是：你接下来的方向在哪里？</strong></p>
<p>5.普通程序员这个境界的程序员能够基本应付一般的编程工作。他们自己也很清楚，由于天资所限，他们很难成为杰出的程序员。其实，天赋跟成功的关系并不大。如果你有敏锐的商业嗅觉和不错的人际交往能力，你依然可以变得很成功。如果你是一个普通的程序员，但你还能靠这一行当过上不错的生活，那已经说明你是很有才的，只是你不必非得干程序员这一行。人贵自知之名。通常你的能力都会比你自认为的要低。缺乏天赋并不是什么大不了的事情。要勇敢一点，发掘自己的特长，并且充分地加以发挥。</p>
<p>6.<strong>业余程序员业余程序员通常都热衷于编码。</strong>他们可能是一些很有前途的学生或实习生，也可能正在参与某些开源项目，或者利用个人闲暇时间开发一些“好玩的”应用程序或网站。从他们的代码和创意可以看得出，他们是一群很有想法、充满激情的人。成为一名业余程序员是件好事。这个境界的程序员可以通过自我提升，很快速地胜任程序员这个职业。</p>
<p>7.低调的程序员还有一些坊间流传的比较有个性的程序员，比如JoeCoder，很有能力但是没啥令世人瞩目的成就。他们可能服务于某家大型公司。对于这些人来说，写代码仅仅是份工作而已，并非他们生活的全部。这没什么错，挺好的！</p>
<p>8.<strong>烂程序员这个级别的程序员技能极其匮乏（已无境界可言），他们通常是因为某些阴差阳错的原因才干上这一行的。他们所做的任何事情都会给他们的同事带来痛苦和灾难——当然可能也有一个例外，就是他们的同事也是一帮差劲的程序员，差到连身边全是一帮烂程序员都意识不到。如果要给烂程序员下一个定义的话，那就是：没有金刚钻，却偏偏揽了瓷器活。应该承认，以上所有的这些境界定义得并不严谨。其实，不是所有的程序员在他们的职业生涯中都渴望相同的东西。思考一个程序员在他10年、20年、乃至30年、甚至一生的时间内所能达到的成就，是非常有意义的！想一想，你最崇拜哪个程序员？到底是他的什么成就，使得你对他有如此的崇拜？</strong></p>
<p>话说回来：你究竟想要过怎样的生活？</p>
</li>
</ul>
</li>
<li><p>把一堆烂事搞定的艺术</p>
<ul>
<li><p>磨刀不误砍柴工</p>
<p>有个人在山间漫步，偶遇一位伐木工。他便停下来观察这位伐木工，看他热火朝天地锯一棵很大的树。他发现这位伐木工干得大汗淋漓，不停地锯来锯去，但是没有丝毫的进展。这个过路人注意到伐木工所使用的锯子已经和黄油刀一样钝了。于是，他就对伐木工说：“不好意思，伐木工先生，我看着你已经很使劲地在锯那棵树了，但为什么进展不大呀？”伐木工回答道：“是呀……我也知道。不过，看起来这棵树不好对付啊！”此时，汗正从他的眉毛间滴落下来。过路人于是提醒道：“伐木工先生，这不是树的问题，是你的锯子太钝了。这么钝的锯子什么东西也锯不断的！”“我知道。”伐木工回答说，<strong>“但是，我连锯树都忙不过来，哪有时间磨锯子啊！”</strong></p>
<p>大家都知道，如果想要在某方面有所提高，最好的办法就是勤加练习。但是，如果你只顾着埋头写代码，连讨论、反思或者学习的时间也没有了，其实你得不到真正的进步。<strong>你必须在磨练工艺与思考如何提高工艺之间找到一个适当的平衡。</strong></p>
<p><strong>当然，过多地磨锯子，或者随意地、没有目标地磨锯子，会变成另外一种形式的延误</strong>。然而，如果一个程序员对这些完全不感兴趣，那也是一个巨大的危险信号。就像Peter Bregman说的那样，“痴迷可以是一件好事”：</p>
<blockquote>
<p>人们成功常常不是因为他们克服了自己的机能障碍，反而是这些障碍成就了他们。痴迷是通向成功的一个最明显的风向标。如果理解了一个人的痴迷，你就会理解他最自然的动机—他会为之坚持走到世界的尽头。</p>
</blockquote>
<p>对磨锯子有些痴迷是没有问题的，但前提是，你的痴迷是类似Hackers News的网站上积极地提交和讨论与编程相关的文章。</p>
<p>作为一名程序员，你对如何磨快锯子有更好的建议吗？</p>
</li>
<li><p>一路向前冲</p>
<p><strong>沿着那条路下去，一定要快。如果有什么东西挡住了你的去路……绕开它！</strong></p>
</li>
<li><p>关于多任务的神话</p>
<p><strong>根据Weinberg的计算，哪怕只是在你的工作负荷中增加一个项目，也会严重地影响你的效率。你会损失20%的时间。当你增加第三个项目的时候，你有将近一半的时间浪费在任务切换上面。</strong></p>
<p><strong>即便你同一时间只做一个项目，这种问题也可能会发生。轻易让电子邮件、电话以及即时消息打断你正在进行的工作，其影响可能是深远的，就像BBC的这个研究中所记载的那样：</strong></p>
<blockquote>
<p>英国精神病学研究院所做的这个研究表明，<strong>过度地使用科技会降低工作人员的智力。</strong>研究员得出结论：<strong>那些常被电子邮件和电话干扰的人，他们的智商会有10个点的下降——跟研究发现的吸食大麻所引起的损害相比，前者是后者的两倍还多。</strong></p>
</blockquote>
<p>通常情况下，我会拒绝“同时做多个项目”这样的要求。说“不”也许很难，因为软件开发者往往过于乐观，这是他们众所周知的职业性“毛病”。</p>
<p><strong>我们常常高估自己的能力，而关于多任务的神话让我们的内心更加膨胀。但是，只要有可能，请远离干扰，并且避免同时做多个项目。如果实在避免不了，关于你在多任务并行的情况下实际能做多少事情，请你自己保持清醒的认识，也坦率地让其他项目干系人知道。你很可能会力不从心！</strong></p>
</li>
</ul>
</li>
<li><p>高效编程之原则</p>
<ul>
<li><p>第一条发展：永远都是你的错</p>
<p>老是要处理一些困难的、捉摸不透的问题，这是一件令人绝望的事情，但是不要让绝望领着你误入歧途。作为一名谦逊的程序员，最基本的要求就是要有意识：<strong>你写的代码在任何时候出了问题，那一定都是你的错。</strong></p>
<p>代码产权的另一面是代码责任。<strong>无论你的软件出现什么样的问题——甚至最开始出错的地方根本就不是你的代码——你也应该总是假定问题出在你的代码里，并且根据这个假设采取行动。如果你想让世界人民接受你的软件，那你就要为它的故障承担全责。尽管——从严格意义上来说——你并不是非这么做不可。只有这样，你才能赢得尊敬和信用。如果你不断地把问题推卸到其他人、其他公司或者其他的源头上，你是无论如何也得不到尊敬和信用的。</strong></p>
</li>
<li><p>避免写注释</p>
<p>尽管注释本身说不上好或者坏，它们却常常被用作支撑代码的“拐杖”。<strong>应该总是专注于编写代码，而忘了还有注释这种东西的存在。这会迫使你竭尽全力使用最简单、最直白、最能自我说明的方式把代码写出来。</strong></p>
</li>
<li><p>学会阅读源代码</p>
<p>有些时候，文档是不完整的。有些时候，它干脆就是错误的。<strong>源代码是从来不会撒谎的</strong>。对于一名有经验的程序员来说，阅读源代码通常会更快些（尤其在你已经熟悉了软件包架构的情况下）……我现在和几个创业公司在一个中等规模的共享办公区域里一起工作。很多其他公司的首席技术官和工程师都时常跑到我们团队来寻求指导和建议。当他们带着有问题的软件过来的时候，我问他们的第一个问题就是：“嘿，你看过源代码了吗？”</p>
<p>我鼓励开发人员“git clone”他们依赖的所有源代码。起初，他们都有些害怕。“那个项目太大了。我永远也无法把问题找出来！”“我没那么聪明，看不懂那些代码。”“那些代码太难看了！简直惨不忍睹！”<strong>但是，你不必把那些代码翻个底朝天，而只需要跟着线索走</strong>。况且，如果你不能理解你所依赖的平台，你又怎么能驾驭你自己的软件呢？在大多数情况下，菜鸟程序员认为漂亮的，往往止于肤浅；而他们认为丑陋的，往往是骇客大师们所写的久经考验的产品级代码。现在，在经过了一两年之后，有几个开发人员专程过来找我，感谢我当初强迫他们在别人的代码里“潜水”或者“畅游”。他们现在的技能都比以前大有长进，而且他们还感叹：真不知道过去在没有别人源代码的时候是怎么把事情做好的……</p>
<p><strong>真正的骇客世界里只有一个简单的事实：如果一个软件在我的机器上运行，那它就是我的软件</strong>。我对它负责。我必须把它弄明白。从源代码开始构建是一条必须遵循的原则，而且从不例外。我必须控制我的环境，我还要控制所有我依赖的东西。</p>
</li>
<li><p>向橡皮鸭求助</p>
<ul>
<li><p>在Stack Exchange上，我们坚持要求提出问题的人需要在自己的问题上多下些功夫，而且我们在这方面有些偏执。那就是说，当你开始要提问题的时候，你应该：</p>
</li>
<li><p>用足够多的细节来描述发生的状况，这样我们可以顺着你的描述继续研究下去。即使在你所在的特定领域里我们并不是专家，你也要向我们提供必要的背景情况，这样我们可以了解到底发生了什么事情。</p>
</li>
<li><p>告诉我们你为什么需要知道答案。你怎么会出现在这里？是闲来无事的好奇，还是在某个项目里遇到了障碍？我们不是要求你长篇大论地讲生活故事，只是想了解跟你的问题相关的一些基本情况。</p>
</li>
<li><p>说一说为了解决这个问题你都做过什么研究，以及你的发现（如果有的话）。如果你没有做过任何研究，你应该来这里提问题吗？</p>
</li>
<li><p>归根结底，这关乎公平：如果你想要我们花上宝贵的时间来帮助你，只有在你也花了相当的宝贵时间酝酿出一个合格的问题时才算公平。帮我们也就是帮你自己！</p>
</li>
</ul>
</li>
<li><p>当我自己解决了自己的问题，我该怎样感谢社区呢？</p>
<ul>
<li>迄今为止我只贴出了一个问题，第二个问题差一点就贴出去了。<strong>在我写两个问题的过程中，我自己找到了答案（至少是部分答案）。我把这归功于网络社区和提问流程，因为它们促使我自己思考答案</strong>。在我所写的东西里，没有任何内容明确地指明了我要的答案。<strong>但是在我把它们写下来的过程中，某种东西让我用额外的思维方式去思考问题</strong>。</li>
</ul>
<p><strong>为什么适当地组织你的问题通常能让你自己找到答案？</strong></p>
<p>我已经记不清这样的情况发生过多少次：</p>
<ul>
<li>我碰到一个问题；</li>
</ul>
<p>-我决定把这个问题提到Stack Overflow；</p>
<ul>
<li><p>我很笨拙地写下我的问题；</p>
</li>
<li><p>我意识到这个问题根本就说不通；</p>
</li>
<li><p>我花了15分钟重新思考该如何提出我的问题；</p>
</li>
<li><p>我意识到我正在一个完全错误的方向上解决这个问题；</p>
</li>
<li><p>我从头再来，然后很快就找到了解决方案。</p>
</li>
<li><p>你也有过这样的情况吗？有时候，提出正确的问题差不多就已经把问题解决了一半。</p>
</li>
<li><p>开始提出问题实际上促使我自己诊断自己的问题。</p>
</li>
</ul>
<p>为了得到满意的答案，当我尝试组织一个内容连贯且信息翔实的问题时，提问题的动机实际上促使我自己诊断自己的问题。这在别人身上也发生过吗？</p>
<p>这不是一个新的概念。如果给予足够的时间，每个社区似乎都能自己意识到这个问题。但是，“问鸭子”确实是一个非常有效的解决问题的技巧。</p>
</li>
<li><p>创新以人文本</p>
<p>一个好的创意值多少钱？Derek Sivers1认为，不值多少：</p>
<p>当我了解到人们都在紧张兮兮地保护创意，我觉得很好笑。（有人要求我签署一份保密协议，然后才肯告诉我一个简单得不能再简单的创意。）对我来说，<strong>除非创意能被执行，否则它一文不值</strong>。执行是创意的倍增器。真正价值巨大的是“执行”！</p>
<p>如果你想要创业赚钱，你必须把这两者相乘。最杰出的创意，如果没有执行，那也只值20美元。最杰出的创意需要卓越的执行才能值2000万美元。这就是我不想只听人们的创意的原因所在。在没看到他们的执行力之前，我对他们的创意一点儿都不感兴趣。</p>
<p>创意与执行之间的鸿沟是如此巨大，以至于我很费解：为什么作者自己看不到？！</p>
<p>我不会说创意本身毫无价值，但是很显然，单有创意只是空头支票。<strong>成功很少是由创意的质量来决定的，但它时常由你执行的质量来决定</strong>。因此，与其担心你全心投入的下一个大创意是否足够出色，不如担心你能执行得多好。</p>
<p>不要批判那些“超有默契的人”，他们正是你取得成功所必需的；这个在Stack Overflow上同样备受推崇。具有讽刺意味的是，Andy Baio（就是在上面邮件里被点名的那个人）在去年给我的一封邮件里说道：</p>
<p>我非常喜欢Hacker News网站上那个关于用一个周末的时间就克隆一个网站的讨论。我最欣赏的评论是，有人相信Stack Overflow之所以成功仅仅是因为人们对Atwood和Spolsky的狂热崇拜。太令人惊异了！</p>
<p>不管你在互联网上有多么出名，都不可以跳过“执行”这一步。当然，你可能在刚开始的时候会吸引更多的眼球，但如果你没能做出来一些有用的东西，整个世界最终会齐刷刷地耸耸肩膀、转去那些更加有用的地方。</p>
<p><strong>在软件开发领域，执行意味着专注于构成你的应用程序的所有微小细节。如果你不是始终沉迷于你的应用程序的每个方面，不去持续优化和改进它的每一处细节（无论多么微不足道），那么你就不是在执行。至少，不是在很好地执行。</strong></p>
<p>除非你是一个人工作的（如今已经非常少见了），否则，你掌控构成你的应用程序的所有细节的能力完全取决于你能否组建一支很棒的团队。他们是成功的必要元素。这段来自Ed Catmull的演讲4，几乎完全专注于皮克斯5是如何通过尝试和失败学会组建具有执行力的团队的。</p>
<p>这是一次引人入胜的演讲，过程中充满了令人惊叹的见识。你应该把这段视频完整地看一遍。在演讲中，Catmull先生延伸了Sivers先生的观点：</p>
<p>如果你把一个好的创意给一个普通的团队，他们会把它搞砸。如果你把一个普通的创意给一个好的团队，他们会对它加以完善。或者，他们会把那个创意丢掉，然后想出一些更棒的。</p>
</li>
<li><p>你的团队能通过电梯测试吗</p>
<p><strong>软件开发者认为他们的工作就是编写代码。其实不然。（这句话是我从Billy Hollis那里“偷”来的</strong>。他曾以软件痴迷者为主题做过15分钟的精彩演讲。）<strong>他们的工作应该是解决客户的问题</strong>。当然，我们偏爱通过软件来解决问题，那的确包含了编写代码。但是，我们要有全局的观点：编写代码是我们为了交付解决方案所必须完成的其中一环。它自身并不是目的。</p>
<p>作为软件开发者，我们花了那么多时间沉浸在没完没了的、支离破碎的细节中，以致于我们太容易掉入为了编码而编码的陷阱中。如果没有明确的焦点或者某种让我们团结在一起的东西，我们就会只见代码这棵树木而看不见整个森林。由此可见，拥有一个清晰的项目远景声明（Vision Statement）是极其重要的，每个人都可以把它当作这个项目的试金石。如果你把远景声明搞清楚了，你团队里的每个人都应该能通过由陌生人主持的“电梯测试”——在60秒之内，清晰地解释他们在做什么，以及为什么人们会在意他们正在做的事情。</p>
<p>我发现有一个做法在让整个团队思考产品远景方面很有效果，那就是“设计产品包装盒”。这个练习可以在项目启动阶段很好地激发大家的思维和讨论。整个团队假设产品最终会被装在一个可拆封的盒子里，而他们的任务就是设计这个包装盒的正面和背面。这包括给产品起个名字、一副图片、正面列出3~4个关键点来“叫卖”这个产品、背面的详细特性说明、以及运行要求。</p>
<p><strong>实践证明，想出15<del>20个产品特性是容易的。难就难在，要选出其中3</del>4个能促使人们购买这个产品的特性。这个过程中还经常会发生关于“谁是真正的客户”的激烈争论</strong>。</p>
<p>“设计产品包装盒”是构建远景声明的一种极好的方法。它基于一个具体的、真实世界里的概念，因此大多数人都可以轻松地开动他们的脑筋。忘掉那些空中馅饼式的远景追求吧，让我们务实一点：我们（假想）的产品包装盒看起来会是什么样的呢？</p>
<p>我们都是消费者。我们对产品包装盒的设计目标都很清楚。如果不拿产品包装盒跟极端的“电梯推介”相提并论，那它也应该：</p>
<ul>
<li><strong>用最简单可行的方法来解释我们的产品是什么</strong>；</li>
<li><strong>把潜在客户愿意购买这个产品的原因解释得一清二楚</strong>；</li>
<li><strong>与货架上所有其他的产品包装盒相比具有独一无二的辨识度</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>招聘程序员须得其法</p>
<ul>
<li><p>怎样招聘程序员</p>
<ol>
<li><p>首先要求通过几个简单的“Hello World”在线测试</p>
</li>
<li><p>提出要看看他们的文件夹</p>
<p> 看看应聘者以前做过什么样的工作，他在网上展示了什么样的作品，这对了解这个人是极其有帮助的——通过这些，可以去理解他做过的东西，并且判断出他擅长什么（或者不擅长什么）。</p>
</li>
<li><p>只雇佣认同公司文化的人</p>
</li>
<li><p>进行一个周详的结构化电话面试</p>
<p> <strong>不要期望从电话的另一头得到完美的答案，也没这个必要。你需要了解的只是这个人解决问题的方式，还有他们是否真的掌握了相关的技术（上下浮动10%）</strong>。你的目标是，不要让一些不合格的人蒙混过关，否则到了下一阶段会浪费大家更多的时间。因此，你不要心慈手软，要对电话另一头保持火力，而当发现有太多疑点之后，提前结束通话。</p>
</li>
<li><p>给他们一个“试镜”项目</p>
<p>到这时候，应聘者已经通过了“Hello World”编程测试，他的“文件夹”里的东西也很光彩夺目，他融入公司文化没有丝毫的问题，他也成功通过了电话面试。是时候把他叫过来进行面对面的面试了，对吗？别这么急，兄弟！</p>
<p>我见过一些应聘者通过了前面4关，然后加入了公司，结果在实际项目中还是表现不佳。我没有提醒你吗？招聘程序员是很难的！</p>
<p>这位候选人会不会是一个成功的聘用呢？如果你还心存疑虑，想要抹去这层阴影的最好办法，就是给他一个“试镜”项目。我指的不是那种空泛的、抽象的编程问题，而是现实世界里、实际项目中你需要马上做的一块实实在在的工作。这块工作你原本是打算让正式员工做的，只是他们现在都在忙着其他的事情，因此这块工作暂时还没分配出去。</p>
<p>这个项目应该以常规的咨询服务的形式进行，按小时计费，并且清晰地定义好项目任务书。<strong>选择的项目一定要小，理想情况下几天就能做完，至多1~2周</strong>。候选人可以进办公室来做这个项目，或者也可以远程登录过来。我知道，不是所有的公司都能提供这种“一口大小”的工作分给公司以外的人来做。（他们拼死了也想把所有的事情都在公司内部做完。）但是，我就想了，如果你费劲脑汁还是想不出一个迷你的“试镜”项目给一位很不错的候选人做（你很有可能把这个人招进来哦），也许你在现有员工之间的工作分配方面也存在一些问题，至少不够结构化。</p>
<p>如果“试镜”项目做成了，那就太美妙了——你现在得到了一位高度合格的候选人，他的做事能力得到了验证，而且你还有效地给实际项目完成一些工作。迄今为止，我还没见过有谁通过了“试镜”项目的考验但后来还在实际项目中表现不佳的。我非常依赖“试镜”项目来考察一个人的能力；做这种项目实际上跟做正常的工作很接近了，就差没把人家聘用进来了。不过，如果“试镜”项目失败了，也不要紧，想想也就浪费一点点咨询服务费，跟把候选人直接叫进公司、浪费公司的其他4~5位同事的时间去面试他相比，其实还是挺划算的。况且，你还可以把这个“试镜”项目传给下一位有潜力的候选人去做。</p>
</li>
<li><p>找个房间面谈，并最后定夺</p>
</li>
<li><p>上面没有哪条是保证奏效的</p>
</li>
</ol>
</li>
<li><p>如何做好电话面试筛选</p>
<ol>
<li><p>不要让候选人主导面试过程。大部分时间都应该是面试官在说话。面试官要引导整个对话过程，直到自己满意为止（要么确认候选人知道答案，要么候选人放弃了）。</p>
</li>
<li><p>小心只会一招的”小马驹”。<strong>只会一种特定的语言或编程环境，并且对其他东西一窍不通的候选人，小心啦，这是一个巨大的红色警告信号</strong>。</p>
<p> 电话面试的目的，不是让候选人复述他们做过的事情。面试官应该把他们从舒适区推出去一点，问他们一些相关的问题，但那些又是他们以前没见过或没做过的。理想情况下，你要了解这个人在面对新事物（比如你的代码库）的时候会做出什么样的反应。</p>
<p> 为了让电话面试进行得更加顺畅一点，我在下面罗列了你在面试软件开发工程师时需要问的5个基本问题。它们不能保证你会找到最棒的候选人，但能阻止相当一部分的人蒙混过关。</p>
<p> <strong>1）编程。候选人需要用C、C++或Java写一段简单的代码，要求语法正确。</strong></p>
<p> <strong>2）面向对象（Object Oriented，简称OO）的设计。候选人需要说清楚OO的基本概念，并且想出一些类来为一个简单的问题建模。</strong></p>
<p> <strong>3）脚本编程和正则表达式。候选人需要描述一下，如何在50000个HTML网页里把电话号码都找出来。</strong></p>
<p> <strong>4）数据结构。候选人需要证明他对最常用的数据结构都有着基本的理解。</strong></p>
<p> <strong>5）位与字节。候选人需要回答几个关于位、字节和二进制数字的简单问题。</strong></p>
<p> 请注意：我们这里想要发掘的，是在前面所说的某一方面完全无知的人。如果他们挣扎了一下，然后还是回答出来了，也就算过了。他们甚至可以要求一点小小的线索或提示。我不介意他们反应迟钝或动作缓慢。我们要找出的，是那些对问题中所涉及的领域极端困惑、毫无头绪的候选人。</p>
</li>
</ol>
</li>
<li><p>工作经验年数之神话</p>
<p>在招聘过程中，纵然你的电话面试筛选工作做得非常出色，有个概念还是常常会被扭曲。在澳大利亚有一家名叫Flat Rate Recruitment的人才中介公司，他们的Andrew Stuart曾经给我写信，向我讲述了一个非常好的故事。我把它摘录如下，恰好来说明这个问题：</p>
<p>我有个客户正在开发一个关于安全方面的高级应用程序。我给他们输送人才，一个接着一个，结果候选人统统都被退回来了。究其原因，几乎无一例外都说这些人”没有足够的底层编码经验”。然而，我送去的人都做过像设计并开发操作系统、高级内存管理等这样的事情，或者开发过其他高度复杂的应用程序。但我的客户不感兴趣。他们要求候选人前一份工作做的是在某个特定领域内的底层编码，并且要有实际经验。幸运的是，我最终找到了一位候选人-他是一位非常聪明的软件工程师，他几乎单枪匹马完成了一款优秀的电脑模拟器-但是，在客户所要求的特定领域里，他几乎没有任何底层编码的经验。</p>
<p>我告诉客户：”我现在有个很棒的小伙子，虽然他没有底层编码经验，但我认为你们应该雇用他。”他们一开始持极其怀疑的态度。我力劝，一定让他们给个面试的机会，”瞧，这小伙子是个超级棒的软件工程师，虽然他现在没有你们所要求领域内的底层编码经验，但只要你们雇用他，给他3～6个月的时间，他一定能够成为你们想要的那种有底层编码经验的超级棒的软件工程师”。</p>
<p>他们后来面试了他，并且雇用了他。也就是几个星期的时间，他很快成为那家公司最聪明的程序员。他快速掌握了他们的底层编码技术，他的学习能力比公司里的其他人都要出色。每次我跟那个客户联系的时候，他们都要对这位员工大加赞美一番，因为他已经成为那家公司的技术骨干。自那以后，那家公司已不再把招聘重点放在那些过往工作经验和所需技术完全匹配的候选人身上。<strong>取而代之的是，他们开始专注于寻找并雇用最聪明、最富有热情的工程师</strong>。</p>
<p>从我记事的那天起，关于工作经验年数的神话就已经在软件行业里广为流传了。但它是有害的，效果往往会适得其反。不难想象，就是因为很多公司都痴迷于雇用经验和技术完全匹配的人，结果造成很多才华横溢的软件工程师都被拒之门外。</p>
<p>他们似乎已经忘记了，软件开发者最擅长的就是学习。<strong>雇主应该找的是富有热情、有干劲、脑子灵活、自学能力强，并且证明了有能力用任何语言编程的人，然后就是找一些有趣的项目让他们施展才华</strong>。</p>
<p>工作经验年数与编程技能之间是没有必然联系的。这已经一次又一次地被证明过了。在任何特定的技术领域工作过6～12个月之后，你要么是精通了，要么就这样一直混下去了。不管其他程序员宣称他们有多少年的”经验”，其实都不重要，他们甚至很可能仍然对他们正在做的事情一窍不通。为什么杰出的程序员很快会变得以一定程度的厌世怀疑态度去看待他们的同事们呢？原因就在这里。也许这是唯一合理的解释，那就是经验和技能之间的背离在软件工程领域已经是相当普遍了！</p>
<p>了解了这些之后，如果你看到一家公司在它的招聘过程中还在一味地追求工作经验年数这样的神话，你还会想去这家公司工作吗？也许不会吧。</p>
<p>于是，我有了这样的一个观点：<strong>在你的招聘广告里写”要求在X平台上有Y年的工作经验”是很愚昧的！只要应聘者有6个月或1年的工作经验，那就不要再去比工作年数啦</strong>！转而去关注其他能够表现出能力差异的方面吧！平台经验只是一个基准线，它不应该成为一个至关重要的考量因素。</p>
<p>换个角度来说，如果你正在找工作，你就可以根据像”3～5年的某某技术经验”这样的招聘要求，来判断这个公司的用人之道。他们对某个特定技术领域的服务年数要求越高，就越有可能完全不知道怎么招人，因而他们组建的团队也很可能都是些平庸之辈。</p>
<p>我并不是说工作经验在软件开发方面无关紧要。恰恰相反，经验是很重要的。但是，我们得全面考量一个开发人员的经验，并且认识到，人们投入的时间并不会自动转化为技能；否则，你可能会把一些超级棒的软件工程师拒之门外，仅仅是因为他们在你要求的狭小技术领域内缺少”N年的工作经验”-这样就太可惜了！</p>
</li>
<li><p>与程序员面谈</p>
<p>在30分钟的面试时间里，你怎样才能识别出那些有潜质的软件开发者？关于这个话题，Artima Developer网站上有一篇很不错的圆桌论文，题为”How to Interview a Programmer”（怎样面试程序员）-它汇聚了很多知名程序员的建议：</p>
<ul>
<li><p>在一个专业技术领域深入试探</p>
</li>
<li><p>让他们评论一件事情（或一样东西）</p>
</li>
<li><p><strong>请他们解决一个问题</strong>（但不是回答一个谜题）</p>
</li>
<li><p><strong>查看他们的代码</strong></p>
</li>
<li><p><strong>询问他们看过什么书</strong></p>
</li>
<li><p>问一个关于人的问题</p>
</li>
<li><p>把他们招进来试用</p>
</li>
</ul>
<p>Joel Spolsky在面试程序员方面也有一些独到的见解，他的指导原则可以归纳为”人要聪明，能把事做好”：</p>
<ol>
<li><p>自我介绍</p>
</li>
<li><p><strong>针对最近的项目提问</strong></p>
</li>
<li><p>提一个难以回答的问题</p>
</li>
<li><p><strong>写几个C函数</strong></p>
</li>
<li><p><strong>给他一段代码，问他是否满意</strong></p>
</li>
<li><p>设计问题</p>
</li>
<li><p>用难题来挑战他</p>
</li>
<li><p><strong>问他有什么问题</strong></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>促使团队紧密协作</p>
<ul>
<li><p>不管怎么说，那总是人的问题</p>
<p>Bruce Eckel 巧妙地指出了所有软件开发问题的根源：</p>
<p>我们身处一个新兴产业中。很原始，真的-我们对真正有用的东西知之甚少，而且我们总是认为我们已经找到了可以解决一切问题的”银弹”。结果呢？这么多年来我们一直在经历从繁荣到萧条的轮回：新的想法出现、进一步发展、失去控制、偃旗息鼓。不过，有些理念似乎有持久力。例如，敏捷方法论里的很多理念看起来在生产力和质量方面正在产生着实质性的影响。这是因为它们更多关注了在一起工作的”人”的问题，而更少关注”技术”的问题。</p>
<p>我从Gerald Weinberg那里学到了很多。他最早写的几本书都是关于编程技术的。后来他转变了方向，撰写了（包括与人合写）50多本关于软件开发流程的书。他还有一句名言：”不管他们告诉你什么，那总是人的问题。”</p>
<p>项目的成败通常都是因为流程和人员的问题-你每天的工作方式；你的架构师、你的经理以及和你一起工作的编程团队成员；你是如何沟通的，最重要的是，当流程和人员出现问题时，你是如何解决它们的。让你陷入困境最快的方法，就是认为技术是决定性的因素，而且你相信你能轻易解决其他方面的问题。事实上，那些其他方面的问题最可能让你止步不前。</p>
<p>Bruce把Gerald Weinberg的原话记错了，它应该是”不管什么问题，那总是人的问题”。但是，Bruce的重述有一种不可言喻的真实感，当然也忠实于Gerald Weinberg原话的精神。</p>
<p>假设我现在有个任务，要去判断你的软件项目是否会失败。我手上有3个问题，当我得到你对它们的回答时，我几乎可以肯定地宣判你的项目结果：</p>
<p>1．你的团队将会写多少行代码？</p>
<p>2．你们在开发什么样的软件？</p>
<p>3．你喜欢你的同事吗？</p>
<p>最后的那一个问题不是笑话。我是在说正经的。从个人角度出发，你是否喜欢你团队成员的陪伴？你是否在专业上尊重你的团队成员？假设你换工作到了另一家公司，你是否会邀请你的同事一起过去？你们是否有令人振奋的团队讨论，还是那种打倒、拖出去，直到最后一个站着的强人说了算的争论？在你的团队里，是否有你想要”投票赶下岛”的人（如果你可以这么做的话）？</p>
<p>让你关注跟你一起工作的”人”，而不是那些实实在在的事情（例如，实际的工作或者你工作中所用的特定技术），这听起来可能有点本末倒置，但事实上并非如此。我发现，<strong>从你选择的跟你一起工作的人身上能最准确地预测工作满意度。而根据我以前的经验，工作满意度和成功有着密切的联系</strong>。我还从来没有看到过一个快乐、健康、有凝聚力、社交正常的软件开发团队失败过呢！遗憾的是，这样的团队太少了。</p>
<p>就像Gerald Weinberg所说的，那总是”人”的问题。如果你不是和你喜欢的人、你尊敬的人、会挑战和激励你的人一起工作，那你为什么不去找到这些人呢？是什么在阻止你？</p>
</li>
<li><p>领导须以身作则</p>
<p>开发团队需要遵守纪律才能从现代软件工程规范中获益。如果你的团队没有正确的工程纪律，那么你们所使用的工具和流程几乎都起不到什么作用。这一点，我已经在“Discipline Makes Strong Developers”（纪律造就强大的开发者）一文中着重论述过了。</p>
<p>有人提议，应该在团队里配备一位像枪炮士官哈特曼那样的资深训导员，以强化工程纪律。一些评论者对此表示了担忧。这也在情理之中。</p>
<p>你这个臭小子！我知道你的名字了！看我怎么收拾你！我看你还笑得出来吗？你会想哭都哭不出来的。你必须一条一条学下去。我会教你的。</p>
<p>对于软件开发者来说，以哄骗或痛斥的方式让他们服从不是一个有效的激励方法。至少在我的经验里，那行不通。<strong>如果你想提高团队的工程水平，你需要一个领导，而不是靠一个训导员去强制执行。其目标并不是给所有的同事洗脑，而是要和他们一起协商出大家都能接受的标准</strong>。</p>
<p>Dennis Forbes曾经发表过一篇文章，题目为“Effectively Integrating into Software Development Teams”（有效地融入软件开发团队）。我觉得他很出色地概括了关于有效领导方面的策略。他用一封假想的电子邮件开头（根据我对Dennis的了解，这也可能是他的亲身经历），描述了被人当作强制执行者的弊端：</p>
<p>我最近被拉去帮助一个软件开发团队完成一个产品的开发，具体的要求是协助一些Web应用程序的编码。我尽了自己最大的努力去融入这个团队，热心地帮助他们，以赢得一些信誉和尊敬。</p>
<p>我时常转发“Joel on Software”上的各种小文章给大家，还建议在公司里摆上一堆像《代码大全》、《人件》以及《人月神话》之类的书籍。不管任何事情，只要我觉得可以做得更好，我都会尽力给大家指出来。我经常浏览源代码库，以找出可以让其他成员工作得更好的方法。</p>
<p>当其他开发者来向我寻求帮助的时候，我不仅帮他们解决实际的问题，我还举一反三——指出他们在开发方式上的问题，教他们怎样改进打字形式，告诉他们该使用哪种命名规范，提倡一种更好的代码编辑工具，并且对究竟应该使用存储过程（Stored Procedure）还是动态SQL的争论给出我训练有素的最终结论。</p>
<p>然而，所有这些努力似乎都不起作用，我还是会常常受到他们的抵制，而且我觉得整个团队不是很喜欢我。我的很多建议都没有被采纳，而且我觉得有些人给我的回应是毫不掩饰的讽刺。</p>
<p>我到底哪里做错了？</p>
<p>我相信我们都曾和这样的人一起工作过。也许我们自己就是这样的人。即使你有最好的意图，并且已经熟读我给大家推荐的优秀书籍，你最终还是会落得跟枪炮士官哈特曼一样的下场：被你自己的团队“枪杀”了。</p>
<p>在文章的最后，Dennis对如何避免被你自己的团队“枪杀”做了一个很有想法的总结：</p>
<p><strong>保持谦虚</strong>。总是先假定你是错的。虽然开发者的确是会犯错误的，并且作为一个新人你理所当然应该帮助其他人发现和修正错误，但是在你骄傲地宣布你的发现之前，你应该努力确保你的观察结果是正确的。如果你老是喊着“狼来了”（慌报险情），你的信誉将遭受巨大的损失。</p>
<p><strong>提出建设性的批评时要小心。开发者更容易接受非正式的建议和具有巧妙引导性的问题，而不是把同样的内容以电子邮件的方式发送给整个开发组</strong>。扩大受众面很可能会引起开发者的防御和逆反。团队总是会去猜测你的动机。如果你贬低他们的工作是为了提升你自己，你会因此被投诉而流放的。</p>
<p><strong>要想赢得信誉和尊敬，最好的方法就是努力工作并且取得实实在在的成绩</strong>。廉价而肤浅的替代品——例如群发关于最佳实践的邮件，或者转发别人鼓吹某种“银弹”的评论——它们不会产生同样的效果，到头来你可能也只是枉费心机。</p>
<p>百说不如一干。创建一个团队博客（blog），或者一个维基（wiki），或者实施一种新的代码控制机制，或者实现一种新技术——这些事情说起来都很容易。<strong>所有人都知道，你只是在声明这些主意是你想出来的，而实现它们所需付出的艰苦努力却最终会落在别人的头上——他们会因此而讨厌你</strong>。如果你想建议些什么，你应该为此付出实际的行动、做好充分的准备。例如，展示团队博客的基本要素，包括初级的使用指南，以及所有的支撑技术。这并不能保证团队对你的倡议会一呼百应，而且你还可能徒劳无功，但团队会意识到：你是付出努力的，你在积极地推动它，而不是在试图捡便宜。</p>
<p>没有一个通用的建议可以适用于所有的情况。不是所有的应用都是大型的电子商务网站。仅仅因为那是最普遍认同的最佳实践，并不意味着它对你所加入的团队来说也是最好的设计原则。也许差得很远！</p>
</li>
<li><p>程序员与系统管理员的黑夜传说</p>
</li>
<li><p>结对编程与代码评审</p>
<p>我曾经讨论过“代码评审”（CodeReview）的功效。那是我亲身经历过的，因此我可以毫无保留地担保代码评审的价值。我忍不住想知道，是否结对编程就是打过兴奋剂的代码评审。它们之间不是一个替代另一个的关系——你当然可以两个都做——但是，我怀疑结对编程的很多好处都可以通过可靠的同级评审（PeerReview）来获得。</p>
<p>不过，代码评审也不是万能灵药，就像MartyFried指出的那样：</p>
<p>我对于代码复查的经验好坏参半。其中的一个问题是，似乎没有人愿意花时间去真正理解那些并不简单的新代码，所以反馈通常是非常笼统的。<strong>但是后来，当有人要在原有代码基础上添加功能或者修改错误的时候，他们通常会有很多的反馈（有时候他们还会怒气冲冲地想要推倒重来），但那时候可能已经太晚了，而且效果也不会理想；之前写那块代码的程序员可能也已经不在了</strong>。我觉得，代码评审或许多多少少有些好处，但要让一个程序员告诉他的老板他的程序员同伴工作很差劲就有点勉为其难了。</p>
<p>结对编程的优势就在于它的即时性：当复查者就坐在你边上的时候，忽略他是不可能的。大多数人在可以选择的情况下都会选择息事宁人。然而在结对编程中，这是不可能的。在代码被写下来的那一时刻，配对的每个人都必须立即理解代码。结对或许有点唐突，但是它能强制一定程度的交流，这是你用其他方法可能永远也做不到的。</p>
<p>另一方面，相比于把程序员的身体堆在同一个地方（这是结对编程的要求），同级评审更有灵活性（其规模可大可小）。让我们来看一看Macadamian在WINE项目中做代码评审的经历吧：</p>
<p><strong>在WINE项目中，我们采用了两个以前我们不曾用过的流程：公开的同级评审——在这个流程中，新的代码和补丁会通过一个邮件列表发送给所有参与这个项目的人；以及单一提交者——在这个流程中，项目主管对哪个补丁能被接受进入源码树有最终的决定权。</strong></p>
<p>我们很快发现，Alexandre Julliard对于代码能否进入源码树特别地挑剔——他自1994年开始就已经是WINE的维护者以及核心开发者之一了。我们团队的补丁都要经过他的仔细审查。当其中有些被驳回的时候，团队里就会有很多的抱怨：“我的代码能正常工作。这个家伙以为他是谁啊？最后期限就要到了，我们没时间了!”但是，随着项目的进展，我们意识到我们在开发有史以来最好的代码。我们写出了整洁、设计良好的代码，并且能在第一遍就通过审核进入源码树很快就成为了一种骄傲。我们同时还发现，尽管这个项目十分庞大，并且开发者散布在世界各地，我们仍然非常清楚地知道整个项目的进展状况，因为我们在邮件列表上看到了每一个补丁。我们现在在每个项目上都采用代码评审；在更大型的项目上，我们还会创建一个内部邮件列表，并且指定一位单一提交者。或许在你的公司里建立起代码评审的流程会很痛苦，而且团队里可能还会有些抱怨，但是在代码的质量以及可维护性方面你将会看到巨大的进步。</p>
<p>我认为这两种方法很明显都是“纯好事”，尽管它们都有各自的优点和不足。其中的一个就一定比另一个更有效吗？我们应该两个都做吗？</p>
<p>归根结底，我不认为这是一个二选一的问题，只要保证你有超过一双的眼睛在看你所写的代码，不管你选择用哪种方法都是可以的。当你的代码有其他人帮你复查的时候——不管那个人就坐在你边上，还是远在几千英里以外——你就会开发出更好的软件。这个我可以保证！。</p>
</li>
<li><p>会议是浪费工作时间的最佳去处</p>
<p>今天你开了多少个会？这个星期呢？这个月呢？</p>
<p>现在你再自问一下，那些会议中有多少是值得参加的？如果把相同的时间用在工作上，你又能完成多少事情？</p>
<p>这不禁让人想知道，我们究竟为什么要开会。</p>
<p>在GitHub，我们不开会。我们没有固定的工作时间，甚至都没有规定工作日。我们不记录休假或者病假的天数。我们没有经理，也没有组织结构图。我们没有着装规范。我们没有开支账户审计，也没有人力资源部门。</p>
<p>现在，我很肯定Tom（GitHub的联合创始人）在说“GitHub不开会”的时候是在开玩笑的，因为我最近去他们公司做演讲的时候，在他们的办公室里亲眼看到了会议室。谁知道呢，也许他们用那些会议室来存放多余的“叉子”。</p>
<p>尽管有些会议是不可避免的，甚至是必需的，Tom在这里倡导的原则却很重要。<strong>我们应该以怀疑的态度去看待会议，把它当成是一种降低工作效率的风险。我们举行会议是因为我们认为我们需要它们，但事实上，会议往往只是在浪费宝贵的工作时间</strong>。就我而言，我采用以下的几个原则，以确保我的会议是真正有用的：</p>
<ol>
<li><p><strong>会议绝不应该超过一个小时，否则应判以死刑</strong></p>
<p>   对于任何会议，第一个并且最重要的约束就是时间。可想而知，它在任何公司都是最宝贵的资源。<strong>如果你不能把会议限制在大约一个小时之内，那一定是有什么事情错得离谱了。你应该首先修正这个错误。可能是会议牵涉了太多的人，也可能是会议讨论的范围太宽泛了，或者就是整体上缺少一个能使会议不偏离的必要的焦点</strong> 。我不相信有人可以记住在长达几个小时的会议里发生的任何事情。当其他的一切都无法做到时，请至少把会议开得简短！</p>
</li>
<li><p><strong>每个会议都应该有一个清晰的目标声明</strong></p>
<p>   你开会要达到什么目标？你能用简洁的一句话来说明你召集会议的目的吗？我不想推荐你使用“议事日程”和“日程事项”，因为“议事日程”这个词暗示着一个巨大而乏味的分项列表——包含太多事情了！只要确保每个人都很清楚会议的目的，剩下的事自然会水到渠成。</p>
</li>
<li><p><strong>在开会之前预先做好功课</strong></p>
<p>   <strong>既然你的会议有了一个清晰的目标声明，那么每个与会者都应该提前知道了他们将要讨论和分享的内容，并且在走进会议室之前都已经做好了准备。是这样吗？只有这样，我们才能把会议控制在一个小时之内。如果你没有预先做好功课，你就不应该参加这个会议。如果没有任何人做功课，那么这个会议应该被取消</strong>。</p>
</li>
<li><p><strong>把会议变成可选的</strong></p>
<p>   “强制”的会议是站不住脚的。每一个出现在会议上的人都应该是因为他们想要在那里，或者他们需要在那里。<strong>一种让你自己对会议负责的可靠方法，就是让每个人自行决定是否要参加你的会议</strong>。想象一下举行一次大家都真正想要参加的会议，那一定是因为它……真的很有用，或者很有趣，或者很娱乐。现在就让它发生吧！</p>
</li>
<li><p><strong>在会议结束时概括一下待办事项</strong></p>
<p>   假设你的会议从未召开过，会有什么后果呢？如果你诚实地回答说“几乎没什么后果”，那么也许你的会议根本就没必要开。任何一个真正有成效的会议都会做一些决定，然后就直接导致某些事情的发生。<strong>作为一个负责任的与会者，你应该把你需要做的事情都记录下来——而且为了表明大家的责任心，会议室里的每个人最好在离开会议室之前都概括一下他们的待办事项——这样做对每个人都是有益的</strong>！</p>
<p>   我并不是说我们不应该开会，关键在于，我们必须认识到会议固有的风险，并且努力使我们必须要开的为数不多的会议开得更有效率。（但愿我们不用开太多的会！）让我们快速干活，少说废话，抓住工作的重点。</p>
</li>
</ol>
</li>
<li><p>处理坏苹果</p>
<p>Robert认为这是一个关于技术依赖的警示性故事，但我看到了另外的一些东西：一个有问题的团队成员，也就是一个典型的”坏苹果”。</p>
<p>我相信Joe曾经有过最好的意图，但是当你积极地对项目宣战并以你的团队成员为敌时，你就成了项目的一个负担。</p>
<p>问题员工对于项目的损耗是很严重的，就像Steve McConnell在《快速软件开发》一书第12章指出的那样：</p>
<p><strong>如果你容忍所有其他开发者眼里的”问题员工”（哪怕这样的员工只有一个），你就会损害优秀开发人员的士气。你在暗示着，你不仅期望你的团队成员贡献他们的全部，你还指望他们在有同事作对时也能这样做。</strong></p>
<p>在一次32个管理团队的联合评审中，Larson和LaFasto发现团队成员最一致而强烈的抱怨是，他们的团队主管不愿意直面并解决与个别团队成员表现差劲有关的问题。（Larson和LaFasto在1989年提出了这个发现。）他们在报告中指出，”如果团队主管不愿意直接并有效地处理自私的团队成员或者不作为的团队成员，这种主管给团队带来的扰乱比其他任何单一方面的团队领导力问题都要严重”。他们接着说，”这是一个重大的管理盲区，因为管理者所认为的团队运转状况几乎总是比团队成员实际认为的要更加乐观”。</p>
<p>我们应该如何识别问题员工呢？这并不像你想象的那么困难。我有一个朋友曾经把他团队中的某个人比喻成”癌症”（他原话中用的就是这个词）。当你或者团队中的任何其他人使用像”癌症”这样一个词来比喻某个团队成员时，你的项目就已经有严重的病变了。你不必和团队中的每个人都成为朋友，当然那有一定的帮助，但对个人和职业一定程度的基本尊重才是任何团队正常运转所必需的。</p>
<p>Steve McConnell列举了一些警报信号，用以识别你的团队中是否有”坏苹果”：</p>
<ol>
<li><p>他们掩饰自己的无知，而不是尽力去向他们的团队伙伴学习。他们会说：”我不知道该怎么解释我的设计。我只知道它能正常工作。”或者”我的代码太复杂了，没办法测试。”（这些可都是他们的原话。）</p>
</li>
<li><p>他们对个人隐私有着过度的渴望。他们会说：”我不需要任何人来查看我的代码。”</p>
</li>
<li><p>他们很在意自己的地盘。他们会说：”我代码里的问题没人能修复。但我现在太忙了，没时间去管它们。我打算下周处理它们。”</p>
</li>
<li><p>他们抱怨团队所做的决定，并且在团队已经继续前进了很久之后还会重拾旧题。他们会说：”我还是认为，我们应该回过头去修改我们上个月讨论的那个设计。我们当初选择的那个是行不通的。”</p>
</li>
<li><p>所有其他的团队成员都在传说关于同一个人的俏皮话或者抱怨他。软件开发人员通常不会直接抱怨，因此当你听到很多俏皮话的时候，你必须去查探是否有什么状况发生。</p>
</li>
<li><p>他们不会积极投入团队的行动。在我经历的一个项目中，就在我们第一个重要的截止日期的前两天，有个开发人员突然要求请一天假。原因是什么呢？他想那天去参加邻城的一个男装展销会-那清晰地表明他并没有融入整个团队。</p>
</li>
</ol>
<p>让我把我的观点说得清清楚楚、明明白白：如果你的团队主管或者经理没有处理项目中的”坏苹果”，那他就是玩忽职守。</p>
<p><strong>你绝不应该害怕去调动（甚至解雇）那些从内心不为团队利益考虑的人。你可以培养一个人的技能，但是你不能让他们有积极的态度。这些具有破坏性的人格在一个项目里逗留得越久，它们的影响就会越大。它们会以代码、关系和交流的形式，慢慢地把毒害传播到项目的每一个角落。</strong></p>
<p><strong>把某个人从团队中调走是很痛苦的。这件事对任何人来说都没有趣。但是，当你意识到你本应该在六个月前就把某人调走时，此时你已经更加痛苦了。</strong></p>
</li>
<li><p>坏苹果是团队的毒药</p>
</li>
</ul>
</li>
<li><p>蝙蝠的：程序员的高效工作场所</p>
<ul>
<li><p>程序员的《权利法案》</p>
<p>程序员应有的权利你都要去争取！而且记住：<strong>你可以让公司做出改变，要不然你就换一家公司</strong>。”</p>
<p>一个公司愿意付给一个开发人员6万~10万美元的薪水，却用糟糕的工作条件以及破烂的硬件设施摧残他，这对我来说是难以置信的。不管怎么说，这买卖一点都不划算。然而，我却总能看到这样的事情。这让人很震惊，竟然有这么多公司依然没有为软件开发者的成功提供必要的基础条件。</p>
<p>我提议，我们应该制定一个针对程序员的《权利法案》，以防止公司拒绝给程序员提供取得成功所必需的基础条件，最终达到保护程序员权利的目的。</p>
<ol>
<li><p>每个程序员都应该有两个显示器</p>
<p> <strong>在LCD价格跳水以及双输出的显卡如此普及的情况下，如果你还把你的开发者限制在一个屏幕上，那你一定是疯了。通过把电脑桌面双倍扩大可以获得生产力的提升，这已经被充分论证过了。如果你想把开发者的生产力发挥到极致，请确保每个开发者都有两个显示器。</strong></p>
</li>
<li><p>每个程序员都应该有一台快速的电脑</p>
<p> 程序员必须运行很多软件才能完成他们的工作：开发环境、数据库引擎、网络服务器、虚拟机，如此等等。运行所有这些软件需要一台快速的电脑，再配上很多内存。<strong>程序员的电脑越快，他们每次编译、调试的周期就越短</strong>。我不是让你当“发烧友”，花天价去购买最新、最顶级的配置——但是，你也得向高配置看齐吧。给你的开发者配备快速的、带有很多内存的电脑吧。眼巴巴地盯着进度条等待绝对是一种浪费！</p>
</li>
<li><p>每个程序员都应该自己选择鼠标和键盘</p>
<p> 在大学的时候，我经营过一个代客油漆的业务。我雇用的每一位油漆工都需要他们自己购买刷子。这是我早期积累的经验之一。将一把标准的刷子扔给一位新的油漆工是行不通的。这些“公司标配的”刷子不被爱惜，很快就会沦落到破损不堪的状况。但是，那些自己买刷子的油漆工很珍惜他们的刷子。他们懂得欣赏花20美元买来的专业刷子与那些从一元店里买来的一次性刷子之间的差别。<strong>拥有自己的刷子让他们产生一种持久的责任感和手艺人的感觉。程序员应该和他们的鼠标以及键盘保持一种相同的关系——它们是我们用来实践我们手艺的最基本的日常工具，我们应该加以善待。</strong></p>
</li>
<li><p>每个程序员都应该有一把舒适的椅子</p>
<p> 别小看这个问题！很大程度上来说，我们靠屁股每天坐上8个小时来谋生。为什么不在一把舒适的、设计优良的椅子上度过那8小时呢？要坐8个小时啊，仅仅给程序员提供勉强过得去的椅子是不够的，要让他们坐得愉悦才行！当然，你雇用程序员主要是为了他们聪明的脑袋，但是也别忘了照顾他们的其他重要部位。</p>
</li>
<li><p>每个程序员都应该能快速接入互联网</p>
<p> <strong>任何东西只要能“偷”来的，好的程序员从来不会自己去写。互联网是有史以来“偷”东西的最佳去处</strong>。我完全赞成“读万卷书”，但如果没有快速响应的互联网搜索、不能弹指间找到我想要的东西，很难想象我是否还能正常开展工作。</p>
</li>
<li><p>每个程序员都应该有安静的工作环境</p>
<p> 编程需要全神贯注。程序员在一个嘈杂的环境里是没法高效工作的。请确保你的工作环境能够保护程序员的“心流”状态，否则他们宝贵的时间将在各种干扰之下消耗殆尽。</p>
</li>
</ol>
<p>我们要求的这几个基本权利是容易办到的。这些要求并不过分，但它们对于软件开发者工作生活的质量起着关键性的作用。如果你所在的公司在这方面做得不好，那就改善一下吧，这既不需要大量的资金投入，做起来也并不难。作为程序员，你要去争取应有的权利！而且记住：<strong>你可以让公司做出改变，要不然你就换一家公司</strong>。</p>
</li>
<li><p>电脑工作站的人体工程学</p>
</li>
<li><p>多显示器能提高生产力吗</p>
<p>早在使用Windows Me的黑暗年代，我就已经热衷于多显示器了。在最近的4年里，我曾多次写文章来表达给电脑上多个显示器所带来的各种乐趣：</p>
<pre><code>* &quot;Multiple Monitors and Productivity&quot;（多显示器和生产力）

* &quot;Multiple LCDs&quot;（多个液晶显示器）

* &quot;Joining The Prestigious Three Monitor Club&quot;（加入享有盛名的三显示器俱乐部）

* &quot;The Large Display Paradox&quot;（大显示器的悖论）

* &quot;LCD Monitor Arms&quot;（液晶显示器支架）
</code></pre>
</li>
<li><p>购置优质的电脑椅</p>
<p>待补充……</p>
</li>
<li><p>背景光的功效</p>
<p>待补充……</p>
</li>
</ul>
</li>
<li><p>设计时要把用户放在心上</p>
<ul>
<li><p>你永远不会有足够的奶酪</p>
<p>我们也许会认为自己的应用程序很吸引人，但它们在用户眼里真的那么有吸引力吗？我表示高度的怀疑。除非你给用户提供免费的mp3音乐，或者给他们看色情图片，否则你不太可能有足够的奶酪让人愿意去克服哪怕是最微弱的电击。你能控制的惟一可变因素只有你的应用程序的可用性。只有让进入的门槛低到荒唐的程度，才能让人们稍微去看一看你的软件——更别提有多少人会去使用它了。</p>
<p>Joel Spolsky也曾说起过这样的事：</p>
<p>这里有一个可怕的事实——至少会让用户界面专业人员提心吊胆：<strong>一个应用程序如果可以把人们真正想要的东西做得非常好，那么它即使不是很好用，它仍然会获得成功。反之，一个应用程序即便是世界上最容易使用的，但如果它不能做任何人想要的任何事，那它一定会失败</strong>。因为可用性被普遍认为是“可选的”——这就是那可怕的事，而且在很多情况下，它确实是可选的——于是，用户界面咨询顾问们不得不忙着为自己辩护，他们整出了一个难以令人信服的投资回报率（Return On Investment，简称ROI）公式，用以精确计算客户为可用性项目付出的75000美元投资会获得多少回报。在很多情况下，可用性的确是可选的。CNN网站就不会从可用性咨询中得到任何收获。</p>
<p>Napster和ICQ在用户界面方面绝对惨不忍睹。但这完全没有关系。他们贡献给世界的东西是那么引人入胜，而且（在那个时期）没有足够的竞争，以致于那些开发者并没有为糟糕的用户界面付出沉重的代价。</p>
<p>美味的奶酪是一种稀有的奢侈品；大多数致力于标准商业应用的开发者都不应该奢望这种东西。比如一个文件管理系统，用户要疯狂到什么程度才会对它充满期待呢？要让用户真正地使用你的软件，如果你对此还有一丝希望的话，忘掉奶酪吧——确保你不会“电击”你的用户。</p>
</li>
<li><p>细节决定成败</p>
<p>待补充……</p>
</li>
<li><p>用户界面代表了软件</p>
</li>
<li><p>用户界面须优先设计</p>
</li>
<li><p>分页显示该休矣</p>
</li>
<li><p>对待弱视的用户</p>
</li>
<li><p>在谈浏览器底栏</p>
</li>
<li><p>费茨定律与无限宽度</p>
</li>
<li><p>单元测试的终极失败</p>
</li>
<li><p>第一版做得不好，但照样发布</p>
<p>我曾经发布过的软件中没有一个能让我满意的。哪怕一个也没有！部分的原因是，像很多其他的软件开发者一样，我是一个完美主义者。于是，有些问题就不可避免了：</p>
<pre><code>* **开发计划太激进，时间太短了。我们需要更多的时间！**

* **我们碰到了原先没有预料到的技术问题，它逼着我们做了一个折中的解决方案。**

* **我们的设计做错了，不得不在开发的过程中做出改变。**

* **我们的团队出人意料地发生了内部摩擦。**

* **客户跟我们想象中的不一样。**

* **设计师、开发者和项目管理团队之间的沟通效率没有我们想象中的那么高。**

* **我们高估了自己学习新技术的能力。**

* **这个清单还可以继续往下写。软件项目失败的原因真是数不胜数！**
</code></pre>
<p>在项目启动的时候，你憧憬着你的软件会成为软件工程历史上一座光彩夺目的丰碑。然而在开发周期结束的时候，你最终做出来的却只是那座丰碑的暗淡的影子。</p>
<p>看到这，你也许想要认输了——往开发计划里增加更多的时间，这样你就能在软件发布之前把它做得更好。毕竟，软件的发布还得靠那些开发人员。</p>
<p>在这里我要告诉你，这种做法是错误的。</p>
<p>没错，你在这个项目里把很多很多东西都做砸了。但是，你还把很多很多你尚且不知道的东西做砸了。除非你把软件发布出去、送到用户和客户的面前，否则你无法知道那些做砸的东西到底是什么。我觉得，用DonaldRumsfeld的那首诗来说明这个问题再好不过了：</p>
<pre><code>我们知道，

有一些已知的知道。

有些东西我们知道我们知道。

我们也知道，

有一些已知的未知。

也就是说，

我们知道有些东西我们不知道。

但还有些未知的未知，

就是那些我们不知道我们不知道的东西。
</code></pre>
<p>在项目的收尾阶段面对那些无法避免的忧郁——在枪口之下妥协，还有很多令人不安的权宜之计、欠考虑的解决方案——你可能会蹲下来，默默地舔着你的伤口。你也可能重整队伍，在将软件发布之前另外再花上几个月的时间去修复那些问题。你可能还会自我感觉良好，因为你做了一个艰难的决定：你及时阻止了向全世界发布又一个错误百出的半成品软件，确保了软件工程的质量。</p>
<p>不幸的是，跟发布带有缺陷的版本比较起来，这是一个更大的错误。</p>
<p><strong>与其在与世隔绝的实验室里花上3个月的时间无聊地修复第一版里的问题，你不如把这3个月的时间用于倾听来自真实世界里使用你的软件的用户提出的反馈，尽管他们很烦人，但他们很虔诚、很专注。别把时间花在你想象中的软件上。也别去想象你的用户。他们存在于真实世界里。你可以转过身去，利用来自于真实世界的定向反馈，不仅可以修复第一版里所有做得很差劲的部分，而且可以根据确凿的用户使用数据做出预测，从而能够让你把开发经费花得更有效益。</strong></p>
<p>别误会，我不是说你应该发布像狗屎一样的东西。相信我，我们都是完美主义者。但现实是残酷的，它容不下我们的完美主义。理智一些吧，抛开完美主义；要认识到，当你的软件在真实世界里的岩岸上崩溃的时候，让人失望是难免的，但那是可以弥补的！重要的不是软件的初始状态有多么完美——事实上，有人认为，“如果你没有被你的第一版软件搞得局促不安，那说明你还发布得不够早”——重要的是，你在把软件发布之后都做了些什么？</p>
<p>你的团队对用户反馈的响应速度会为你的软件定下基调，这是任何一次软件发布都不能起到的作用。那才是你真正需要去提高的方面。<strong>不要再沉迷于柏拉图式的理想（发布一款神话中的完美软件），而应该对你的用户和客户做出及时的响应，并且通过基于他们的反馈持续改进和完善你的软件来展示你对他们的诚意。至于说你在为一个接近完美的软件发布而努力，你实际上在为一个错误的目标而浪费精力。</strong></p>
<p><strong>只要有可能的话，请尽早发布你的软件。然后把剩下的时间都用在基于真实世界的反馈进行的快速迭代开发上</strong>。不管你预算的时间有多少，你终将做出更好的软件来。这是毋庸置疑的！</p>
<p>请你相信我：<strong>即使第一版做得很差劲，坚持把它发布出去</strong>。</p>
</li>
</ul>
</li>
<li><p>安全数据：保护用户数据</p>
<ul>
<li><p>所有网络通信都应该加密吗</p>
</li>
<li><p>防范字典式攻击</p>
</li>
<li><p>快速哈希</p>
</li>
<li><p>关于网络密码的可怕真相</p>
</li>
</ul>
</li>
<li><p>第9章 加强代码测试，别让它太差劲</p>
<ul>
<li><p>与客户患难与共</p>
</li>
<li><p>结交“混世魔猴”</p>
</li>
<li><p>代码评审：说做就做</p>
<p>在“The Soft Side of Peer Reviews”（同级评审的柔软面）一文中，Karl Wiegers以下面这段高调的声明开篇：</p>
<p>同级评审——软件交付物原作者以外的其他人帮忙检查缺陷、促进提升的一种活动——是最有效的提高软件质量的工具之一。同级评审的方法包括审查、走查、同级桌查、以及其他类似的活动。在从同级评审中受益了将近15年之后，我绝不再愿意在一个不做同级评审的团队里工作。</p>
<p>在Vertigo公司参与了一段时间的代码评审之后，我坚信，<strong>同级之间的代码评审是你为提高代码质量所能做的最大的贡献</strong>。如果你现在还没有跟另外一个开发人员开展代码评审活动的话，你实际上正在放纵大量的Bug留在你的代码里，也使自己错失了一些关键的职业技能发展的契机。就我个人而言，在我找到一位同事帮我检查完代码之前，我不会认为我已经完成了编码。</p>
<p>不过，我说的话你可能不信。McConnell在《代码大全》（Code Complete）一书里为代码评审的功效提供了大量的证据，摘录如下：</p>
<p>……孤立的软件测试功效有限——在平均缺陷发现率方面，单元测试只能达到25%，功能测试可以达到35%，而集成测试也只能达到45%。相比之下，设计和代码审查的平均功效可以达到55%和60%。评审结果的案例研究非常鼓舞人心：</p>
<pre><code>* 在一个软件维护的组织里，在引入代码评审之前，55%的单行维护代码改动都是错误的。在引入评审之后，错误率降到了2%。如果考量所有的代码改动，在评审引入之后，95%的代码改动第一次提交的时候就对了；而在评审引入之前，首次代码提交的正确率低于20%。

* 在一个软件开发的组织里，由同一批人开发11个程序，前5个在开发过程中不做评审，后6个做评审。在所有的程序都正式发布之后，前5个程序平均每100行代码有4.5个错误，而后6个程序平均每100行代码只有0.82个错误。代码评审可以消除80%以上的错误。

* 安泰保险公司通过代码审查发现了程序里82%的错误，他们因此能够减少20%的开发资源投入。

* IBM的Orbit项目（500000行代码）使用了11级的审查。软件提前交付了，错误率只有大概1%（这个比率通常是可以接受的）。

* AT&amp;T内部一个200人的组织报告称，在他们引入代码审查之后，生产率提升了14%，而软件缺陷降低了90%。

* 美国国家航空航天局下属的喷气推进实验室估计，在早期阶段发现并修复缺陷所节省的成本，按照审查次数折算下来，每次审查可以省下大概25000美元。
</code></pre>
<p><strong>代码评审的惟一障碍是找到一位你尊敬的开发人员，然后留出专门的时间来做这件事</strong>。一旦你开始这么做了，我相信你会很快发现，你在代码评审中花的每一分钟都会得到十倍的回报！</p>
<p>如果你所在的公司或组织刚刚开始做代码评审，我强烈推荐Karl的这本书：《软件同级评审》（Peer Reviews inSoftware: A Practical Guide）。Karl在他的网站上提供的样章也不失为一份极好的入门资料。</p>
</li>
<li><p>加大测试力度</p>
</li>
<li><p>我同情那些不写单元测试的傻瓜</p>
<p>J.Timothy King写了一篇很棒的文章：“先写单元测试的12个好处”（Twelve Benefits of Writing Unit Tests First）。遗憾的是，他在文章最后说的话完全是画蛇添足。</p>
<p>然而，如果你不愿意改掉先写代码的老习惯，如果你觉得固执己见比设计优秀的软件更重要，好吧，我对你深表同情。</p>
<p>把你的怜悯用在不认同你的人身上，并不是推广你主张的最有效的方式。</p>
<p>看看T先生的例子吧。他从1980年代初开始怜悯傻瓜，但迄今为止，“愚蠢”在这个世界仍然是随处可见。</p>
<p>J.Timothy King有点弄巧成拙了，因为关于单元测试的主张是很重要的。单元测试的普遍接受，已经成为过去5~7年里软件开发领域里最大的进步之一！</p>
<p>你是怎样解决一个软件问题的？在学校里老师教过你吗？你首先会做什么？你在开始解决问题的时候，会问，“我要写什么代码来解决这个问题呢？”但其实这是后面的问题。你最先要问的问题不是“我要写什么代码”，而是“我怎样才能确认我的方法解决了那个问题？”</p>
<p>在我们接受的教育里存在一个假设，就是我们已经知道如何去判断我们的解决方案是否奏效。这根本就不是问题。就比如下流行为，我们看到的时候也就知道了。关于代码需要去做什么事，我们相信也没必要在写代码之前去思考一下。这种信仰已经根深蒂固，对于大部分人来说，这是很难改变的！</p>
<p>J.Timothy King罗列了12个具体的方法，来帮助大家接受“测试先行”的观念（这种方法已经帮助他写出了更为出色的代码）：</p>
<ol>
<li><p><strong>单元测试可以证明你的代码是能真正解决问题的</strong></p>
</li>
<li><p>你可以获得一个底层模块的回归测试工具</p>
</li>
<li><p>你可以在不破坏现有功能的基础上持续改进设计</p>
</li>
<li><p>一边写单元测试，一边写实现代码，这种工作方式更有乐趣</p>
</li>
<li><p><strong>它们可以用来真实地展示开发进度</strong></p>
</li>
<li><p><strong>单元测试可以用作为演示代码</strong></p>
</li>
<li><p><strong>它逼着你在写代码之前做好计划</strong></p>
</li>
<li><p>它降低Bug修复的成本</p>
</li>
<li><p><strong>单元测试甚至比代码审查的效果还要好</strong></p>
</li>
<li><p>它实际上为程序员消除了工作上的障碍</p>
</li>
<li><p>单元测试促成更好的设计</p>
</li>
<li><p>它比不写单元测试而直接写代码的效率更高</p>
</li>
</ol>
<p>上面这个列表里，即使你只认同3~4个——根据我的经验，至少一半以上是正确的——对于软件开发者来说也是一个巨大的进步。关于单元测试的重要性，我绝对没有不同意见。恰恰相反，我越来越相信，单元测试是如此之重要，以致于它应该成为第一类的语言构建（像类、方法、事件等一样）。</p>
<p>然而，我觉得“测试先行”（或者说“测试驱动”）的倡导者太专注在他们自己的立场上，有点急于求成了。要求开发人员一夜之间彻底改变他们开发软件的方式是很过分的。特别是，有些开发人员还从来没有写过单元测试。对于任何软件开发组织来说，如果他们还没有把单元测试采纳为每一个软件项目的标准方法，那我也不认为他们具备了采用“测试驱动”开发方法的条件。</p>
<p>对“测试驱动”的过度推崇和膜拜，可能使得软件开发人员对单元测试的整个概念都产生怀疑和厌恶。</p>
<p>要真是那样，就很可惜了！因为关于软件测试，测总比不测好。我们对随机测试（Ad-hoctesting）的概念很熟悉，其实单元测试也就是一种更为正式一点的随机测试，难道不是吗？我觉得Fowler有段话说得非常好：</p>
<p><strong>你想把某些信息打印到屏幕或输出给调试器的任何时候，你都应该把它改写成一个单元测试。</strong></p>
<p>我希望开发人员能够认识到单元测试的价值。我力劝他们在编写功能代码的时候，也养成编写结构化测试代码的习惯。观念改变一点点，可能最终会促成更大的飞跃，就比如测试驱动开发——但是，在开始跑之前，你必须先学会爬！</p>
</li>
<li><p>单元测试与Beta测试的对比</p>
</li>
<li><p>低保真的可用性测试</p>
<p>牛人，给你来个突击测验：你怎么知道你的应用程序能够正常工作？当然，也许你的程序通过了编译。也许它通过了所有的单元测试。也许它还成功通过了QA的严酷考验。也许它被成功部署到了一个正式的服务器，或者被打包成了一个安装程序。也许连Beta测试人员都签字认可了。</p>
<p>然而，所有这些都不能说明你的程序能够正常工作。</p>
<p>用户真的能理解你的应用程序吗？他们能够使用你的程序去完成他们的工作吗？这才是“能工作的应用程序”的定义。我在第一段罗列的所有东西都算不上什么。<strong>实际上，如果你不找来真正的用户做可用性测试（Usability Testing）的话，你是无法知道你的程序能否正常工作的！</strong></p>
<p>你会定期给你的应用程序做可用性测试吗？</p>
<p>你应该去做！这就是我的观点。Steve Krug有本书叫《Don’t Make Me Think》，其中有个中心思想就是：可用性测试对于任何软件项目来说都是必需的。Krug有个简单易行的方法来做可用性测试，他称之为“跳楼大减价”的可用性测试。</p>
<p>可用性测试已经存在很长一段时间了。它的基本理念很简单：如果你想知道你的软件、网站或VCR的遥控器是否容易使用，那么在一些人尝试使用它的时候观察他们，记下他们在哪里碰到了问题，然后修正这些问题，之后再度测试。</p>
<p>不过，在最开始的时候，可用性测试的花费非常昂贵。你需要建立一个可用性实验室，它带有一间位于单向玻璃后面的观察室；至少要有两部摄像机，分别录制用户的反应和他们正在使用的东西。此外，你还得招募大量的测试用户，以得到具有统计意义的结果。这是科学研究。每次测试需要花费2~5万美元。因此这种活动不会经常发生。</p>
<p>但是在1989年，Jakob Nielsen写了一篇题为“Usability Engineering at a Discount”（打折的可用性工程）的论文。他指出，可用性测试不是非得那样做不可。你可以不需要可用性实验室，而且就算测试用户减少很多，也能得到同样的结果。这个想法是一个巨大的进步！惟一的问题是，10年以后的人们仍然觉得可用性测试不便宜，聘请一个人主持一次测试仍然得花上5000〜15000美元。结果呢？虽说可用性测试比以前发生得多了，但还是不够频繁。</p>
<p>在这一章里，我要介绍的方法将会更加激进，这就是我们所说的“跳楼大减价”可用性测试。我将教你在你没有时间且预算不足的情况下，如何自己进行测试。当然，如果你有能力去请专家进行测试的话，那就去请吧。但如果这样破费会减少你的测试次数，那你还是别请了。</p>
<p>Krug指出，除非你对可用性测试有抵触情绪，否则它不难！即使只请一个人来做可用性测试，你多多少少总能得到一些有用的结果，比如下面的情况：</p>
<p>可用性测试总是会有效果的，哪怕对不合适的用户做一次最糟糕的测试，也会让你看到网站的一些需要改进的地方。我喜欢在每次研习班上做一次现场用户测试；通过这种方式，人们会认识到测试其实很容易做，而且经常能产生许多有价值的看法。我会在班上找一位志愿者，请他在某个其他同学的网站上执行一项任务。这样的测试不会超过10分钟，但被测试网站的主人通常会迅速记上好几页的笔记。他们还会询问是否可以对测试过程录像，以便他们带回去给开发团队看。（曾经有人告诉我，他的团队看过录像后对网站进行了一项改进，后来他们算了一下，这项改进帮他们节省了10万美元！）</p>
<p>如果你想看到更多的证据，来证明不需要很多用户也能进行有效的可用性测试，那就来看看Jakob Neilsen提供的这张图吧：</p>
<p>显而易见，完全不做可用性测试是一场灾难。但还有一点不是那么显而易见的是，只有少许几个人进行的可用性测试也能相当有效。而且，如果你遵循Krug给出的指导原则，你的低保真（Low-Fi）可用性测试会进行得更加顺利：</p>
<pre><code>* 我该在什么时候测试？理想情况下，一个月一次。在整个开发过程中，你应该持续不断地做小型的可用性测试。这些测试应该很简单，持续时间较短，以便于你随时都可以开展，而不用提前花时间去做计划。

* **我需要找多少用户？3个，或者顶多4个。**

* **要找什么样的用户**？随机抓一些人。只要会用电脑就行。一个不为人知的秘密是，可用性测试找谁测其实无关紧要。**尽管找到具有代表性的用户会更好，但早点测、经常测要重要得多**。别不好意思，不要放过你的朋友和邻居。

* **测试要持续多长时间？每个用户花45分钟到1个小时。尽量保持简单。让测试的范围小一点**。不管怎么说，哪怕做最简单的可用性测试，它还是会占用额外的时间。但从长远来说，它还是为你节省时间的。可用性测试的结果可以让你幸免于无休止的争论，或者避免在项目的收尾阶段大量返工。

* 在哪里测试？任何办公室或者会议室。你所需要的只是一个房间、一张桌子、一台电脑和两把椅子，并且不受别人的干扰。

* **测试人员应该具备什么特质？任何有点耐心的人都可以。这个人要有耐心，还要冷静、感性并且善于倾听。只要稍微训练一下，大部分人都能胜任做一个测试人员。**

* **我需要什么设备？你只需要一个屏幕录制软件（比如Camtasia）。如果想要录制的效果更好一点，你可以用一个便携式摄像机把人和屏幕都录下来。**

* **我要为测试做什么准备？想好你想要展示的东西。草拟一些步骤和说明，以引导参与者如何开始测试。**

* 测试需要花多少钱？如果不算主持人的时间，给每个用户50~100美元津贴。

* **我们应该怎样解读测试的结果？在当天的午饭时间，向开发团队和任何感兴趣的干系人汇报。可用性测试最大的好处之一，就是测试结果在所有人面前都是一目了然的。任何严重的问题都难以被遗漏！**
</code></pre>
<p>如果你还没买《Don’t Make Me Think》这本书，那你就太落伍了！赶紧去买吧！在等待送货期间，我强烈建议你下载该书的第9章先看看（下载地址为<a target="_blank" rel="noopener" href="http://sensible.com/Downloads/DMMTchapter09_for_personal_use_only.pdf">http://sensible.com/Downloads/DMMTchapter09_for_personal_use_only.pdf</a>）。我前面只是初略地介绍了一下，如果你想知道更多的细节，还是去看书吧。</p>
<p><strong>可用性测试没必要做得很复杂。如果你真的想知道你正在做的东西是否对路，邀请一些人来使用它吧，并且你待在旁边仔细观察。没别的，也就是从会计部把Joe抓过来，从市场部把Sue抓过来；只要不是直接参与这个项目的，附近的人随便抓，然后请他们使用你做的东西。不要告诉他们做什么。给他们指定一个任务，然后提醒他们，在他们动手做的同时把心里的想法都说出来。而你只需要静静地坐在后面，仔细观察</strong>。根据我个人的经验，我可以告诉你，结果往往是令人惊讶的。</p>
<p>可用性测试的好处是毋庸置疑的。你尽管去做吧，这样才能真正体会到那些好处！</p>
</li>
<li><p>比程序崩溃更糟糕的时什么</p>
</li>
</ul>
</li>
<li><p>第10章 创建并管理社区，同时从中受益</p>
<ul>
<li><p>倾听社区的声音，但别被他们牵着鼻子走</p>
<p>大家都知道，面试官是多么热衷于问这样的问题，“你最大的弱点是什么？”“你曾经犯过最大的错误是什么？”这些问题听起来可能都是公式化的，甚至都是些陈词滥调，但是你在回答的时候可要小心了：它们貌似无足轻重，其实不然！</p>
<p>如果有人问我，“在创办Stack Overflow网站的过程中你犯过最大的错误什么”，我会很坦然，因为我不用费尽心思地去寻找答案。我可以很诚实地告诉大家，我在开发Stack Overflow的第一天就犯了个天大的、非常荒唐的错误，而且我还固执地坚持了整整9个月，完全不顾社区里此起彼伏的抗议。我越陷越深，甚至还写了一篇长长的博客去驳斥。</p>
<p>长久以来，我一直有一种很可怕的“搏击俱乐部”式的观念：“Stack Overflow网站的第一条规则，就是你别对Stack Overflow说三道四！”毕竟，大家上这个网站来是为了找到志同道合的人一起学习编程，而不是讨论一个做得很傻的网站。是这样吗？</p>
<p>我没有意识到大家对“元”（meta）的需要。</p>
<p>所谓“元”，就是一个大家讨论自身所处之地的地方。听起来很费解吧，但是其含义值得我们好好想想。“元”是给那些深切关注社区、也愿意更进一步做出贡献、组织起来并费尽心思去研究怎样维持和管理社区的人的。所以，我很懊悔！我当初的所作所为，实际上是在告诉那些热爱Stack Overflow的人们：“滚一边去！”</p>
<p>回想起来，我真是羞愧难当！</p>
<p>在社区的不断刺激之下，也在我反复的防守还击过程中，很庆幸，我最终醒悟了。尽管我们在一开始的测试阶段用了一个第三方的“元”站点，但在公测后的10个月，也就是2009年6月最终发布的时候，我们还是用了自己的域名：meta.stackoverflow。同样的错误绝不再犯第二次，在我们后来做Stack Exchange的时候就注意了——我们为每一个上线的Stack Exchange子网站从一开始就配备了一个“元”。我们现在知道了，“元”的参与是社区有序领导和治理的源泉，我们须培养它，也因此要加以密切的监控。</p>
<p>为了“赎罪”，我也成为了我们自己“元”的顶级用户。在过去的2年又7个月的时间里，我将自己埋身在成堆的bug、功能需求和各种讨论中，而支持所有这些的就是我们的“元”。从我的用户账号概况里可以看出，在那段时间里，我有901天都泡在“元”里，其实差不多也就是每天都在了！我以自己对“元”的参与度而感到骄傲，好比是得了一块勋章，而更重要的是，我认识到了我们应该围绕着用户开展工作。我们在Stack Exchange上所做的任何一件事都是特意公开的——这跟象牙塔式的开发模式完全是对立的。</p>
<p>这一路走过来，在开发社区软件和处理社区反馈方面，我学到了不少的经验和教训。现总结如下：</p>
<ol>
<li><p><strong>90%的社区反馈都是垃圾</strong></p>
<p> 让我们现在就承认吧！在这方面，“史特金定律”是不可能被任何人否定的，无论你是男人、女人、孩子，还是一个社区。“元”社区，我爱死你了；正因为如此，让我们彼此坦诚相待吧：<strong>你们提出的大部分反馈和功能需求，其实没有任何可操作性</strong>……需要的话，我可以说出一万条理由。</p>
<p> 且慢，别忽略了要点：这也意味着，有另外10%的社区反馈是非常棒的！假如你有毅力看上上百条帖子，我保证你会发现其中有10条的含金量很高，而就是它们能让你的网站得到明显的提升。做好准备吧，若想从一大堆社区反馈里挖掘出“宝石”，你需要花很多时间，而且这时间还不是一般的多！我坚信，每个社区总会有一些足够聪明的人来制造一定数量的“宝石”，他们常常让你喜出望外。</p>
</li>
<li><p><strong>别抵挡不住诱惑而误入歧途</strong></p>
<p> 当你收到反馈和功能需求的时候，你应该立即把它们分成两大类：</p>
<p> 我们需要给这辆轿车安上电动窗！</p>
<p> 或者</p>
<p> 我们需要给这辆轿车加个货车车厢！</p>
<p> 显而易见，前者只是给轿车增加一个合理的配件，而后者试图改变车辆的基本特性。<strong>软件本身固有的“易于修改的特性”，使得增加功能变得很诱人，但这有时候无异于给轿车加上一个货车车厢</strong>。为什么不这么做呢？用户们会不断地反问你。货车多方便呀！真的是这样吗？</p>
<p> 别掉进陷阱！牢记你当初的使命。轿车加货车的混合体对于很多人来说都很有吸引力，但是这很可怕，你会最终做出一辆像斯巴鲁Brat一样的车。除非你真的想要做出一辆货车来，否则，如果用户提出想要货车这样的功能，你最好大方地把他们带到附近的货车经销商那里，因为他们似乎来错了地方。</p>
</li>
<li><p><strong>坦诚地说出你不想做的事</strong></p>
<p> 当看到bug跟踪系统里或反馈论坛里有成千上万条记录无人问津时，我总是很沮丧。这是社区疏于治理的信号，更为糟糕的是，它折射出了社区里一种信赖缺失的关系。这很常见，也很可悲。千万别搞成这样！</p>
<p> 尽管很多时候来自社区的反馈是令人讨厌的，但我并不建议你把对他们的厌恶之情赤裸裸地表现出来。那样只会显得你很卑劣。但当你觉得他们提出的请求没有道理，或者你无法在一个合理的范畴内将它们实现的时候，请你不要羞于“礼貌地”拒绝他们。（当然，你应该总是保留将来改变主意的权力。）毫无疑问，被人拒绝是很伤心的，但被人忽略让人尤其心灰意冷。我非常非常坚定地相信，只要你对你的社区待之以诚，他们最终会因此而更加敬重你。</p>
<p> 所有的关系都是基于诚实的。如果你不愿意诚实地对待你的社区，你凭什么要求他们来尊敬你呢？他们最终会离你而去……</p>
</li>
<li><p><strong>倾听社区的声音，但别被他们牵着鼻子走</strong></p>
<p> 把“元”社区里的需求一股脑儿地吸收进你的软件或者网站中加以实现，这么做看起来很不错。“元”的出发点是倾听来自社区的声音，然后根据社区反馈采取相应的行动，对吗？遗憾的是，如果你过于直接地对社区反馈采取行动，那是非常危险的，它也是很多社区失败的原因。让我们一起来看看GitHub的联合创始人Tom Preston-Werner是怎么解释的吧：</p>
<p> 我们来看一个这样的需求：“GitHub应该允许我用FTP的方式把我项目里的一个文档站点上传上去。”其实，这个客户真正想说的是：<strong>“我想要一个简单的方法来发布与我项目相关的内容。”只是他们早已经习惯了现有的东西，所以他们必然以他们熟悉的术语来表达他们的需求。我们本可以按照他们要求的那样，实现一个糟糕的基于FTP的解决方案。然而，经过我们深入研究之后，我们发现了问题的根本，最终的解决方案是：允许用户通过往账号里加一个Git仓库来实现内容发布。这种做法既满足了功能需求，又不失优雅，堪称完美。</strong></p>
<p> 社区反馈是美妙的，但它的作用绝不应该被夸大并滥用，它不能代替你去深刻反思你要做的东西以及你为什么要这样做。<strong>花点功夫去挖掘潜在的真正需求吧，然后制定出一个合理的产品路线图。</strong></p>
</li>
<li><p>参与并支持你的社区</p>
<p> 大概有一半的社区关系都不尽如人意，他们并不在恪守承诺地做着社区认为他们应该做的事情。即便这样，建议你还是要去积极参与社区，去倾听，去回应。当Stack Exchange的联合创始人回复你在“元”里的发帖时，即使他的回复不能完全达到你的期望，我希望你也能理解，他的行动足以证明了我们对社区的承诺，那就是我们始终跟社区在一起并肩作战。</p>
<p> 不管你现在缺不缺钱用，你都应该热衷到“元”里的社区反馈或bug报告里挖掘出稀有的“宝石”。这些“宝石”能让你的网站或产品更加出色。你应该义无反顾地这么去做，以促成公众反馈的良性循环：“你所关心的就是我们所关注的，所有事情都在朝着一个好的方向持续得到改进。”</p>
<p> 这就是社区的真谛！难道不是吗？</p>
</li>
</ol>
</li>
<li><p>我重申：别盲目听从你的用户</p>
<p>关于倾听用户，Paul Buchheit是这么说的：</p>
<p>我用了一天的时间就做出了第一版的Gmail。它一开始并不起眼。我所做的，也不过是把我所有的邮件放进Google组（Usenet）的索引引擎里。我把它发给几个人看了，他们评价说这还是挺有用的，但如果除了我的邮件之外也能搜他们的邮件，那就更好了。于是我开发了第二版。在将第二版发布之后，人们开始想要回复邮件的功能。于是我开发了第三版……在Gmail正式面世之前，这个过程实际上在Google内部持续了好几年！</p>
<p>一般创业公司不太会有成千上万那么多的内部用户。因此，把产品尽早公开发布出去是很重要的。当FriendFeed在10月份准发布（内部测试）的时候，这个产品其实才开发了大概两个月（而且99.9%的代码是由Bret和Jim两个人写的）。从那以后，我们做了大量的改进。试想如果我们当初没有提前发布，可以肯定的是，我们最终做出来的产品绝对不会像现在这么好。什么原因呢？因为我们找到了用户，而且我们倾听来自他们的反馈，我们很清楚地知道我们的产品哪方面做得好以及哪方面做得不好。</p>
<p>倾听用户是一件很微妙的事情。<strong>用户常常不知道他们想要什么，即使知道，他们也未必能够说得清楚</strong>。沟通永远是个问题。但不管怎么样，你都不能忽视用户。大部分人在发现你的软件或网站满足不了他们的需要时，都只是静静地走开，而且永远不会回头。因此，那些热心给出反馈的用户值得你去注意和尊敬。他们很积极，以帮助你设计产品为己任。如果你不认真倾听，并且有礼貌地回应所有的用户反馈，那你注定会失败。</p>
<p>拒绝倾听用户是很不明智的。然而，我们给“可用性”设定的第一条规则是“不要听从用户”，这不是自相矛盾吗？</p>
<p>如果想知道哪个设计方案更好，只须用户在操作界面上尝试去完成他们的任务时，你在一旁仔细观察。这个方法是如此之简单，以致于很多人都熟视无睹。他们不敢相信，认为可用性测试一定还有其他更为高深的东西。然而，这里面究竟有哪些基本原则呢？我把它们归结如下：</p>
<pre><code>* 观察人们的实际做法；

* 不要相信人们说的他们做了什么；

* 绝对不要相信人们预想的他们将来可能会做什么。
</code></pre>
<p>我是认同Paul的，但他的话容易让人误解。Paul曾在一篇文章里说过相关的这么一段话，“我们心里很清楚什么东西在正常工作”，它实际上暗示了“衡量”和“关联”两个要素。如果你的产品能够产生详细的日志来记录用户的实际操作，那么就没必要当面去观察他们了（尽管你去当面观察也无妨）。在你收集了用户的反馈之后，要把它们跟记录那些用户实际操作的数据关联起来。</p>
<p><strong>不要单纯地实现来自“用户代表”或者“业务分析师”的功能需求。把可用性搞砸最常见的做法，就是只听用户说的，而不去看他们真正做的。需求说明书里定义的常常都是错误的。你必须快速地把需求转变成原型程序，然后将具体的东西展示给用户，以确认那是否就是他们真正想要的。</strong></p>
<p>仅凭用户反馈就采取行动是有问题的。哪怕你出于多么美好的意图去猜测。如果你能根据“白纸黑字”一样可靠的数据而采取行动，为啥还要靠猜呢？<strong>把用户反馈和详细的使用数据结合起来，然后再去对你的应用程序或网站采取必要的改进措施，这才是正确的做法。</strong></p>
</li>
<li><p>游戏化</p>
</li>
<li><p>暂停，禁止，或者打入地狱</p>
</li>
</ul>
</li>
<li><p>轻重缓急，了然于心</p>
<ul>
<li><p>程序员，你幸福吗？</p>
<p>科学家们喜欢标新立异，抛出了这样的一个观点：钱是可以买到幸福的。从一定程度上来说，他们是对的！</p>
<p>近期的研究已经开始区分主观幸福的两个方面：情绪上的幸福感和对生活的看法。前者是指一个人每天经历的情绪的质量，具体包括快乐、压力、悲伤、愤怒以及其他让人开心或不开心的感情的频率和强度。后者是指人们在审视他们的生活时所持的看法。钱到底能不能买到幸福呢？我们对以上两个方面分别做了评估—盖洛普公司做了一个关于“幸福指数”的民意调查，每天都有1000名美国人参与。在分析了超过45万份问卷结果之后，我们得出了这样一个报告：如果以收入的对数作为参考坐标，人们对生活的看法随着收入的提高在稳步提升，而情绪上的幸福感也在提升，只不过当年收入超过7.5万美元的时候幸福感就停滞不前了。</p>
<p>这里还有一个数字可供大家参考：美国联邦政府当前公布的四口之家的贫困线标准是23050美元。也就是说，一旦你的收入超过了贫困线的3倍多一点之后，你就已经得到了最大的幸福，至少钱本身能给你带来的幸福就那么多。</p>
<p>上面的结论在很多研究资料里都得到了印证。一旦你拥有了“足够的”金钱去满足“马斯洛需求层次理论”金字塔最底部的基本需求之后—也就是说，你不再需要为食物、住所、安全而担心，甚至还有一点可支配的收入用于应急—即使你赚更多的钱，甚至堆金如山，也无助于你到达金字塔的顶端。</p>
<p>然而，即使你幸运地拥有一份可观的收入，你花钱的方式也会对你所花的钱能带来的幸福（或者不幸）产生很大的影响。我可不是危言耸听哦！这是有科学依据的。相关的研究在“If money doesn’t make you happy, then you probablyaren’t spending it right”（如果金钱没能给你带来幸福，那可能是你花钱的方式不对）一文中做了很好的总结。</p>
<p>关于幸福，其实大部分人都不知道它的科学本质—什么能带来幸福？什么又能维持幸福？—也因此，他们不知道怎样使用自己的金钱去获取幸福。那么，下面的事就不足为奇了：一个对酒一窍不通的有钱人，并不见得比他的邻居们更会储存酒；一个对幸福一无所知的有钱人，并不见得比其他人生活得更幸福。金钱是获取幸福的一种机会，但仅仅因为人们觉得应该能给他们带来幸福的东西常常并不能让他们如愿以偿，这种机会很多时候都被白白浪费了。</p>
<p>那么，什么才是幸福的真谛呢？下面，我将尽我所能总结出最基本的8点，但如果你想了解各条原则背后的研究论证过程以及更多的细节，我建议你还是去完整阅读一下那篇论文。（在互联网上可以搜索得到。）</p>
<ol>
<li><p>经历胜过物质</p>
<p> 东西会变旧。东西会变得平淡无奇。东西就是东西，它还会磨损，很难拿来分享。但是经历却完全不同，它是独特的，它在你的记忆里像钻石一样光芒四射，而且常常还会历久弥新。经历永远都可以拿出来与人分享。只要有可能的话，把钱花在经历上（比如带全家去迪士尼乐园玩），而不要花在物质上（比如买一台新电视机）。</p>
</li>
<li><p>助人为乐</p>
<p> 人类本质上是社会性的动物。任何花点钱就能跟其他人建立起更为深入的联系的东西（或事情），将有助于我们的社会关系更加紧密，有助于提升我们自己和他人的正面感受。想一想，你能通过何种方式、只需花费自己一部分的钱就能帮到别人？<strong>勿以善小而不为</strong>。把它们放到你的常规开销计划里去吧！</p>
</li>
<li><p>让幸福细水长流</p>
<p> 人是最能适应变化的。因此，最有效的花钱方式是经常买来一些小变化，而不是花大钱一下子买来一个大惊喜，然后坐等着新鲜劲很快过去。如果可能的话，把一个大的购买计划拆分成多个小的，一点一点慢慢买进来，更好地享受整个过程。<strong>就拿幸福来说吧，频率比强度更重要</strong>。大家需要改变一下观念，记住：很多次小的、愉快的购买实际上比一次巨额的购买更能有效地给你带来幸福。</p>
</li>
<li><p>少买保险</p>
<p> 人能快速适应变化，不管这个变化是正面的还是负面的。额外的担保或保险是在利用我们“损失厌恶”的天性，利用我们的一时冲动。因为人们的适应能力很强，当购买的东西出现故障时，其实他们并不会像原先想象的那样懊恼不已。</p>
<p> 而且，因为人们放弃了享受完整承诺带来的情感利益，保险条款容易不生效或者慷慨的返还政策反而会引起更多的焦虑和不快。因此，避免购买保险，千万别贪图慷慨的返还政策。</p>
</li>
<li><p>为将来埋单</p>
<p> 即刻的喜悦可能会使你冲动买下你承受不起的东西，或者不是你真正想要的东西。冲动购买使你丧失了必要的思考空间，让你难以做出合理的决定。它也无情地扼杀了期待的感觉，而期待恰恰是幸福的源泉。<strong>为了让幸福最大化，你应该尽情享受是否要买、买什么、什么时候到货等问题带来的不确定性，甚至故意把做决定的过程拖长。</strong></p>
</li>
<li><p>三思而后行</p>
<p> <strong>在考虑为将来购置东西的时候，我们常常会忽略一些细节问题。但有研究表明，恰恰是这些被我们忽略的微小细节决定了我们的幸福（或者不幸）。在进行一次重要的采购之前，考虑一下售后服务，同时也想想一旦拥有这样东西之后你到底哪些时间会用在它上面。试着设想将来典型的一天，一小时一小时地细细审视：这东西会如何影响你的生活？</strong></p>
</li>
<li><p>小心比较购物的陷阱</p>
<p> <strong>“比较购物”转移了我们的注意力，使我们过多地关注在这个商品区别于其他商品的一些无足轻重的特性上，而忽略了去评估我们真正有多喜欢这个东西</strong>。他们关注的是我们购物时关心的方面，而不是我们购买之后使用的时候我们所关注的方面。换句话说，花2美元买到一块便宜巧克力（不错的买卖），跟这块巧克力好不好吃其实没什么关系。不要为了比较而比较，谨防掉入比较购物的陷阱。试着去考量那些真正能给你带来快乐或提升体验的指标。</p>
</li>
<li><p>随大流</p>
<p> 不要高估你的能力，别以为你能独立预测你会有多喜欢某样东西。从科学的角度来讲，我们在这方面极其不擅长！但如果某样东西可靠地给其他很多人带来了幸福，那它很可能也会给你带来幸福。在你做出购买决定之前，请认真考量一下别人的看法和用户评论。</p>
<p> 赚钱不容易。跟钱财相比，幸福更是来之不易！因此，当你花钱的时候，请记住上面的8点，这样才能使你买到的幸福最大化。请记住：这是科学！</p>
</li>
</ol>
</li>
<li><p>来也匆匆，去也匆匆，到头来两手空空</p>
<p>…….</p>
</li>
</ul>
</li>
<li><p>abc</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/07/27/operating-systems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/operating-systems/" class="post-title-link" itemprop="url">操作系统导论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-27 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-27T00:00:00+00:00">2019-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 13:18:12" itemprop="dateModified" datetime="2022-01-04T13:18:12+00:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/" itemprop="url" rel="index"><span itemprop="name">博览群书</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中文版：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/33463930/">豆瓣读书</a></p>
<p>英文版：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/19973015/">豆瓣读书</a></p>
<h3 id="第1章-关于本书的对话"><a href="#第1章-关于本书的对话" class="headerlink" title="第1章 关于本书的对话"></a>第1章 关于本书的对话</h3><h3 id="第2章-操作系统介绍"><a href="#第2章-操作系统介绍" class="headerlink" title="第2章 操作系统介绍"></a>第2章 操作系统介绍</h3><h3 id="第3章-关于虚拟化的对话"><a href="#第3章-关于虚拟化的对话" class="headerlink" title="第3章 关于虚拟化的对话"></a>第3章 关于虚拟化的对话</h3><h3 id="第4章-抽象：进程"><a href="#第4章-抽象：进程" class="headerlink" title="第4章 抽象：进程"></a>第4章 抽象：进程</h3><h3 id="第5章-插叙：进程API"><a href="#第5章-插叙：进程API" class="headerlink" title="第5章 插叙：进程API"></a>第5章 插叙：进程API</h3><h3 id="第6章-机制：受限直接执行"><a href="#第6章-机制：受限直接执行" class="headerlink" title="第6章 机制：受限直接执行"></a>第6章 机制：受限直接执行</h3><h3 id="第7章-进程调度：介绍"><a href="#第7章-进程调度：介绍" class="headerlink" title="第7章 进程调度：介绍"></a>第7章 进程调度：介绍</h3><p>  任何公平（fail）的政策（如RR），即在小规模的时间内将CPU均匀分配到活动进程之间，在周转时间这类指标上表现不佳。事实上，这是固有的权衡：如果你愿意不公平，你可以运行较短的工作直到完成，但是要以响应时间为代价。如果你重视公平性，则响应时间会较短，但会以周转时间为代价。这种权衡在系统中很常见。你不能既拥有你的蛋糕，又吃它。</p>
<h3 id="第8章-调度：多级反馈队列"><a href="#第8章-调度：多级反馈队列" class="headerlink" title="第8章 调度：多级反馈队列"></a>第8章 调度：多级反馈队列</h3><pre><code>* 规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A （不运行B）。
* 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B 。
* 规则 3：工作进入系统时，放在最高优先级（最上层队列）。
* 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。
* 规则 5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。
</code></pre>
<h3 id="第9章-调度：比例份额"><a href="#第9章-调度：比例份额" class="headerlink" title="第9章 调度：比例份额"></a>第9章 调度：比例份额</h3><p>  彩票调度通过随机值，聪明地做到了按比例分配。步长调度算法能够确定的获得需要的比例。虽然两者都很有趣，但由于一些原因，并没有作为CPU调度程序被广泛使用。一个原因时这两种方式都不能很好得适合I/O[AC97]；另一个原因是其中最难的票数分配问题并没有确定的解决方式。</p>
<h3 id="第10章-多处理器调度（高级）"><a href="#第10章-多处理器调度（高级）" class="headerlink" title="第10章 多处理器调度（高级）"></a>第10章 多处理器调度（高级）</h3><p>  单队列的方式（SQMS）比较容易构建，负载均衡较好，但在扩展性和缓存亲和度方面有着固有的缺陷。多队列方式（MQMS）又很好的扩展性和缓存亲和度，但实现负载均衡却很困难。</p>
<h3 id="第11章-关于CPU虚拟化的总结对话"><a href="#第11章-关于CPU虚拟化的总结对话" class="headerlink" title="第11章 关于CPU虚拟化的总结对话"></a>第11章 关于CPU虚拟化的总结对话</h3><h3 id="第12章-关于内存虚拟化的对话"><a href="#第12章-关于内存虚拟化的对话" class="headerlink" title="第12章 关于内存虚拟化的对话"></a>第12章 关于内存虚拟化的对话</h3><h3 id="第13章-抽象：地址空间"><a href="#第13章-抽象：地址空间" class="headerlink" title="第13章 抽象：地址空间"></a>第13章 抽象：地址空间</h3><p>  操作系统的一个重要子系统：虚拟内存。虚拟内存负责为程序提供一个巨大的，稀疏的，私有的地址空间的假象，其中保存了程序所有指令和数据。操作系统在专门硬件的帮助下，通过每一个虚拟内存的索引，将其转换为物理地址，物理内存根据获得的物理地址去获取所需的信息。操作系统会同时对许多进程执行此操作，并且确保程序之间互相不会受到印象，也不会影响操作系统。</p>
<h3 id="第14章-插叙：内存操作API"><a href="#第14章-插叙：内存操作API" class="headerlink" title="第14章 插叙：内存操作API"></a>第14章 插叙：内存操作API</h3><h3 id="第15章-机制：地址转换"><a href="#第15章-机制：地址转换" class="headerlink" title="第15章 机制：地址转换"></a>第15章 机制：地址转换</h3><p>  利用地址转换，操作系统可以控制进程的所有内存访问，确保访问在地址空间的界限内。这个技术高效的关键是硬件支持，硬件快速地将所有内存访问操作中的虚拟地址（进程自己看到的内存位置）转换为物理地址（实际位置）。所有的这一切对进程来说都是透明的，进程并不知道自己使用的内存引用已经被重定位，制造了美妙的假象。</p>
<p>  我们还看到了一种特殊的虚拟化方式,称为基址加界限的动态重定位。基址加界限的虚拟化方式非常高效,因为只需要很少的硬件逻辑,就可以将虚拟地址和基址寄存器加起来,并检查进程产生的地址没有越界。基址加界限也提供了保护,操作系统和硬件的协作,确保没有进程能够访问其地址空间之外的内容。保护肯定是操作系统最重要的目标之一。没有保护,操作系统不可能控制机器(如果进程可以随意修改内存,它们就可以轻松地做出可怕的事情,比如重写陷阱表并完全接管系统)。</p>
<p>  遗憾的是,这个简单的动态重定位技术有效率低下的问题。</p>
<h3 id="第16章-分段"><a href="#第16章-分段" class="headerlink" title="第16章 分段"></a>第16章 分段</h3><h4 id="16-1分段：返化的基址-界限"><a href="#16-1分段：返化的基址-界限" class="headerlink" title="16.1分段：返化的基址/界限"></a>16.1分段：返化的基址/界限</h4><p>  一个段只是地址空间里的一个连续定长的区域，在典型的地址空间里有3个逻辑不同的段：代码、栈和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存。</p>
<p>  分段解决了一些问题,帮助我们实现了更高效的虚拟内存。不只是动态重定位,通过避免地址空间的逻辑段之间的大量潜在的内存浪费,分段能更好地支持稀疏地址空间。它还很快,因为分段要求的算法很容易,很适合硬件完成,地址转换的开销极小。分段还有一个附加的好处:代码共享。如果代码放在独立的段中,这样的段就可能被多个运行的程序共享。</p>
<p>  但我们已经知道,在内存中分配不同大小的段会导致一些问题,我们希望克服。首先,是我们上面讨论的外部碎片。由于段的大小不同,空闲内存被割裂成各种奇怪的大小,因此满足内存分配请求可能会很难。用户可以尝试采用聪明的算法[W+95],或定期紧凑内存,但问题很根本,难以避免。</p>
<p>  第二个问题也许更重要,分段还是不足以支持更一般化的稀疏地址空间。例如,如果有一个很大但是稀疏的堆,都在一个逻辑段中,整个堆仍然必须完整地加载到内存中。换言之,如果使用地址空间的方式不能很好地匹配底层分段的设计目标,分段就不能很好地工作。</p>
<h3 id="第17章-空闲空间管理"><a href="#第17章-空闲空间管理" class="headerlink" title="第17章 空闲空间管理"></a>第17章 空闲空间管理</h3><h3 id="第18章-分页：介绍"><a href="#第18章-分页：介绍" class="headerlink" title="第18章 分页：介绍"></a>第18章 分页：介绍</h3><h4 id="18-6-小结"><a href="#18-6-小结" class="headerlink" title="18.6 小结"></a>18.6 小结</h4><p>  作为虚拟内存挑战的解决方案。与以前的方法（如分段）相比，分页有许多优点。首先，它不会导致外部碎片，因为分页（按设计）将内存划分为固定大小的单元。其次，它非常灵活，支持稀疏虚拟地址空间。</p>
<p>  然而，实现分页支持而不小心考虑，会导致较慢的机器（有许多额外的内存访问来访问页表）和内存浪费（内存被页表塞满而不是有用的应用程序数据）。</p>
<h3 id="第19章-分页：快速地址转换（TLB）"><a href="#第19章-分页：快速地址转换（TLB）" class="headerlink" title="第19章 分页：快速地址转换（TLB）"></a>第19章 分页：快速地址转换（TLB）</h3><h4 id="19-2-示例：访问数组"><a href="#19-2-示例：访问数组" class="headerlink" title="19.2 示例：访问数组"></a>19.2 示例：访问数组</h4><blockquote>
<p>提示：尽可能利用缓存</p>
<p>缓存是计算机系统中最基本的性能改进技术之一，一次又ー次地用于让“常见的情况更快”[HPO6]硬件缓存背后的思想是利用指令和数据引用的局部性（ locality）。通常有两种局部性：时间局部性（ temporal locality）和空间局部性（ spatial locality）时间局部性是指，最近访问过的指令或数据项可能很快会再次访问。想想循环中的循环变量或指令，它们被多次反复访问。空间局部性是指，当程序访问内存地址x时，可能很快会访问邻近x的内存。想想遍历某种数组，访问一个接一个的元素。当然，这些性质取决于程序的特点，并不是绝对的定律，而更像是一种经验法则。</p>
<p>硬件缓存，无论是指令、数据还是地址转换（如TLB），都利用了局部性，在小而快的芯片内存倍器中保存一份内存副本。处理器可以先检查缓存中是否存在就近的副本，而不是必须访问（缓慢的）内存未满足请求。如果存在，处理器就可以很快地访问它（例如在几个CPU时钟内），避免花很多时间来访问内存（好多纳秒）。</p>
<p>你可能会疑惑：既然像TLB这样的缓存这么好，为什么不做更大的缓存，装下所有的数据？可惜的是，这里我们遇到了更基本的定律，就像物理定律那样。如果想要快建地线存，它就必须小，因为光建和其他物理限制会起作用。大的缓存注定慢，因此无法实现目的。所以，我们只能用小而快的幾存。剩下的问题就是如何利用好缓存来提升性能。</p>
</blockquote>
<h3 id="第25章-关于并发的对话"><a href="#第25章-关于并发的对话" class="headerlink" title="第25章 关于并发的对话"></a>第25章 关于并发的对话</h3><h3 id="第26章-并发：介绍"><a href="#第26章-并发：介绍" class="headerlink" title="第26章 并发：介绍"></a>第26章 并发：介绍</h3><pre><code>* 临界区(critical section )是访问共享资源的一段代码,资源通常是一个变量或教据结构。

* 竞态条件(race condition)出现在多个执行线程大致同时进入临界区时,它们都试图更新共享的教据结构,导致了令人惊话的(也许是不希望的)结果。

* 不确定性(indeterminate )程序由一个或多个竞态条件组成,程序的输出因运行而异,具体取决于哪些线程在何时运行。这导致结果不是确定的 (deterministic ),而我们通常期望计算机系统给出确定的结果。

* 为了避免这些问题,线程应该使用某种互斥(mutual exclusion )原语。这样做可以保证只有一个线程进入临界区,从而避免出现竟态,并产生确定的程序输出。
</code></pre>
<h3 id="第27章-插叙：线程API"><a href="#第27章-插叙：线程API" class="headerlink" title="第27章 插叙：线程API"></a>第27章 插叙：线程API</h3><pre><code>* **保持简洁**。最重要的一点,线程之间的锁和信号的代码应该尽可能简洁。复杂的线程交互容易产生缺陷。

* **让线程交互减到最少**。尽量减少线程之间的交互。每次交互都应该想清楚,并用验证过的、正确的方法来实现(很多方法会在后续章节中学习)。

* **初始化锁和条件变量**。未初始化的代码有时工作正常,有时失败,会产生奇怪的结果。

* **检查返回值**。当然,任何C和UNIX 的程序,都应该检查返回值,这里也是一样。否则会导致古怪而难以理解的行为,让你尖叫,或者痛苦地。自己的头发。

* **注意传给线程的参数和返回值**。具体来说,如果传递在找上分配的变量的引引用,可能就是在犯错误。

* **每个线程都有自己的栈**。类似于上一条,记住每一个线程都有自己的找。因此,线程局部变量应该是线程私有的,其他他线程不应该访问。线程之间共享數据,值要在堆(heap )或者其他全局可访问的位置。

* **线程之间总是通过条件变量发送信号**。切记不要用标记变量来同步。

* **多查手册**。尤其是Linux 的pthread手册,有更多的细节、更丰富的內容。请仔细阅读!
</code></pre>
<h3 id="第28章-锁"><a href="#第28章-锁" class="headerlink" title="第28章 锁"></a>第28章 锁</h3><p>  如今真实的锁是如何实现的:一些硬件支持(更加强大的指令)和一些操作系统支持(例如 Solaris的 park()和unpark()原语,Linux的 futex)。当然,细节有所不同,执行这些锁操作的代码通常是高度优化的。</p>
<blockquote>
<p>提示：代码越少越好（劳尔定律）</p>
<p>程序员倾向于吹嘘自己使用大量的代码实现某功能。这样做本质上是不对的。我们应该吹嘘以很少的代码实现给定的任务。简洁的代码更易懂，缺陷更少。正如 Hugh Lauer在讨论构建一个飞行员操作系统时说：“如果给同样这些人两倍的时间，他们可以只用一半的代码来实现”[L81]。我们称之为劳尔定律（Lauer’s Law），很值得记住。下次你吹嘘写了多少代码来完成作业时，三思而后行，或者更好的做法是，回去重写，让代码更清断、精简。</p>
</blockquote>
<h3 id="第29章-基于锁的并发数据结构"><a href="#第29章-基于锁的并发数据结构" class="headerlink" title="第29章 基于锁的并发数据结构"></a>第29章 基于锁的并发数据结构</h3><p>  控制流变化时注意获取锁和释放锁；增加并发不一定能提高性能；有性能问题的时候再做优化。关于最后一点，避免不成熟的优化（ premature optimization）对于所有关心性能的开发者都有用。我们让整个应用的某一小部分变快，却没有提高整体性能，其实没有价值。</p>
<blockquote>
<p>提示：更多并发不一定更快</p>
<p>如果方案带来了大量的开销（例如，频繁地获取锁、释放锁），那么高并发就没有什么意义。加果简单的方案很少用到高开销的调用，通常会很有效。增加更多的锁和复杂性可能会适得其反。话虽如此，有一种办法可以获得真知：实现两种方案（简单但少ー点并发，复杂但多一点并发），测试它们的表现。毕竟，你不能在性能上作弊。结果要么更快，要么不快。</p>
</blockquote>
<blockquote>
<p>提示：当心锁和控制流</p>
<p>有一个通用建议，对并发代码和其他代码都有用，即注意控制流的变化导致函数返回和退出，或其他错误情况导致函数停止执行。因为很多函数开始就会获得锁，分配内存，或者进行其他一些改变状态这种模式。的操作，如果错误发生，代码需要在返回前恢复各种状态，这容易出错。因此，最好组织好代码，减少这种模式。</p>
</blockquote>
<blockquote>
<p>建议：避免不成熟的优化（ Knuth定律）</p>
<p>实现并发数据结构时，先从最简单的方案开始，也就是加一把大锁来同步。这样做，你很可能构建了正确的锁。如果发现性能问题，那么就改进方法，只要优化到满足需要即可。正如 Knuth的著名说法“不成熟的优化是所有坏事的根源。”</p>
</blockquote>
<h3 id="第30章-条件变量"><a href="#第30章-条件变量" class="headerlink" title="第30章 条件变量"></a>第30章 条件变量</h3><h3 id="第31章-信号量"><a href="#第31章-信号量" class="headerlink" title="第31章 信号量"></a>第31章 信号量</h3><p>  信号量是编写并发程序的强大而灵活的原语。</p>
<blockquote>
<p>提示：简单的笨办法可能更好（Hil定律）</p>
<p>我们不能小看一个概念，即简单的笨办法可能最好。某些时候简单的自旋锁反而是最有效的，因为它容易实现而且高效。虽然读者一写者锁听起来很酷，但是却很复杂，复杂可能意味着慢。因此，总是优先尝试简单的笨办法。</p>
<p>这种受简单吸引的思想，在多个地方都能发现。一个早期来源是 Mark Hill的学位论文[H87]，研究如何为CPU设计缓存。Hill发现简单的直接映射缓存比花哨的集合关联性设计更加有效（一个原因是在缓存中，越简单的设计，越能够更快地查找）。Hill简洁地总结了他的工作：“大而笨更好。”因此我们将这种类似的建议叫作H定律（Hill’s Law）。</p>
</blockquote>
<h3 id="第32章-常见并发问题"><a href="#第32章-常见并发问题" class="headerlink" title="第32章 常见并发问题"></a>第32章 常见并发问题</h3><p>  非死锁缺陷</p>
<pre><code>* 违反原子性缺陷
* 违反顺序缺陷
</code></pre>
<p>  死锁的产生需要如下4个条件[C+71]</p>
<pre><code>* 互斥：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。
* 持有并等待：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。
* 非抢占：线程获得的资源（例如锁），不能被抢占。
* 循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。
</code></pre>
<h3 id="第33章-基于事件的并发（进阶）"><a href="#第33章-基于事件的并发（进阶）" class="headerlink" title="第33章 基于事件的并发（进阶）"></a>第33章 基于事件的并发（进阶）</h3><h3 id="第34章-并发的总结对话"><a href="#第34章-并发的总结对话" class="headerlink" title="第34章 并发的总结对话"></a>第34章 并发的总结对话</h3><h3 id="第35章-关于持久性的对话"><a href="#第35章-关于持久性的对话" class="headerlink" title="第35章 关于持久性的对话"></a>第35章 关于持久性的对话</h3><h3 id="第36章-I-O设备"><a href="#第36章-I-O设备" class="headerlink" title="第36章 I/O设备"></a>第36章 I/O设备</h3><p>  利用中断减少CPU开销</p>
<blockquote>
<p>提示：中断并非总是比PIO好</p>
<p>尽管中断可以做到计算与IO的重叠，但这仅在慢速设备上有意义。否则，额外的中断处理和上下文切换的代价反而会超过其收益。另外，如果短时间内出现大量的中断，可能会使得系统过載并且引发活锁[MR96]。这种情况下，轮询的方式可以在操作系统自身的调度上提供更多的控制，反而更有效。</p>
</blockquote>
<p>  利用DMA进行更高效的数据传送</p>
<p>  DMA引擎是系统中的一个特殊设备，它可以协调完成内存和设备间的数据传递，不需要CPU介入。</p>
<p>  DMA工作过程如下。为了能够将数据传送给设备，操作系统会通过编程告诉DMA引擎数据在内存的位置，要拷贝的大小以及要拷贝到哪个设备。在此之后，操作系统就可以处理其他请求了。当DMA的任务完成后，DMA控制器会抛出一个中断来告诉操作系统自己已经完成数据传输。</p>
<h3 id="第37章-磁盘驱动器"><a href="#第37章-磁盘驱动器" class="headerlink" title="第37章 磁盘驱动器"></a>第37章 磁盘驱动器</h3><h3 id="第38章-廉价冗余磁盘阵列（RAID）"><a href="#第38章-廉价冗余磁盘阵列（RAID）" class="headerlink" title="第38章 廉价冗余磁盘阵列（RAID）"></a>第38章 廉价冗余磁盘阵列（RAID）</h3><h3 id="第39章-插叙：文件和目录"><a href="#第39章-插叙：文件和目录" class="headerlink" title="第39章 插叙：文件和目录"></a>第39章 插叙：文件和目录</h3><h4 id="39-4-读写文件"><a href="#39-4-读写文件" class="headerlink" title="39.4 读写文件"></a>39.4 读写文件</h4><blockquote>
<p>提示：使用 strace（和类似工具）</p>
<p>straceエ具提供了一种非常棒的方式，来查看程序在做什么。通过运行它，你可以跟踪程序生成的系统调用，查看参数和返回代码，通常可以很好地了解正在发生的事情。</p>
<p>该工具还接受一些非常有用的参数。例如，f跟踪所有fork的子进程，t报告每次调用的时间，-e trace=open， close，read，wite只跟踪对这些系统调用的调用，并忽略所有其他调用。还有许多更强大的标志，请阅读手册页，弄清楚如何利用这个奇妙的工具。</p>
</blockquote>
<h4 id="39-9-删除文件"><a href="#39-9-删除文件" class="headerlink" title="39.9 删除文件"></a>39.9 删除文件</h4><p>  unlink()值需要待删除文件的名称，并在成功时返回零。</p>
<h4 id="39-13-硬链接"><a href="#39-13-硬链接" class="headerlink" title="39.13 硬链接"></a>39.13 硬链接</h4><p>  调用 unlink时，会删除人类可读的名称（正在删除的文件）与给定inode号之间的“链接”，并减少引用计数。只有当引用计数达到零时，文件系统才会释放inode和相关数据块，从而真正“删除”该文件。</p>
<h4 id="39-14-符号链接"><a href="#39-14-符号链接" class="headerlink" title="39.14 符号链接"></a>39.14 符号链接</h4><p>  还有一种非常有用的链接类型，称为符号链接（ symbolic link），有时称为软链接（soft ink）。事实表明，硬链接有点局限：你不能创建目录的硬链接（因为担心会在目录树中创建一个环）。你不能硬链接到其他磁盘分区中的文件（因为 inode号在特定文件系统中是唯的，而不是跨文件系统），等等。</p>
<p>  符号链接实际上与硬链接完全不同。第一个区别是符号链接本身实际上是一个不同类型的文件。我们已经讨论过常规文件和目录。符号链接是文件系统知道的第三种类型。</p>
<p>  链接指向文件的路径名作为链接文件的数据。如果链接到更长的路径名，链接文件会更大。
  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/07/23/misc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/23/misc/" class="post-title-link" itemprop="url">一些工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-23 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-23T00:00:00+00:00">2019-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 13:18:12" itemprop="dateModified" datetime="2022-01-04T13:18:12+00:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index"><span itemprop="name">tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><ol>
<li><p><a target="_blank" rel="noopener" href="http://astyle.sourceforge.net/">AStyle</a> 一个代码格式化工具，虽然代码格式化的工具很多，但是这是我认识的第一款，而且功能也很强大，Linux平台自然也是有的。</p>
 <!-- 个人的配置 待添加 ...---></li>
<li><p><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=Lukamicoder.AStyleExtension">AStyle Extension</a> Visual Studio 版本的 AStyle，仅作标记。另外，Visual Studio 默认配置会自动格式化代码，所以通常我会关闭他的自动格式化代码功能，并且把制表符(tab)用4个空格(space)替代。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.scootersoftware.com/">Beyond Compare</a> 作为程序员应该都用过这个比较工具，而且破解版也比较容易找，文件过滤的功能特别好使！</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://gnuwin32.sourceforge.net/">GnuWin32</a> Windows下的Linux工具集，使用Win7开发必备工具集，在Win10下安装Linux子系统之后似乎就可以不用这些工具了。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
